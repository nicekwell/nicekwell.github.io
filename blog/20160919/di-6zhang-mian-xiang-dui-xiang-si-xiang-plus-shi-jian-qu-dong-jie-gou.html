<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <title>第6章 面向对象思想+事件驱动结构 - 生命不息 折腾不止</title>
  <meta name="author" content="nicekwell">

  
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://nicekwell.github.io/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou.html">
  <link href="/favicon.png" type="image/png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="生命不息 折腾不止" type="application/atom+xml">

  <!-- http://opengraphprotocol.org/ -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://nicekwell.github.io/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou.html">
  <meta property="og:title" content="第6章 面向对象思想+事件驱动结构 - 生命不息 折腾不止">
  

  <script src="/javascripts/libs/jquery/jquery-2.1.3.min.js"></script>

<link href="/assets/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet" type="text/css">


  
  <link href="/stylesheets/screen.css" media="screen, projection, print" rel="stylesheet" type="text/css">

  

</head>

  <body   >
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="wrap">
      <header role="banner">
        <nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" title="toggle navbar" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">生命不息 折腾不止</a>
        </div>

        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li class="active">
                    <a rel="index" href="/">Blog</a>
                </li>
                <li >
                    <a href="/blog/archives">Archives</a>
                </li>
		<li >
                    <a href="/dan-pian-ji-bian-cheng">单片机编程</a>
                </li>
		<li >
                    <a href="/ping-heng-de-shi-jie">平衡的世界</a>
                </li>
		<li >
                    <a href="/diy">DIY</a>
                </li>
		<li >
                    <a href="/about">About</a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a class="subscribe-rss" href="/atom.xml" title="subscribe via RSS">
                        <span class="visible-xs">RSS</span>
                        <img class="hidden-xs" src="/images/rss.png" alt="RSS">
                    </a>
                </li>
                
            </ul>
            
                <form class="navbar-form navbar-right" action="https://www.google.com/search" method="GET">
                    <input type="hidden" name="sitesearch" value="nicekwell.github.io">
                    <div class="form-group">
                        <input class="form-control" type="text" name="q" placeholder="Search">
                    </div>
                </form>
            
        </div>
    </div>
</nav>


      </header>
      <div id="main" role="main" class="container">
        <div id="content">
          <div class="row">
  <div class="page-content col-md-9" itemscope itemtype="http://schema.org/Blog">
    <meta itemprop="name" content="生命不息 折腾不止" />
    
    <meta itemprop="url" content="http://nicekwell.github.io" />
    <article class="hentry" role="article" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
      
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2016-09-19T23:52:32+08:00"  data-updated="true" itemprop="datePublished dateCreated">2016年9月19日</time>
        
      </p>
    
    
    <h1 class="entry-title" itemprop="name headline">
        第6章 面向对象思想+事件驱动结构
        
    </h1>
    
  </header>


<div class="entry-content clearfix" itemprop="articleBody description"><ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 对象和事件</a></li>
  <li><a href="#c" id="markdown-toc-c">2. C语言对一个对象的封装</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">3. 事件分配机制</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">4. 系统层构建</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">5. 库函数</a></li>
</ul>

<p>  先来看一下这个东西吧：<a href="http://v.youku.com/v_show/id_XNTk2NzExMjg4.html">http://v.youku.com/v_show/id_XNTk2NzExMjg4.html</a>。</p>

<p>  看完之后应该会觉得这个东西的结构非常复杂，这是笔者做过的最复杂的项目之一。由于是给公司开发的，所以和上一章一样不能公开源代码，但是会举一些简单的例子说明。<br />
  刚接到这个项目了解了大体功能后，第一反应是用“界面函数”的结构。确实，这个东西是非常适合用界面函数完成的，但是由于当时笔者正在自学C++，于是用C++的思路分析了一下这个项目：<br />
  1、总共有4个界面，而且有两个和列表框好像啊。<br />
  2、几乎所有的动作都是由旋转编码器触发的。<br />
  经过一番思考之后，笔者决定做一次尝试，用面向对象的思想加上事件驱动的机制完成它。</p>

<p>  下面就介绍一下这种结构，也希望能借此说明“对象”和“事件”的概念。</p>

<!-- more -->

<h1 id="section">1. 对象和事件</h1>

<p>  基本上每个面向对象语言的书都会把对象的概念说一下。在这个项目里有4个界面，把这四个界面看作四个对象，这四个对象的所有动作都由事件驱动。<br />
  什么又是“事件”呢？简单来说“一个对象发生了某个事情”就是这个对象的某种事件。事件一定是基于某个特定的对象而言的，不能简单地说“发生了某个事情”，应该说“某个对象发生了某个事情”。而我们要做的就是确定“每个对象有哪些事情会发生”，并完成“某个对象在发生某个事情时要做的事”。</p>

<p>  所以对于一个对象而言，它应该有：</p>

<ul>
  <li>1、与它对应的事件函数，用于执行“某个事件发生时要做的事”，一个对象所拥有的这些函数的个数和它可能发生的事件数是相等的。</li>
  <li>2、完成上述函数所需要的辅助函数。<br />
这些函数有些可能是公共的，是由系统提供的API或者其他工具函数；<br />
也可能是这个对象特有的，是对这个对象做的某种更改。</li>
  <li>3、每个对象都有自己的属性，这些属性在程序中的体现就是变量。</li>
</ul>

<p>  这里面，1和2的函数本质上都是一样的，都是这个对象所包含的函数。不同的是：<br />
  与事件相对应的函数称它为这个对象的“事件”，这些函数数量与这个对象的事件数是相等的；<br />
  完成某种特定操作的函数称它为这个对象的“方法”，也就是“这个对象可以做的事”。并且这些方法中，有些是允许被外界调用的，有些只允许在本对象内使用，所以又分为“公共方法”和“私有方法”。</p>

<p>  下面就以一张表来说明一个对象内部的组成，以及各个成员的含义：</p>

<p><img src="/images/dan-pian-ji-bian-cheng/duixiang.png" alt="对象的组成" /></p>

<p>  有了这些了解之后我们就可以开始构建整个系统了。</p>

<h1 id="c">2. C语言对一个对象的封装</h1>

<p>  在C++ 中有专门的对象结构，它可以把对象里的函数和变量分为公共、私有等类型。</p>

<p>  而在C语言中没有这样的结构，我们通过使用上的约定也可以达到同样的效果。比如一个内部的函数，我们约定有些函数外部可以调用，它就是公共函数；约定有些函数外部不要调用，它就是私有函数。</p>

<p>  下面是对象的各个部分在C语言中的形式及意义：</p>

<p><img src="/images/dan-pian-ji-bian-cheng/duixiang1.png" alt="对象的各个部分在C语言中的形式及意义" /></p>

<p>  公共方法和事件本质上都是对外公开的函数。公共方法完成对本对象的某一主动的操作，而事件是完成对外部被动的响应。<br />
  甚至可以把事件从对象的组成中取出来，把事件归到系统范畴。</p>

<hr />

<p>  下面就以一个简单的列表框的例子说明如何封装一个对象，假设这个列表框（对象）的名字叫做List1，一共只有3个列表项，每个列表项都有一个自己的名称和内容（0~255），有一个光标指示当前选中列表项，分配的事件有“列表项+1”“列表项-1”“列表项内容+1”“列表项内容-1”，并且这些改变是可以循环的（255+1=0，0-1=255）。</p>

<p>  假设屏幕显示的网格是4行16列，外部提供的绘图函数有：<br />
  Disp(r,c,unsigned char *)       //往r行c列写入一个字符串<br />
  Clear()        //清屏</p>

<p>  有了这些条件后，对这个对象的封装如下：</p>

<ul>
  <li>List1.c</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* List1 */
</span><span class="line">void Clear();	//清屏函数
</span><span class="line">void Disp(unsigned char r,unsigned char c,unsigned char *p);	//在r行c列显示字符串
</span><span class="line">/**************公共变量*****************/
</span><span class="line">#define List1_ListCount 3	//列表长度为固定
</span><span class="line">unsigned char List1_ListIndex=0;	//当前选中的列表项，从0开始数
</span><span class="line">#define List1_StartIndex 0	/*当前屏幕显示的第一个列表项序号，从开始数，
</span><span class="line">				由于屏幕能一次性把所有的3个列表项都显示出来，所以这里是固定的值。*/
</span><span class="line">unsigned char List1_ListData[3];	//三个列表项的数据
</span><span class="line">/**************私有变量***************/
</span><span class="line">unsigned char code List1_Name0[]="Power";	//第0号列表项的名称
</span><span class="line">unsigned char code List1_Name1[]="Mode ";	//第1号列表项的名称
</span><span class="line">unsigned char code List1_Name2[]="K    ";	//第2号列表项的名称
</span><span class="line">/**************私有方法***************/
</span><span class="line">void List1_DispName()	//在固定位置显示个列表项的名称
</span><span class="line">{
</span><span class="line">	Disp(0,1,ListName0);	//显示号列表项名称
</span><span class="line">	Disp(1,1,ListName1);	//显示号列表项名称
</span><span class="line">	Disp(2,1,ListName2);	//显示号列表项名称
</span><span class="line">}
</span><span class="line">void List1_DispCursor()	//在当前选中列表项前显示“&gt;”，没选中的显示空格
</span><span class="line">{
</span><span class="line">	unsigned char i;
</span><span class="line">	for(i=0;i&lt;List1_ListCount;i++)
</span><span class="line">	{
</span><span class="line">		if(i==List1_ListIndex)
</span><span class="line">			Disp(i,0,"&gt;");
</span><span class="line">		else
</span><span class="line">			Disp(i,0," ");
</span><span class="line">	}
</span><span class="line">}
</span><span class="line">void List1_DispData(unsigned char n)	//显示n号列表项的数据
</span><span class="line">{
</span><span class="line">	unsigned char vm[4];	//现存，以十进制显示，总共三位数
</span><span class="line">	//先计算现存
</span><span class="line">	vm[0]=List1_ListData[n]/100+0x30;	//计算百位的现存
</span><span class="line">	vm[1]=(List1_ListData[n]%100)/10+0x30;	//计算十位的现存
</span><span class="line">	vm[2]=List1_ListData[n]%10+0x30;	//计算个位的现存
</span><span class="line">	vm[3]='\0';	//字符串结尾
</span><span class="line">	//下面开始显示
</span><span class="line">	Disp(n,10,vm);	//从n行列开始写入数据
</span><span class="line">}
</span><span class="line">/***************公共方法************************/
</span><span class="line">void List1_Show()
</span><span class="line">{
</span><span class="line">	//先清屏
</span><span class="line">	Clear();
</span><span class="line">	//再显示所有列表项的名称
</span><span class="line">	List1_DispName();
</span><span class="line">	//再显示所有列表项的数据
</span><span class="line">	{
</span><span class="line">		unsigned char i;
</span><span class="line">		for(i=0;i&lt;List1_ListCount;i++)
</span><span class="line">			List1_DispData(i);
</span><span class="line">	}
</span><span class="line">	//再显示光标
</span><span class="line">	List1_DiapCursor();
</span><span class="line">}
</span><span class="line">void List1_Hide()
</span><span class="line">{
</span><span class="line">	Clear();
</span><span class="line">}
</span><span class="line">void List1_SelectedListP1()	//当前选中项内容+1
</span><span class="line">{
</span><span class="line">	List1_ListData[List1_ListIndex]++;
</span><span class="line">	List1_DispData(List1_ListIndex);
</span><span class="line">}
</span><span class="line">void List1_SelectedListM1()	//当前选中项内容-1
</span><span class="line">{
</span><span class="line">	List1_ListData[List1_ListIndex]--;
</span><span class="line">	List1_DispData(List1_ListIndex);
</span><span class="line">}
</span><span class="line">void List1_ListP1()	//选中项序号+1
</span><span class="line">{
</span><span class="line">	List1_ListIndex++;
</span><span class="line">	if(List1_ListIndex==3)	//实现循环
</span><span class="line">		List1_ListIndex=0;
</span><span class="line">	List1_DispCursor();	//刷新光标
</span><span class="line">}
</span><span class="line">void List1_ListM1()	//选中项序号-1
</span><span class="line">{
</span><span class="line">	List_ListIndex--;
</span><span class="line">	if(List_ListIndex==0xff)	//实现循环
</span><span class="line">		List1_ListIndex=2;
</span><span class="line">	List1_DispCursor();	//刷新光标
</span><span class="line">}
</span><span class="line">/**************事件******************/
</span><span class="line">void List1_Key0Down()	//0号键按下，让选中项序号-1
</span><span class="line">{
</span><span class="line">	List1_ListM1();
</span><span class="line">}
</span><span class="line">void List1_Key1Down()	//1号键按下，让选中项序号+1
</span><span class="line">{
</span><span class="line">	List1_ListP1();
</span><span class="line">}
</span><span class="line">void List1_Key2Down()	//2号键按下，让选中项内容-1
</span><span class="line">{
</span><span class="line">	List1_SelectedListM1();
</span><span class="line">}
</span><span class="line">void List1_Key3Down()	//3号键按下，让选中项内容+1
</span><span class="line">{
</span><span class="line">	List1_SelectedListP1();
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  在其他地方只要包含这个List1.c文件就可以调用该对象里的各种方法和事件函数了，里面的私有方法和私有变量虽然约定外部是不要使用的，但是外部确实是可以调用的。所以也可以为这个对象写一个List1.h文件，只把公开的部分进行声明：</p>

<ul>
  <li>List1.h</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* List1 */
</span><span class="line">#ifndef LIST1_H
</span><span class="line">#define LIST1_H
</span><span class="line">
</span><span class="line">#define List1_ListCount 3	//列表长度为固定
</span><span class="line">unsigned char List1_ListIndex=0;	//当前选中的列表项，从开始数
</span><span class="line">#define List1_StartIndex 0	/*当前屏幕显示的第一个列表项序号，从开始数，
</span><span class="line">					由于屏幕能一次性把个列表项都显示出来，所以这里是固定。*/
</span><span class="line">unsigned char List1_ListData[3];	//三个列表项的数据
</span><span class="line">/***************公共方法************************/
</span><span class="line">void List1_Show();
</span><span class="line">void List1_Hide();
</span><span class="line">void List1_SelectedListP1();	//当前选中项内容+1
</span><span class="line">void List1_SelectedListM1();	//当前选中项内容-1
</span><span class="line">void List1_ListP1();//选中项序号+1
</span><span class="line">void List1_ListM1();//选中项序号-1
</span><span class="line">/**************事件******************/
</span><span class="line">void List1_Key0Down();	//0号键按下，让选中项序号-1
</span><span class="line">void List1_Key1Down();	//1号键按下，让选中项序号+1
</span><span class="line">void List1_Key2Down();	//2号键按下，让选中项内容-1
</span><span class="line">void List1_Key3Down();	//3号键按下，让选中项内容+1
</span><span class="line">
</span><span class="line">#endif</span></code></pre></td></tr></table></div></figure>

<p>  如果采用了List1.h的话，要把List1.c文件里重复定义的部分给去掉。<br />
  每个对象有每个对象的特点，它们差别很大，构建方法也是大不相同的。但是每个对象构建好之后就是一个模板，它是非常独立的，在其他地方只要把代码直接复制过去做少量更改就可以使用了。</p>

<h1 id="section-1">3. 事件分配机制</h1>

<p>  一个工程中会有多个对象，每个对象都有一些可能会发生的事件，这些事件函数是由系统调用的，由系统来判断什么对象发生了什么事件。<br />
  比如在这个项目中，基本的事件有：左编码器按下、右编码器按下、左编码器左旋、左编码器右旋、右编码器左旋、右编码器右旋、左编码器按下左编码器左旋、左编码器按下左编码器右旋、右编码器按下右编码器左旋、右编码器按下右编码器右旋、串口接收数据事件、IIC接收数据事件。<br />
  由于旋转编码器的驱动本身用的就是外部中断，外部中断对单片机来说就是一种意外事件。所以只要在中断里判断当前进行的是什么操作，并记录当前哪个界面正在被使用，就可以调用相应对象的相应事件了。<br />
  然而，并不是所有的对象都一定具有所有的这些事件，根据该对象功能的需要，选用一部分有用的事件进行响应。比如在IIC界面里不考虑串口，这个界面就只响应IIC接收数据事件，而忽略串口接收数据事件。<br />
  事件并不一定非要由外部中断产生，也可能是系统虚拟的。<strong>总之事件分配有系统完成，系统利用各个资源抽象出事件概念，然后分配到相应对象上。</strong></p>

<p>  下面是一个完成事件分配的例子：</p>

<p><img src="/images/dan-pian-ji-bian-cheng/eint.png" alt="中断电路" /></p>

<p>  有两个按键，任意一个按键按下都会触发int0中断。假设共有2个对象，下面是事件分配的代码：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
</pre></td><td class="code"><pre><code class=""><span class="line">unsigned char FocusNum=0;	//标志当前获焦的对象序号，在此只有两个对象，范围是0~1
</span><span class="line">sbit kint0=P3^2;
</span><span class="line">sbit k0=P0^0;
</span><span class="line">sbit k1=P0^1;
</span><span class="line">
</span><span class="line">……
</span><span class="line">
</span><span class="line">void int0() interrupt 0
</span><span class="line">{
</span><span class="line">    EA=0;	//关中断
</span><span class="line">
</span><span class="line">    if(k0==0)	//说明是k0按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_k0Down();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_k0Down();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    else if(k1==0)	//说明是k1按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_k1Down();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_k1Down();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    while(kint0==0);	//等待两个按键都释放     IE0=0;	//清除中断标志，防止在中断处理程序执行过程中再次触发了中断     EA=1;	//开中断
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  采用FocusNum来记录当前激活的对象。</p>

<p>  在此想说明的是，k0和k1两个操作都是放在一个中断里的，具体产生什么事件则是再次通过代码判断的，这些代码属于系统层，是根据实际需要对事件的抽象。</p>

<p>  比如如果需要产生“两个按键同时按下”事件，则可按如下方式分配：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void int0() interrupt 0
</span><span class="line">{
</span><span class="line">    unsigned char 
</span><span class="line">    EA=0;	//关中断
</span><span class="line">    mdelay(200);    //这个延时是为了等待两个按键的状态都稳定，虽然我们是把两个按键同时按下，
</span><span class="line">                    //但肯定因为某个先按下触发中断，此时检测另一个按键不一定是按下的状态
</span><span class="line">    if(k0==0 &amp;&amp; k1!=0)	//说明是k0按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_k0Down();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_k0Down();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    else if(k1==0 &amp;&amp; k0!=0)	//说明是k1按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_k1Down();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_k1Down();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    else if(k0==0 &amp;&amp; k0==0)	//两个按键都按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_BothDown();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_BothDown();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    while(kint0==0);	//等待两个按键都释放
</span><span class="line">    IE0=0;	//清除中断标志，防止在中断处理程序执行过程中再次触发了中断
</span><span class="line">    EA=1;	//开中断
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  甚至可以继续改，实现“k0按下时k1按下”“k1按下时k0按下”“k0长按”“k0连按”等事件，这里就不一个个实现了。<br />
  总之只要系统层能够识别的动作都可以抽象成事件。</p>

<h1 id="section-2">4. 系统层构建</h1>

<p>  在以前的编程中从来没把程序这么明确地分层，可能是因为这次项目比较复杂，并且用来面向对象的方法，所以这种结构自然就产生了。在各个对象中有一些公共方法，这些函数完成特定的功能，而他们都依赖于底层的支持。<br />
  当然可以让对象直接操作驱动函数，从最底层开始。但是这样的话，一方面用起来会很麻烦，另一方面可能不是所有的底层功能都会用到。<br />
  所以让系统层根据上层对象的需要把这些功能封装，并向上层提供使用接口。这是系统层做的事情之一。<br />
  另外系统层也会构建一些控制逻辑，这些功能并不在底层有实体的驱动函数，它是系统在软件层面抽象出来的。比如当前系统的数据显示进制、背光灯时间等，它们不对应底层的操作，仅在系统层抽象。对于上层的对象来说，根本不需要考虑这些，只要调用系统层提供的API就行了。<br />
  此外，系统层要做的当然还有事件分配，上一节介绍的事件分配系统是系统层核心的一部分，而系统层还有其他很多功能。事件分配系统是利用各个资源抽象出事件概念，并分配给各个对象。而本节讨论的系统层是利用各个资源，在底层驱动的支持下，根据需要构建出一些控制逻辑，并封装成系统API，供上层软件使用。</p>

<p>  综上，系统层做的事情有：<br />
  1、构建事件分配系统。<br />
  2、对底层驱动封装，并向上层提供操作接口。<br />
  3、根据需要再构建一些其他控制结构，并向上提供接口。</p>

<h1 id="section-3">5. 库函数</h1>

<p>  库函数也属于对系统对底层的封装。某些功能可能比较复杂，可以构成一整套体系，那么就可以把这些函数归位一类，作为完成某个功能的库函数。<br />
  这点和类似于操作系统的GTK库或者QT库，它们提供了大量的绘图函数。<br />
  在本项目中，使用了绘图库，它就是在底层对液晶屏操作的基础上建立的文字和图片显示函数，提供了在指定位置写入字符、汉字，以及反色写入、垂直镜像写入等功能。上层的对象调用这些函数会非常方便。<br />
  总结一下库的作用：利用系统层的API，或者跳过系统层直接调用驱动函数，构建出自己的一套控制逻辑，并对外提供基于这个控制逻辑的函数库。</p>

</div>


      <footer>
        <p class="meta text-muted">
          
  

<span class="glyphicon glyphicon-user"></span> <span class="byline author vcard" itemprop="author" itemscope itemtype="http://schema.org/Person">Posted by <span class="fn" itemprop="name">nicekwell</span></span>

          












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2016-09-19T23:52:32+08:00"  data-updated="true" itemprop="datePublished dateCreated">2016年9月19日</time>
          

<span class="glyphicon glyphicon-tags"></span>&nbsp;
<span class="categories">
  
    <a class='category' href='/blog/categories/dan-pian-ji-bian-cheng/'>单片机编程</a>
  
</span>


        </p>
        
          <div class="sharing">
  
  
  
</div>

        
        
          <ul class="meta text-muted pager">
            
            <li class="previous"><a href="/blog/20160919/di-5zhang-ding-shi-qi-zhi-xing-ren-wu.html" title="Previous Post: 第5章 定时器执行任务">&laquo; 第5章 定时器执行任务</a></li>
            
            
          </ul>
        
      </footer>
    </article>
    
      <section>
        <h2>Comments</h2>
        <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
      </section>
    
  </div>

  
  <aside class="sidebar col-md-3">
    
      <section class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">Recent Posts</h3>
  </div>
  
  <div id="recent_posts" class="list-group">
    
    <a class="list-group-item active" href="/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou.html">第6章 面向对象思想+事件驱动结构</a>
    
    <a class="list-group-item " href="/blog/20160919/di-5zhang-ding-shi-qi-zhi-xing-ren-wu.html">第5章 定时器执行任务</a>
    
    <a class="list-group-item " href="/blog/20160919/di-4zhang-zhan-yong-shi-yu-fei-zhan-yong-shi-cheng-xu-jie-gou.html">第4章 占用式与非占用式程序结构</a>
    
    <a class="list-group-item " href="/blog/20160919/di-3zhang-ding-shi-qi-fen-pei-ren-wu.html">第3章 定时器分配任务</a>
    
    <a class="list-group-item " href="/blog/20160919/di-2zhang-jie-mian-han-shu-jie-gou.html">第2章 “界面函数”结构</a>
    
  </div>
</section>






    
  </aside>
  
</div>

        </div>
      </div>
    </div>
    <footer role="contentinfo"><div class="container">
    <p class="text-muted credits">
  Copyright &copy; 2016 - nicekwell<br>
  <small>
      <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>,
      <span class="credit">customized with <a href="https://github.com/kAworu/octostrap3">octostrap3</a></span>.
  </small>
</p>

</div>
</footer>
    

<script type="text/javascript">
      var disqus_shortname = 'nicekwell';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://nicekwell.github.io/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou.html';
        var disqus_url = 'http://nicekwell.github.io/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou.html';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>








<script src="/assets/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="/javascripts/modernizr.js"></script>


  </body>
</html>
