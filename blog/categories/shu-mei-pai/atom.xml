<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 树莓派 | 生命不息 折腾不止]]></title>
  <link href="http://nicekwell.net/blog/categories/shu-mei-pai/atom.xml" rel="self"/>
  <link href="http://nicekwell.net/"/>
  <updated>2017-11-23T20:22:29+08:00</updated>
  <id>http://nicekwell.net/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-UART串口]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-uartchuan-kou.html"/>
    <updated>2017-11-23T20:05:37+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-uartchuan-kou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">0、包含头文件</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">1、打开串口</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">2、写入（发送）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">3、读取（接收）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">4、缓冲区操作</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">5、关闭串口</a></li>
</ul>
<p>  </p>

<p>前面介绍了python操作串口的方法，是通过通用的串口库实现的。<br />
用c语言当然也可以通过通用串口接口实现，而wiringPi也提供了自己的一套串口操作函数，可以很方便地操作串口。<br />
事实上，wiringPi就是在上层利用通用串口操作接口，封装了一套自己的库函数。</p>

<!-- more -->

<h3 id="section">概述</h3>

<p>在前面python串口编程处就介绍了，树莓派3B的板载串口被蓝牙占用，但可以方便地使用USB串口模块。</p>

<p>树莓派的板载串口是给系统登录使用的，我们要先把这个功能关掉。<br />
<strong>sudo raspi-config</strong><br />
Advanced Options –&gt; Serial –&gt; 关闭串口 –&gt; 重启</p>

<p>树莓派上有两个串口，一个硬件串口，工作稳定，但是分配给了蓝牙；还有一个“mini-uart”，这个串口的时钟是由内核提供，所以不太稳定 。 在树莓派3B上，蓝牙和硬件串口是不能兼得。<br />
这个链接(http://ukonline2000.com/?p=880)有介绍如何把硬件串口分配到GPIO14、GPIO15上，这里不做介绍了。</p>

<p>总之，在树莓派3B上，想要使用板载硬件串口是比较麻烦的，我们这里使用的是USB转串口模块，也能很方便地使用串口。</p>

<h3 id="section-1">0、包含头文件</h3>

<p><strong>#include &lt;wiringSerial.h&gt;</strong></p>

<h3 id="section-2">1、打开串口</h3>

<p><strong>&lt;fd&gt; = serialOpen(char* device, int buad);</strong><br />
【功能】<br />
打开串口文件，并设置波特率，返回文件编号。<br />
【输入】</p>

<table>
  <tbody>
    <tr>
      <td>*device</td>
      <td>设备路径的字符串。比如 “/dev/ttyUSB0”</td>
    </tr>
    <tr>
      <td>buad</td>
      <td>波特率，是一个数值。可以设置为：2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</td>
    </tr>
  </tbody>
</table>

<p>【输出】一个文件编号，代表这个串口设备文件，后面对这个串口的操作都会用到。<br />
【说明】<br />
1、wiringPi提供的设置（以及后面的读写功能）是简化的文件操作，可以满足大部分需求。<br />
2、这里的<file编号>是标准的linux文件描述符，可以使用linux标准的文件操作函数write()、read()等来操作。</file编号></p>

<p>后面也会有说明，wiringPi提供的读写功能是简化的，不提供二进制数值读写，但是可以使用linux标准的读写函数来操作。</p>

<h3 id="section-3">2、写入（发送）</h3>

<p><strong>void serialPutchar(int fd, unsigned char c) ;</strong><br />
【功能】发送一个字节数据。<br />
【输入】<br />
fd是打开串口时的文件描述符。<br />
输入的就是一个字节数据，可以用字符表示，也可以用十六进制数表示。</p>

<p><strong>void serialPuts(int fd, char *s) ;</strong><br />
【功能】发送字符串。<br />
【输入】<br />
fd是打开串口时的文件描述符。<br />
*s 是一个字符串，会发送该字符串，直到’\0’结束。<strong>‘\0’不会发送出去。</strong></p>

<p><strong>void serialPrintf(int fd, char *message, …) ;</strong><br />
【功能】功能类似于printf，可以同时发送多个字符串。</p>

<p> </p>

<p>注意：<strong>以上两个发送函数只是把数据推送到发送缓冲区里，不会等待串口发送完成。</strong>后续程序如果要用到用到串口返回数据应当要考虑到串口传输时间。<br />
<strong>并且最好等之前的数据全部发送完成后再发送新数据，否则可能会出问题，这也要考虑到串口发送数据的时间，可能需要等待。</strong><br />
关键是上层还没有找到判断串口发送完成的方法。</p>

<h3 id="section-4">3、读取（接收）</h3>

<p><strong>int serialDataAvail(int fd) ;</strong><br />
【功能】获取接收缓冲区里的字节数。<br />
【输入】创建串口设备文件时的文件描述符。<br />
【输出】接收缓冲区里所存放的数据字节数。</p>

<p><strong>int serialGetchar(int fd) ;</strong><br />
【功能】从接收缓冲区里读取一个字节数据。<br />
【输入】创建串口设备文件时的文件描述符。<br />
【输出】读取到的一个字节内容。虽然是一个字节内容，但仍然定义为了int型。<br />
【说明】<br />
<strong>如果缓冲区里没有数据，则会等待10s，相当于python里把timeout设置为10s。<br />
10s过后如果还没有数据的话，则会返回 -1，十六进制显示为 0xffffffff。</strong>
这里的10s是wiringPi默认的，查看源代码可以看到：<br />
<img src="/images/raspberrypi/2017-11-23-shu-mei-pai-wiringpi-uartchuan-kou/1.png" alt="1.png" /></p>

<h3 id="section-5">4、缓冲区操作</h3>
<p><strong>void serialFlush(int fd) ;</strong><br />
清空缓冲区，放弃所有数据。</p>

<h3 id="section-6">5、关闭串口</h3>
<p><strong>void serialClose(int fd) ;</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-优先级&amp;中断&amp;线程]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng.html"/>
    <updated>2017-11-23T19:48:00+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi库真是包含了各个方面，甚至提供了进程操作接口。<br />
使用wiringPi的接口可以很方便地创建新进程。</p>

<!-- more -->

<p> </p>

<p><strong>int piHiPri (int priority) ;</strong><br />
设置进程优先级。范围是0~99，数字越大优先级越高，默认是0。<br />
返回0代表成功，返回-1代表失败。<br />
注：必须已root身份运行，否则无效。</p>

<p> </p>

<p><strong>int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;</strong><br />
设置某个pin作为中断脚，当触发中断时调用指定函数。<br />
估计实现原理是后台用了一个定时器不断扫描这个引脚。<br />
pin是引脚序号，编号方式在Setup时决定。<br />
edgeType是中断触发方式：</p>

<table>
  <tbody>
    <tr>
      <td>INT_EDGE_FALLING</td>
      <td>下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_RISING</td>
      <td>上升沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_BOTH</td>
      <td>上升沿和下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_SETUP</td>
      <td>未设置</td>
    </tr>
  </tbody>
</table>

<p>中断处理函数传入函数指针即可。</p>

<p> </p>

<p><strong>int piThreadCreate (PI_THREAD func) ;</strong><br />
创建一个线程执行func函数。要求func函数用PI_THREAD声明。<br />
返回0代表创建成功，非0代表失败。<br />
例：</p>

<p><code>c
PI_THREAD (func)    //注意这种声明方式，函数名用括号括起来，不带参数
{
	...
}
void main()
{
	...
	piThreadCreate(func);
	...
}
</code></p>

<p> </p>

<p><strong>piLock (int keyNum) ;</strong><br />
<strong>piUnlock (int keyNum) ;</strong><br />
获取锁和释放锁。wiringPi-C提供了4个锁，keyNum范围是0~3。<br />
默认所有所都是释放状态，当调用piLock()想要获取锁时，如果这个锁没有被释放则会一直等待，直到这个锁被释放才会拿到这个锁并继续运行下去。<br />
这里的锁可以理解为某个资源，使用该资源时调用piLock()标志该资源正在被使用，使用结束后调用piUnlock()表示释放该资源。其他地方想要使用该资源也必须先获取这个锁，如果没有获取到则等待使用者释放资源后再使用。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-时间函数]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu.html"/>
    <updated>2017-11-23T19:27:41+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi不仅提供硬件操作的接口，同时也提供了一些时间管理函数。</p>

<!-- more -->

<p> </p>

<p><strong>void delay (unsigned int howLong)</strong><br />
延时ms，最大传入32位无符号型整数，大约49天。<br />
实际上是睡眠，不占用cpu。<br />
由于linux是多任务的，所以实际延时时间可能会更长。</p>

<p> </p>

<p><strong>void delayMicroseconds (unsigned int howLong)</strong><br />
延时微秒，最大传入32位无符号型整数，大约71分钟。</p>

<p>wiringPi的库文件中有这样一个函数：
```c
	void delayMicrosecondsHard (unsigned int howLong)
	{
	  struct timeval tNow, tLong, tEnd ;</p>

<pre><code>  gettimeofday (&amp;tNow, NULL) ;
  tLong.tv_sec  = howLong / 1000000 ;
  tLong.tv_usec = howLong % 1000000 ;
  timeradd (&amp;tNow, &amp;tLong, &amp;tEnd) ;

  while (timercmp (&amp;tNow, &amp;tEnd, &lt;))
    gettimeofday (&amp;tNow, NULL) ;
} ``` 其实 delayMicroseconds 函数会判断传入时间如果小于100us就使用 delayMicrosecondsHard 占用式延时，否则会调用 nanosleep 函数。   如果我们想要精确延时，是可以使用 delayMicrosecondsHard 函数的，这个函数在.h文件里没有声明，但已经编译完成，只要用 void delayMicrosecondsHard (unsigned int howLong); 把此函数声明一下就可以使用了。
</code></pre>

<p> </p>

<p><strong>unsigned int millis (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是ms。</p>

<p> </p>

<p><strong>unsigned int micros (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是us。<br />
<strong>测试发现这个函数获取时间速度是很快地，此函数执行时间大约1us，也就是说连续执行两次此函数时间相差大约1us。</strong>在用树莓派处理对时间比较敏感的任务时可能会在意这些时间。</p>

<p>树莓派中经常需要精确地周期性执行某个动作，可以用如下方式精确定时，类似于单片机里的定时器：
<code>c
#define INTERVAL 20000 //间隔时间，单位是us
int main(int argc, char *argv[])
{
    long tim;
    /* do something */
    tim = micros();
    while(1)
    {
      if(micros() - tim &gt;= INTERVAL)
      {
            tim += INTERVAL;
            /* do something */
        }
    }
    return 0;
}
</code></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-GPIO]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio.html"/>
    <updated>2017-11-22T20:07:42+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p>GPIO接口在官网有详细的说明：<a href="http://wiringpi.com/reference/core-functions/">http://wiringpi.com/reference/core-functions/</a></p>

<p>wiringPi的GPIO序号如下：<br />
<img src="/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/1.jpg" alt="1.jpg" /></p>

<p> </p>

<p><strong>void pinMode (int pin, int mode) ;</strong><br />
设置GPIO模式。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
mode可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>INPUT</td>
    </tr>
    <tr>
      <td>OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>GPIO_CLOCK</td>
    </tr>
    <tr>
      <td>SOFT_PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>SOFT_TONE_OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_TONE_OUTPUT</td>
    </tr>
  </tbody>
</table>

<p>只有具有相应功能的引脚才能设置为该功能。</p>

<p> </p>

<p><strong>void pullUpDnControl (int pin, int pud) ;</strong><br />
设置上下拉。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
pud是上下拉配置，可设置为：</p>

<table>
  <tbody>
    <tr>
      <td>PUD_OFF</td>
      <td>无上下拉</td>
    </tr>
    <tr>
      <td>PUD_UP</td>
      <td>上拉，3.3v，50kΩ</td>
    </tr>
    <tr>
      <td>PUD_DOWN</td>
      <td>下拉，50kΩ</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p><strong>void digitalWrite (int pin, int value) ;</strong><br />
设置指定引脚的输出。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
value是输出值，可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>HIGH 或 非0</td>
      <td>高电平（3.3v）</td>
    </tr>
    <tr>
      <td>LOW 或 0</td>
      <td>低电平</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>void digitalWriteByte (int value) ;</p>

<p> </p>

<p><strong>int digitalRead (int pin) ;</strong><br />
读取指定引脚。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
返回的是该引脚的电平，返回HIGH或LOW。</p>

<p> </p>

<p><strong>void pwmWrite (int pin, int value) ;</strong><br />
设置pwn输出占空比。<br />
pin是引脚序号，以何种方式编号在前面决定。（最新的树莓派里面好像把pwm功能去掉了）<br />
value是占空比，范围是0~1023。<br />
？？？在哪设置pwm的周期呢？</p>

<p> </p>

<p><strong>analogRead (int pin) ;</strong><br />
读入模拟量（AD）。<br />
<strong>analogWrite (int pin, int value) ;</strong><br />
输出模拟量（DA）。<br />
<em>以上两个功能需要外加芯片</em>，这里略去。</p>

<p> </p>

<p><strong>wiringPi-C控制GPIO的速度</strong><br />
<img src="/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/2.png" alt="2.png" /><br />
高低电平变化响应速度大约是80ns。（raspberry-gpio-python的速度大约是2us，大约是它的25倍）<br />
注意，wiringPi-C也是在上层的程序，输出的波形同样是不稳定的。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPI-设置引脚编号模式]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi.html"/>
    <updated>2017-11-22T19:52:38+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi</id>
    <content type="html"><![CDATA[<p>  </p>

<p>前面说过树莓派在不同的库下对引脚的编号方式是不同的，wiringPi支持设置各种不同的引脚编号方式。</p>

<!-- more -->

<p>安装好wiringPi之后，不仅在系统中添加了头文件和库，同时也安装了命令行工具。<br />
在shell中可以用 <strong>gpio readall</strong> 命令获取到以下信息：<br />
<img src="/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi/1.png" alt="1.png" /></p>

<p>wiringPi提供三种引脚排序方式：wPi、BCM、Phy。<br />
必须在程序开始时指明使用哪种排序方式。</p>

<ol>
  <li>wiringPi排序方式<br />
<strong>int wiringPiSetup (void) ;</strong><br />
调用此函数即可设置为wiringPi排序。</li>
  <li>BCM排序方式<br />
<strong>int wiringPiSetupGpio (void) ;</strong><br />
调用此函数即可。</li>
  <li>物理排序方式（和 raspberry-gpio-python 的排序相同）<br />
<strong>int wiringPiSetupPhys (void) ;</strong><br />
按照引脚顺序排序，没有GPIO的引脚是无法控制的。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
</feed>
