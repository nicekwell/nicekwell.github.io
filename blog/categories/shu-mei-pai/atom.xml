<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 树莓派 | 生命不息 折腾不止]]></title>
  <link href="http://nicekwell.net/blog/categories/shu-mei-pai/atom.xml" rel="self"/>
  <link href="http://nicekwell.net/"/>
  <updated>2018-01-18T11:11:08+08:00</updated>
  <id>http://nicekwell.net/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-wiringPi-C的i2c库使用]]></title>
    <link href="http://nicekwell.net/blog/20171124/shu-mei-pai-wiringpi-wiringpi-cde-i2cku-shi-yong.html"/>
    <updated>2017-11-24T13:36:14+08:00</updated>
    <id>http://nicekwell.net/blog/20171124/shu-mei-pai-wiringpi-wiringpi-cde-i2cku-shi-yong</id>
    <content type="html"><![CDATA[<p>  </p>

<p>在linux上层有一个操作i2c的通用接口——smbus，在这里我们不介绍smbus的使用，但要知道wiringPi的i2c接口就是在linux上层基于smbus封装的。<br />
wiringPi封装的函数中，有byte和word的读写，但是没有封装block的读写。也就是说，没有提供一次写大块数据的方法。</p>

<!-- more -->

<p> </p>

<p><strong>&lt;file&gt; = wiringPiI2CSetup(int &lt;从机地址&gt;);</strong><br />
打开i2c设备。<br />
输入的是7位的从机地址，不需要输入i2c设备节点路径。<br />
返回的是linux标准的设备文件描述符。</p>

<p>实际的处理过程是这样的：<br />
wiringPi自动检测i2c设备文件路径（/dev/i2c-0或/dev/i2c-1）；<br />
然后打开文件，获取到了标准文件描述符；<br />
然后通过ioctl设置从机地址。</p>

<p> </p>

<p><strong>int wiringPiI2CWrite(int fd,int data);</strong><br />
往从机写一个字节。<br />
也就是从机地址后的一个字节，通常是command。<br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;data&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CWriteReg8(int fd, int reg, int data);</strong><br />
往从机指定的reg写入1个字节。<br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;reg&gt; + &lt;data&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CWriteReg16(int fd, int reg, int data);</strong><br />
往从机指定的reg写2个字节，<strong>先传输低8位，后传输高8位。</strong><br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;reg&gt; + &lt;data低8位&gt; + &lt;data高8位&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CRead(int fd);</strong><br />
从从机直接读取一个字节，不写入任何cmd。<br />
<em>&lt;起始&gt; + &lt;从机地址R&gt; + &lt;读1个字节&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CReadReg8(int fd, int reg);</strong><br />
读取从机指定reg的一个字节。<br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;reg&gt; + &lt;起始&gt; + &lt;从机地址R&gt; + &lt;读1个字节&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CReadReg16(int fd, int reg);</strong><br />
读取从机指定reg的两个字节，<strong>先传输低8位，后传输高8位。</strong><br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;reg&gt; + &lt;起始&gt; + &lt;从机地址R&gt; + &lt;读低8位&gt; + &lt;读高8位&gt; + &lt;结束&gt;</em></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-树莓派的i2c配置]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shu-mei-pai-de-i2cpei-zhi.html"/>
    <updated>2017-11-23T20:35:11+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shu-mei-pai-de-i2cpei-zhi</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#i2c" id="markdown-toc-i2c">1、开启树莓派i2c设备</a></li>
  <li><a href="#i2c-1" id="markdown-toc-i2c-1">2、确认i2c模块加载成功</a></li>
  <li><a href="#i2c-detecti2c" id="markdown-toc-i2c-detecti2c">3、i2c detect检测i2c设备</a></li>
  <li><a href="#i2c-2" id="markdown-toc-i2c-2">4、i2c的波特率</a></li>
</ul>
<p>  </p>

<p>介绍如何在树莓派上配置i2c，包括开关、波特率，以及i2cdetect的简单使用。</p>

<!-- more -->

<h3 id="i2c">1、开启树莓派i2c设备</h3>
<p>树莓派的i2c默认是关闭的。网上找了很多打开i2c的方法，基本上都是：<br />
1、修改 /etc/modules，添加i2c模块开机自动启动。<br />
2、修改 /etc/modprobe.d/raspi-blacklist.conf 黑名单中去掉i2c模块。<br />
但是怎么改都不行，可能是树莓派系统升级了，和以前的设置方法不一样了。<br />
正确的方法是：<br />
1、sudo raspi-config<br />
2、Advanced Options –&gt; I2C –&gt; 开启i2c设备 –&gt; 重启。<br />
加载成功的话会生成 <strong>/dev/i2c-x</strong> 文件，x是总线序号。</p>

<h3 id="i2c-1">2、确认i2c模块加载成功</h3>
<p><strong>lsmod</strong><br />
会看到 i2c_dev 和 i2c_bcm2708 两项。</p>

<h3 id="i2c-detecti2c">3、i2c detect检测i2c设备</h3>
<p>linux下有个i2c工具程序可以方便地检测i2c设备。<br />
1、 安装 i2c-tools<br />
<strong>sudo apt-get install i2c-tools</strong><br />
2、列出所有i2c总线<br />
<strong>i2cdetect -l</strong><br />
如果i2c设备成功打开，将会看到<br />
i2c-1   i2c   3f804000.i2c    I2C adapter<br />
3、列出i2c总线上的所有i2c设备<br />
<strong>i2cdetect -y &lt;总线&gt;</strong><br />
列出总线上所有地址上的设备，形如：</p>

<p><code>
.    0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
</code></p>

<p><strong>这个功能会启动i2c检测电路，电路上实际连接了哪些设备这里就会显示哪些设备。电路上不连接设备的话在这里是不会显示的。</strong><br />
<strong>检测到的是7位的i2c地址。</strong></p>

<p>i2ctools的其他使用在linux里的工具使用中有专门介绍。</p>

<h3 id="i2c-2">4、i2c的波特率</h3>
<p>获取当前波特率：<br />
<strong>sudo cat /sys/module/i2c_bcm2708/parameters/baudrate</strong><br />
设置波特率：<br />
<strong>sudo emacs /etc/modprobe.d/custom.conf</strong><br />
添加一行设置：<br />
<strong>options i2c_bcm2708 baudrate=100000</strong><br />
设置后需要重启才能生效。</p>

<p> </p>

<p>实际测量clk引脚的结果：</p>

<table>
  <tbody>
    <tr>
      <td>设置的频率</td>
      <td>示波器测量的脉宽</td>
      <td>周期</td>
      <td>示波器测量的频率</td>
      <td>传输addr+cmd+20字节所需要的时间</td>
      <td> </td>
    </tr>
    <tr>
      <td>32000(32k)</td>
      <td>25us</td>
      <td>50us</td>
      <td>20kHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>100000(100k)</td>
      <td>8us</td>
      <td>16us</td>
      <td>41.67kHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>1000000(1M)</td>
      <td>800ns</td>
      <td>1600ns</td>
      <td>417KHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>2000000(2M)</td>
      <td>400ns</td>
      <td>800ns</td>
      <td>833.4kHz</td>
      <td> </td>
      <td>波形略有失真，可能和外部电路设计也有关系。</td>
    </tr>
    <tr>
      <td>3000000(3M)</td>
      <td>250ns</td>
      <td>500ns</td>
      <td>1.894MHz</td>
      <td> </td>
      <td>波形已经失真严重，设备接收异常。</td>
    </tr>
  </tbody>
</table>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-UART串口]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-uartchuan-kou.html"/>
    <updated>2017-11-23T20:05:37+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-uartchuan-kou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">0、包含头文件</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">1、打开串口</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">2、写入（发送）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">3、读取（接收）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">4、缓冲区操作</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">5、关闭串口</a></li>
</ul>
<p>  </p>

<p>前面介绍了python操作串口的方法，是通过通用的串口库实现的。<br />
用c语言当然也可以通过通用串口接口实现，而wiringPi也提供了自己的一套串口操作函数，可以很方便地操作串口。<br />
事实上，wiringPi就是在上层利用通用串口操作接口，封装了一套自己的库函数。</p>

<!-- more -->

<h3 id="section">概述</h3>

<p>在前面python串口编程处就介绍了，树莓派3B的板载串口被蓝牙占用，但可以方便地使用USB串口模块。</p>

<p>树莓派的板载串口是给系统登录使用的，我们要先把这个功能关掉。<br />
<strong>sudo raspi-config</strong><br />
Advanced Options –&gt; Serial –&gt; 关闭串口 –&gt; 重启</p>

<p>树莓派上有两个串口，一个硬件串口，工作稳定，但是分配给了蓝牙；还有一个“mini-uart”，这个串口的时钟是由内核提供，所以不太稳定 。 在树莓派3B上，蓝牙和硬件串口是不能兼得。<br />
这个链接(http://ukonline2000.com/?p=880)有介绍如何把硬件串口分配到GPIO14、GPIO15上，这里不做介绍了。</p>

<p>总之，在树莓派3B上，想要使用板载硬件串口是比较麻烦的，我们这里使用的是USB转串口模块，也能很方便地使用串口。</p>

<h3 id="section-1">0、包含头文件</h3>

<p><strong>#include &lt;wiringSerial.h&gt;</strong></p>

<h3 id="section-2">1、打开串口</h3>

<p><strong>&lt;fd&gt; = serialOpen(char* device, int buad);</strong><br />
【功能】<br />
打开串口文件，并设置波特率，返回文件编号。<br />
【输入】</p>

<table>
  <tbody>
    <tr>
      <td>*device</td>
      <td>设备路径的字符串。比如 “/dev/ttyUSB0”</td>
    </tr>
    <tr>
      <td>buad</td>
      <td>波特率，是一个数值。可以设置为：2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</td>
    </tr>
  </tbody>
</table>

<p>【输出】一个文件编号，代表这个串口设备文件，后面对这个串口的操作都会用到。<br />
【说明】<br />
1、wiringPi提供的设置（以及后面的读写功能）是简化的文件操作，可以满足大部分需求。<br />
2、这里的<file编号>是标准的linux文件描述符，可以使用linux标准的文件操作函数write()、read()等来操作。</file编号></p>

<p>后面也会有说明，wiringPi提供的读写功能是简化的，不提供二进制数值读写，但是可以使用linux标准的读写函数来操作。</p>

<h3 id="section-3">2、写入（发送）</h3>

<p><strong>void serialPutchar(int fd, unsigned char c) ;</strong><br />
【功能】发送一个字节数据。<br />
【输入】<br />
fd是打开串口时的文件描述符。<br />
输入的就是一个字节数据，可以用字符表示，也可以用十六进制数表示。</p>

<p><strong>void serialPuts(int fd, char *s) ;</strong><br />
【功能】发送字符串。<br />
【输入】<br />
fd是打开串口时的文件描述符。<br />
*s 是一个字符串，会发送该字符串，直到’\0’结束。<strong>‘\0’不会发送出去。</strong></p>

<p><strong>void serialPrintf(int fd, char *message, …) ;</strong><br />
【功能】功能类似于printf，可以同时发送多个字符串。</p>

<p> </p>

<p>注意：<strong>以上两个发送函数只是把数据推送到发送缓冲区里，不会等待串口发送完成。</strong>后续程序如果要用到用到串口返回数据应当要考虑到串口传输时间。<br />
<strong>并且最好等之前的数据全部发送完成后再发送新数据，否则可能会出问题，这也要考虑到串口发送数据的时间，可能需要等待。</strong><br />
关键是上层还没有找到判断串口发送完成的方法。</p>

<h3 id="section-4">3、读取（接收）</h3>

<p><strong>int serialDataAvail(int fd) ;</strong><br />
【功能】获取接收缓冲区里的字节数。<br />
【输入】创建串口设备文件时的文件描述符。<br />
【输出】接收缓冲区里所存放的数据字节数。</p>

<p><strong>int serialGetchar(int fd) ;</strong><br />
【功能】从接收缓冲区里读取一个字节数据。<br />
【输入】创建串口设备文件时的文件描述符。<br />
【输出】读取到的一个字节内容。虽然是一个字节内容，但仍然定义为了int型。<br />
【说明】<br />
<strong>如果缓冲区里没有数据，则会等待10s，相当于python里把timeout设置为10s。<br />
10s过后如果还没有数据的话，则会返回 -1，十六进制显示为 0xffffffff。</strong>
这里的10s是wiringPi默认的，查看源代码可以看到：<br />
<img src="/images/raspberrypi/2017-11-23-shu-mei-pai-wiringpi-uartchuan-kou/1.png" alt="1.png" /></p>

<h3 id="section-5">4、缓冲区操作</h3>
<p><strong>void serialFlush(int fd) ;</strong><br />
清空缓冲区，放弃所有数据。</p>

<h3 id="section-6">5、关闭串口</h3>
<p><strong>void serialClose(int fd) ;</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-优先级&amp;中断&amp;线程]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng.html"/>
    <updated>2017-11-23T19:48:00+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi库真是包含了各个方面，甚至提供了进程操作接口。<br />
使用wiringPi的接口可以很方便地创建新进程。</p>

<!-- more -->

<p> </p>

<p><strong>int piHiPri (int priority) ;</strong><br />
设置进程优先级。范围是0~99，数字越大优先级越高，默认是0。<br />
返回0代表成功，返回-1代表失败。<br />
注：必须已root身份运行，否则无效。</p>

<p> </p>

<p><strong>int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;</strong><br />
设置某个pin作为中断脚，当触发中断时调用指定函数。<br />
估计实现原理是后台用了一个定时器不断扫描这个引脚。<br />
pin是引脚序号，编号方式在Setup时决定。<br />
edgeType是中断触发方式：</p>

<table>
  <tbody>
    <tr>
      <td>INT_EDGE_FALLING</td>
      <td>下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_RISING</td>
      <td>上升沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_BOTH</td>
      <td>上升沿和下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_SETUP</td>
      <td>未设置</td>
    </tr>
  </tbody>
</table>

<p>中断处理函数传入函数指针即可。</p>

<p> </p>

<p><strong>int piThreadCreate (PI_THREAD func) ;</strong><br />
创建一个线程执行func函数。要求func函数用PI_THREAD声明。<br />
返回0代表创建成功，非0代表失败。<br />
例：</p>

<p><code>c
PI_THREAD (func)    //注意这种声明方式，函数名用括号括起来，不带参数
{
	...
}
void main()
{
	...
	piThreadCreate(func);
	...
}
</code></p>

<p> </p>

<p><strong>piLock (int keyNum) ;</strong><br />
<strong>piUnlock (int keyNum) ;</strong><br />
获取锁和释放锁。wiringPi-C提供了4个锁，keyNum范围是0~3。<br />
默认所有所都是释放状态，当调用piLock()想要获取锁时，如果这个锁没有被释放则会一直等待，直到这个锁被释放才会拿到这个锁并继续运行下去。<br />
这里的锁可以理解为某个资源，使用该资源时调用piLock()标志该资源正在被使用，使用结束后调用piUnlock()表示释放该资源。其他地方想要使用该资源也必须先获取这个锁，如果没有获取到则等待使用者释放资源后再使用。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-时间函数]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu.html"/>
    <updated>2017-11-23T19:27:41+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi不仅提供硬件操作的接口，同时也提供了一些时间管理函数。</p>

<!-- more -->

<p> </p>

<p><strong>void delay (unsigned int howLong)</strong><br />
延时ms，最大传入32位无符号型整数，大约49天。<br />
实际上是睡眠，不占用cpu。<br />
由于linux是多任务的，所以实际延时时间可能会更长。</p>

<p> </p>

<p><strong>void delayMicroseconds (unsigned int howLong)</strong><br />
延时微秒，最大传入32位无符号型整数，大约71分钟。</p>

<p>wiringPi的库文件中有这样一个函数：
```c
	void delayMicrosecondsHard (unsigned int howLong)
	{
	  struct timeval tNow, tLong, tEnd ;</p>

<pre><code>  gettimeofday (&amp;tNow, NULL) ;
  tLong.tv_sec  = howLong / 1000000 ;
  tLong.tv_usec = howLong % 1000000 ;
  timeradd (&amp;tNow, &amp;tLong, &amp;tEnd) ;

  while (timercmp (&amp;tNow, &amp;tEnd, &lt;))
    gettimeofday (&amp;tNow, NULL) ;
} ``` 其实 delayMicroseconds 函数会判断传入时间如果小于100us就使用 delayMicrosecondsHard 占用式延时，否则会调用 nanosleep 函数。   如果我们想要精确延时，是可以使用 delayMicrosecondsHard 函数的，这个函数在.h文件里没有声明，但已经编译完成，只要用 void delayMicrosecondsHard (unsigned int howLong); 把此函数声明一下就可以使用了。
</code></pre>

<p> </p>

<p><strong>unsigned int millis (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是ms。</p>

<p> </p>

<p><strong>unsigned int micros (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是us。<br />
<strong>测试发现这个函数获取时间速度是很快地，此函数执行时间大约1us，也就是说连续执行两次此函数时间相差大约1us。</strong>在用树莓派处理对时间比较敏感的任务时可能会在意这些时间。</p>

<p>树莓派中经常需要精确地周期性执行某个动作，可以用如下方式精确定时，类似于单片机里的定时器：
<code>c
#define INTERVAL 20000 //间隔时间，单位是us
int main(int argc, char *argv[])
{
    long tim;
    /* do something */
    tim = micros();
    while(1)
    {
      if(micros() - tim &gt;= INTERVAL)
      {
            tim += INTERVAL;
            /* do something */
        }
    }
    return 0;
}
</code></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
</feed>
