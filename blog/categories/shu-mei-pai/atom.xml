<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 树莓派 | 生命不息 折腾不止]]></title>
  <link href="http://nicekwell.net/blog/categories/shu-mei-pai/atom.xml" rel="self"/>
  <link href="http://nicekwell.net/"/>
  <updated>2017-11-23T19:56:05+08:00</updated>
  <id>http://nicekwell.net/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-优先级&amp;中断&amp;线程]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng.html"/>
    <updated>2017-11-23T19:48:00+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi库真是包含了各个方面，甚至提供了进程操作接口。<br />
使用wiringPi的接口可以很方便地创建新进程。</p>

<!-- more -->

<p> </p>

<p><strong>int piHiPri (int priority) ;</strong><br />
设置进程优先级。范围是0~99，数字越大优先级越高，默认是0。<br />
返回0代表成功，返回-1代表失败。<br />
注：必须已root身份运行，否则无效。</p>

<p> </p>

<p><strong>int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;</strong><br />
设置某个pin作为中断脚，当触发中断时调用指定函数。<br />
估计实现原理是后台用了一个定时器不断扫描这个引脚。<br />
pin是引脚序号，编号方式在Setup时决定。<br />
edgeType是中断触发方式：</p>

<table>
  <tbody>
    <tr>
      <td>INT_EDGE_FALLING</td>
      <td>下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_RISING</td>
      <td>上升沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_BOTH</td>
      <td>上升沿和下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_SETUP</td>
      <td>未设置</td>
    </tr>
  </tbody>
</table>

<p>中断处理函数传入函数指针即可。</p>

<p> </p>

<p><strong>int piThreadCreate (PI_THREAD func) ;</strong><br />
创建一个线程执行func函数。要求func函数用PI_THREAD声明。<br />
返回0代表创建成功，非0代表失败。<br />
例：</p>

<p><code>c
PI_THREAD (func)    //注意这种声明方式，函数名用括号括起来，不带参数
{
	...
}
void main()
{
	...
	piThreadCreate(func);
	...
}
</code></p>

<p> </p>

<p><strong>piLock (int keyNum) ;</strong><br />
<strong>piUnlock (int keyNum) ;</strong><br />
获取锁和释放锁。wiringPi-C提供了4个锁，keyNum范围是0~3。<br />
默认所有所都是释放状态，当调用piLock()想要获取锁时，如果这个锁没有被释放则会一直等待，直到这个锁被释放才会拿到这个锁并继续运行下去。<br />
这里的锁可以理解为某个资源，使用该资源时调用piLock()标志该资源正在被使用，使用结束后调用piUnlock()表示释放该资源。其他地方想要使用该资源也必须先获取这个锁，如果没有获取到则等待使用者释放资源后再使用。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-时间函数]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu.html"/>
    <updated>2017-11-23T19:27:41+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi不仅提供硬件操作的接口，同时也提供了一些时间管理函数。</p>

<!-- more -->

<p> </p>

<p><strong>void delay (unsigned int howLong)</strong><br />
延时ms，最大传入32位无符号型整数，大约49天。<br />
实际上是睡眠，不占用cpu。<br />
由于linux是多任务的，所以实际延时时间可能会更长。</p>

<p> </p>

<p><strong>void delayMicroseconds (unsigned int howLong)</strong><br />
延时微秒，最大传入32位无符号型整数，大约71分钟。</p>

<p>wiringPi的库文件中有这样一个函数：
```c
	void delayMicrosecondsHard (unsigned int howLong)
	{
	  struct timeval tNow, tLong, tEnd ;</p>

<pre><code>  gettimeofday (&amp;tNow, NULL) ;
  tLong.tv_sec  = howLong / 1000000 ;
  tLong.tv_usec = howLong % 1000000 ;
  timeradd (&amp;tNow, &amp;tLong, &amp;tEnd) ;

  while (timercmp (&amp;tNow, &amp;tEnd, &lt;))
    gettimeofday (&amp;tNow, NULL) ;
} ``` 其实 delayMicroseconds 函数会判断传入时间如果小于100us就使用 delayMicrosecondsHard 占用式延时，否则会调用 nanosleep 函数。   如果我们想要精确延时，是可以使用 delayMicrosecondsHard 函数的，这个函数在.h文件里没有声明，但已经编译完成，只要用 void delayMicrosecondsHard (unsigned int howLong); 把此函数声明一下就可以使用了。
</code></pre>

<p> </p>

<p><strong>unsigned int millis (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是ms。</p>

<p> </p>

<p><strong>unsigned int micros (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是us。<br />
<strong>测试发现这个函数获取时间速度是很快地，此函数执行时间大约1us，也就是说连续执行两次此函数时间相差大约1us。</strong>在用树莓派处理对时间比较敏感的任务时可能会在意这些时间。</p>

<p>树莓派中经常需要精确地周期性执行某个动作，可以用如下方式精确定时，类似于单片机里的定时器：
<code>c
#define INTERVAL 20000 //间隔时间，单位是us
int main(int argc, char *argv[])
{
    long tim;
    /* do something */
    tim = micros();
    while(1)
    {
      if(micros() - tim &gt;= INTERVAL)
      {
            tim += INTERVAL;
            /* do something */
        }
    }
    return 0;
}
</code></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-GPIO]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio.html"/>
    <updated>2017-11-22T20:07:42+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p>GPIO接口在官网有详细的说明：<a href="http://wiringpi.com/reference/core-functions/">http://wiringpi.com/reference/core-functions/</a></p>

<p>wiringPi的GPIO序号如下：<br />
<img src="/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/1.jpg" alt="1.jpg" /></p>

<p> </p>

<p><strong>void pinMode (int pin, int mode) ;</strong><br />
设置GPIO模式。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
mode可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>INPUT</td>
    </tr>
    <tr>
      <td>OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>GPIO_CLOCK</td>
    </tr>
    <tr>
      <td>SOFT_PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>SOFT_TONE_OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_TONE_OUTPUT</td>
    </tr>
  </tbody>
</table>

<p>只有具有相应功能的引脚才能设置为该功能。</p>

<p> </p>

<p><strong>void pullUpDnControl (int pin, int pud) ;</strong><br />
设置上下拉。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
pud是上下拉配置，可设置为：</p>

<table>
  <tbody>
    <tr>
      <td>PUD_OFF</td>
      <td>无上下拉</td>
    </tr>
    <tr>
      <td>PUD_UP</td>
      <td>上拉，3.3v，50kΩ</td>
    </tr>
    <tr>
      <td>PUD_DOWN</td>
      <td>下拉，50kΩ</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p><strong>void digitalWrite (int pin, int value) ;</strong><br />
设置指定引脚的输出。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
value是输出值，可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>HIGH 或 非0</td>
      <td>高电平（3.3v）</td>
    </tr>
    <tr>
      <td>LOW 或 0</td>
      <td>低电平</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>void digitalWriteByte (int value) ;</p>

<p> </p>

<p><strong>int digitalRead (int pin) ;</strong><br />
读取指定引脚。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
返回的是该引脚的电平，返回HIGH或LOW。</p>

<p> </p>

<p><strong>void pwmWrite (int pin, int value) ;</strong><br />
设置pwn输出占空比。<br />
pin是引脚序号，以何种方式编号在前面决定。（最新的树莓派里面好像把pwm功能去掉了）<br />
value是占空比，范围是0~1023。<br />
？？？在哪设置pwm的周期呢？</p>

<p> </p>

<p><strong>analogRead (int pin) ;</strong><br />
读入模拟量（AD）。<br />
<strong>analogWrite (int pin, int value) ;</strong><br />
输出模拟量（DA）。<br />
<em>以上两个功能需要外加芯片</em>，这里略去。</p>

<p> </p>

<p><strong>wiringPi-C控制GPIO的速度</strong><br />
<img src="/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/2.png" alt="2.png" /><br />
高低电平变化响应速度大约是80ns。（raspberry-gpio-python的速度大约是2us，大约是它的25倍）<br />
注意，wiringPi-C也是在上层的程序，输出的波形同样是不稳定的。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPI-设置引脚编号模式]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi.html"/>
    <updated>2017-11-22T19:52:38+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi</id>
    <content type="html"><![CDATA[<p>  </p>

<p>前面说过树莓派在不同的库下对引脚的编号方式是不同的，wiringPi支持设置各种不同的引脚编号方式。</p>

<!-- more -->

<p>安装好wiringPi之后，不仅在系统中添加了头文件和库，同时也安装了命令行工具。<br />
在shell中可以用 <strong>gpio readall</strong> 命令获取到以下信息：<br />
<img src="/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi/1.png" alt="1.png" /></p>

<p>wiringPi提供三种引脚排序方式：wPi、BCM、Phy。<br />
必须在程序开始时指明使用哪种排序方式。</p>

<ol>
  <li>wiringPi排序方式<br />
<strong>int wiringPiSetup (void) ;</strong><br />
调用此函数即可设置为wiringPi排序。</li>
  <li>BCM排序方式<br />
<strong>int wiringPiSetupGpio (void) ;</strong><br />
调用此函数即可。</li>
  <li>物理排序方式（和 raspberry-gpio-python 的排序相同）<br />
<strong>int wiringPiSetupPhys (void) ;</strong><br />
按照引脚顺序排序，没有GPIO的引脚是无法控制的。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-编译&amp;头文件&amp;lib]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-bian-yi-and-tou-wen-jian-and-lib.html"/>
    <updated>2017-11-22T19:40:06+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-bian-yi-and-tou-wen-jian-and-lib</id>
    <content type="html"><![CDATA[<p>  </p>

<p>安装好之后想要使用wiringPi的接口，就必须要包含wiringPi的头文件、链接wiringPi库，本文介绍如何正确编译。</p>

<!-- more -->

<p>安装好之后，会生成以下头文件：</p>

<table>
  <tbody>
    <tr>
      <td>/usr/local/include/wiringPi.h</td>
      <td>提供基础的服务，包括GPIO。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiI2C.h</td>
      <td>提供I2C相关支持。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiSPI.h</td>
      <td>提供SPI相关支持。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiShift.h</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>生成以下库：</p>

<table>
  <tbody>
    <tr>
      <td>/usr/local/lib/libwiringPiDev.so</td>
    </tr>
    <tr>
      <td>等</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>在编写C程序时：</p>

<ol>
  <li>要 include 头文件，直接用&lt;&gt;即可，不需要指明路径。<br />
如：#include <wiringPi.h>  
编译器会自动从/usr/local/include/目录下寻找头文件。</wiringPi.h></li>
  <li>编译时要连接wiringPi的库。<br />
如：gcc gpio.c -o gpio -<strong>lwiringPi</strong><br />
编译器会自动从/usr/local/lib/目录下寻找库。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
</feed>
