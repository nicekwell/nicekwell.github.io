<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 单片机编程 | 平衡的世界]]></title>
  <link href="http://nicekwell.github.io/blog/categories/dan-pian-ji-bian-cheng/atom.xml" rel="self"/>
  <link href="http://nicekwell.github.io/"/>
  <updated>2016-09-19T21:51:52+08:00</updated>
  <id>http://nicekwell.github.io/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[第4章 占用式与非占用式程序结构]]></title>
    <link href="http://nicekwell.github.io/blog/20160919/di-4zhang-zhan-yong-shi-yu-fei-zhan-yong-shi-cheng-xu-jie-gou.html"/>
    <updated>2016-09-19T21:39:56+08:00</updated>
    <id>http://nicekwell.github.io/blog/20160919/di-4zhang-zhan-yong-shi-yu-fei-zhan-yong-shi-cheng-xu-jie-gou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 什么是占用式程序</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 占用式程序的缺点</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3. 对占用式程序的改造</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4. 改造的本质</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">5. 非占用式程序结构的优势</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">6. 非占用式程序的一般结构</a></li>
</ul>

<h1 id="section">1. 什么是占用式程序</h1>
<p>一个进程在一个时刻只能处理一个任务。</p>

<p>每个任务是为了完成一个功能，如果这个功能的实现过程是一直占用进程处理资源的话，就称这个任务函数是占用式程序结构。</p>

<p>最常见的占用式程序结构就是延时函数了，比如最常用的5ms延时函数</p>

<!-- more -->

<p><code>
void delay5(unsigned char n)
{
    unsigned int i;
    for(;n&gt;0;n--)
        for(i=4700;i&gt;0;i--);	//12MHz，1T
}
</code></p>

<p>在完成5ms功能过程中是一直占用调用它的进程处理资源的，在此期间不能进行其他任务。<br />
还有一个很常见的占用式程序——数码管扫描，不过在这里我不举数码管扫描的例子，而举更为复杂一点的8*8彩色点阵屏的扫描程序：</p>

<p><code>
void refresh7()
{
    unsigned char r;
    for(r=0;r&lt;8;r++)
    {
        //扫描红色
        DPw = ~(0x01&lt;&lt;r);    //导通指定的行
        DPr = ~vm7r[r];    //输出r行8个灯中红色led
        DELAY7 (light7);    //亮灯时间长度，时间越长亮度越高
        DPw=0xff;
        DPr=0xff;
        DPg=0xff;
        DPb=0xff;
        DELAY7 (32-light7);//灭灯时间长度
        //为了简洁，这里把绿色和蓝色的扫描程序省略，它们的结构和红色扫描是一样的 
    }
}
</code></p>

<p>这个函数是7色模式下的屏幕扫描程序，调用一次此函数会把整个屏幕扫描一遍。<br />
r代表行数，r循环8次代表屏幕的8个行；在每次循环里，先导通对应的行和需点亮的灯，然后延时light7个单位，再关闭所有显示，再延时32-light7个单位。</p>

<h1 id="section-1">2. 占用式程序的缺点</h1>

<p>占用式程序最大的缺点就是执行时间太长，耽误对其他任务的响应。另外就是资源浪费，很多时间浪费在执行中的延时上。<br />
当然，可以在这些占用式程序中嵌入其他代码以及时处理其他任务，但是这样会造成程序结构混乱，嵌入的其他代码还会影响本程序的执行。如果嵌入的代码功能简单还好，如果功能复杂，尤其是当嵌入的代码也是占用式的，就会严重影响程序执行速度。</p>

<h1 id="section-2">3. 对占用式程序的改造</h1>

<p>在此还以上面的扫描程序为例，对其进行改造。<br />
首先，每次调用就扫描8行，耗时太长，现将其改成每次扫描一行：</p>

<p>```
void refresh7()
{
    static unsigned char r=0;
    //扫描红色
    DPw = ~(0x01«r);	//修改完了再导通指定行
    DPr = ~vm7r[r];//送入R灯IO接口显示
    DELAY7 (light7);//显示时间长度
    DPw=0xff;
    DPr=0xff;
    DPg=0xff;
    DPb=0xff;
    DELAY7 (32-light7);//灭灯时间长度
    //为了简洁，这里把绿色和蓝色的扫描程序省略，它们的结构和红色扫描是一样的</p>

<pre><code>r++;
if(r==8)
    r=0;    } } ```
</code></pre>

<p>用一个静态变量r来记忆行数，这样每次调用此函数只需扫描一行，执行速度是原来的8倍，可以比较快地响应其他任务了。<br />
但是这样还不够，每次扫描都会扫描三种颜色，时间还是有点长，下面再次改造，改为每次只扫描一种颜色：</p>

<p>```
void refresh7()
{
	static unsigned char r=0;
	static unsigned char flagrgb=0;	//当前需要点亮的颜色，0-R,1-G,2-B
	flagrgb++;
	if(flagrgb==3)	//说明三种颜色都扫描完了
	{
		flagrgb=0;	//从红色开始扫描
		r++;		//开始扫描下一行
		if(r==8)	//如果发现行都扫描结束则从第行开始扫描
			r=0;
	}</p>

<pre><code>switch(flagrgb)
{
case 0:	//扫描红色
	DPw = ~(0x01&lt;&lt;r);	//修改完了再导通指定行
	DPr = ~vm7r[r];//送入R灯IO接口显示
	DELAY7 (light7);//显示时间长度
	DPw=0xff;
	DPr=0xff;
	DPg=0xff;
	DPb=0xff;
	DELAY7 (32-light7);//灭灯时间长度
	break;
case 1:	//扫描绿色	
	/*省略代码*/
	break;
case 2:	//扫描蓝色
	/*省略代码*/
	break;
} } ```
</code></pre>

<p>改造完成之后，执行时间再次缩短，变成了刚才的1/3。<br />
这下还没完，我们发现每次扫描中都有延时，延时过程中什么也不做，这是极大的浪费，我们需要再此改造，把延时去掉：</p>

<p>```
void refresh7()
{
	static unsigned char r=0;
	static unsigned char flagrgb=0;	//当前需要点亮的颜色，0-R,1-G,2-B
	static unsigned char num=0;
	num++;
	if(num==32)
	{
		num=0;
		flagrgb++;
		if(flagrgb==3)	//说明三种颜色都扫描完了
		{
			flagrgb=0;	//从红色开始扫描
			r++;		//开始扫描下一行
			if(r==8)	//如果发现行都扫描结束则从第行开始扫描
				r=0;
		}
	}</p>

<pre><code>if(num&lt;light7)	//说明需要点亮
{
	switch(flagrgb)
	{
	case 0:	//扫描红色
		DPw = ~(0x01&lt;&lt;r);
		DPr = ~vm7r[r];//送入R灯IO接口显示
		break;
	case 1:	//扫描绿色	
		DPw = ~(0x01&lt;&lt;r);
		DPg = ~vm7g[r];
		break;
	case 2:	//扫描蓝色
		DPw = ~(0x01&lt;&lt;r);
		DPb = ~vm7b[r];
		break;
	}
}
else	//说明不需要点亮
{
	DPw=0xff;
	DPr=0xff;
	DPg=0xff;
	DPb=0xff;
} } ```
</code></pre>

<p>现在，这个函数中没有任何延时和循环，执行所消耗的时间是非常少的，可以很快地响应响应其他任务。</p>

<h1 id="section-3">4. 改造的本质</h1>

<p>上面我们对这个项目的扫描程序进行了“三大改造”，分别是：1、各个行扫描的分离；2、各个颜色扫描的分离；3、延时函数的消除。<br />
这些改造的本质都是对原程序的分割，把一大坨程序分成多个步骤分别执行，以减小耗时，提高对外部的响应速度。<br />
还记得在第一章说的主函数顺序调用吗？最后说过这样一句话：“在最坏情况下的任务级响应时间取决于整个循环的执行时间”，而通过这样的改造之后，其实就是在缩短这个循环的时间。<br />
<strong>但就整个进程的执行来看，有效代码的比例是降低的</strong>，包括上面“三大改造”的第三点 延时函数的消除，看上去是消除了延时函数，提高了执行效率，但从“扫描一次整屏”这个任务来看，其执行的代码量反而是增加的。（但并不是所有的改造都一定会使效率降低，有些改造确实可以达到“消除延时函数”的目的）<br />
那为什么还要对其进行改造呢，见下节分析。</p>

<h1 id="section-4">5. 非占用式程序结构的优势</h1>

<p>1、非占用式程序相比于占用式程序，增加了一定的代码，虽然会使整体效率降低，但是提高了各个任务之间的切换速度，可以对各个任务都能很快地响应。这点类似于操作系统，虽然降低了效率，但是各个任务间的快速切换可以达到各个任务“并行处理”的效果，光是这点的好处就已经很大了。</p>

<p>2、非占用式程序结构可以放进定时器<br />
第3章已经发现用定时器分配任务的好处，有些简短的代码可以直接放进定时器里。<br />
在改造之前的扫描程序是不适合放在定时器中断处理程序里执行的，因为太长，可能还没执行完就来了下一个中断。就算勉强执行完了，留给主进程处理其他事情的时间也不多了。<br />
而改为非占用式之后，可以在中断处理程序里直接调用扫描程序，它会很快地执行完，然后有充足的时间留给其他任务。</p>

<p>3、非占用式程序并不是一定会降低效率。<br />
就拿“三大改造”的第三点说明，它虽然形式上消除了延时函数，但是每次调用此函数时对num变量的处理，以及有其产生的相关判断语句，总的代码量比原来的要多。<br />
但是，这真的就仅仅是这样了吗？改造之前的函数，执行完退出之后所有的led全是熄灭的，只有在此函数执行过程中（延时阶段）才会点亮（传统数码管扫描亦是如此）。<br />
而改造之后的函数，它的功能就是指定一下每个灯的亮灭，然后立马退出，在执行其他任务的过程中该点亮的灯是在点亮的状态。这样就提高了整体的亮度，在执行其他任务的过程中，从某种意义上说也是在执行当前任务。</p>

<p>这可能还不能太清楚地说明问题，下面再举一例，传统的按键扫描一般是这样：
<code>
if(key==0)	//key是某个引脚
{
    delay5(1);
    if(key==0)	//确认按键已按下
    {
        /*do something*/
    }
}
</code></p>

<p>这段代码也是很浪费时间的，中间有个5ms延时白白浪费。<br />
通过对它改造之后，结合定时器，可以几乎完全地把这5ms时间省出来，把如下代码放进定时器中断处理程序：</p>

<p><code>
static unsigned char keylast;	//保存上次的按键值
if(key==0 &amp;&amp; keylast==1)	//检测到一个下降沿
{
    /*do something*/
}
keylast=key;
</code></p>

<p>这段代码每5ms执行一次，而执行的时间是非常短的，剩下有大量的时间可留给其他任务。<br />
<strong>结合定时器进行改造，是真的可以把占用式函数的延时时间节省出来的。</strong></p>

<h1 id="section-5">6. 非占用式程序的一般结构</h1>
<p>非占用式程序将占用式程序分割执行，需要用到静态变量对当前步骤进行记忆，其一般结构如下：</p>

<p><img src="/images/dan-pian-ji-bian-cheng/feizhanyongshichengxu.jpg" alt="非占用式程序的一般结构" title="非占用式程序的一般结构" /></p>

<p>逻辑变量计算就是根据任务功能构建出一个合理的逻辑结构。<br />
对逻辑变量的响应就是对构建好的逻辑结构的结果的响应和执行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第3章 定时器分配任务]]></title>
    <link href="http://nicekwell.github.io/blog/20160919/di-3zhang-ding-shi-qi-fen-pei-ren-wu.html"/>
    <updated>2016-09-19T21:08:13+08:00</updated>
    <id>http://nicekwell.github.io/blog/20160919/di-3zhang-ding-shi-qi-fen-pei-ren-wu</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 用界面函数构成的基础框架</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 结合定时器编程分析</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3. 任务分割</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4. 定时器分配任务程序结构总结</a></li>
</ul>

<p>  在前两章的内容里都没有考虑中断，本章将引入定时器。引入定时器的原因一些功能需要计时，最常见的就是电子钟了。</p>

<!-- more -->

<p><img src="/images/dan-pian-ji-bian-cheng/dianzizhong.jpeg" alt="电子钟" /></p>

<p>  这是博主2012年的作品，本章将以这个电子钟为背景介绍用定时器分配任务的程序结构，源代码也会在<a href="http://download.csdn.net/detail/nicekwell/6668033" title="从单片机编程到操作系统产生》的附件">附件</a>中给出。</p>

<h1 id="section">1. 用界面函数构成的基础框架</h1>

<p>  这个电子钟的大体硬件租成有：按键、1602显示屏、18b20温度传感器、电源管理模块（两个AD转换和一路PWM输出），由于没用时钟芯片，采用的是8位自动填装定时器每隔200us一次中断来计时的（很准哦）。<br />
  任务处理方面，除计时和日期计算以外，要处理的任务还有：1602显示、按键扫描、温度采集和电源管理（控制电池充放电）。<br />
  需要显示界面有时间显示界面、时间设置界面、电源管理界面和logo界面。每个界面完成不同的功能，时间显示界面就是上图所示的样子，时间设置界面用来完成时间的设置，电源管理界面用来查看当前电池状态以及设置一些充放电参数，logo界面显示3秒后自动跳转到时间显示界面。<br />
  这些界面是如何完成的呢？没错！它就是在主进程里用界面函数完成的。每个界面函数先初始化本界面显示，然后在实现本界面具体功能：</p>

<p>```
void Page1()
{
	/<em>显示初始化</em>/
	/<em>其他初始化</em>/</p>

<pre><code>while(1)
{
	/*本界面任务*/

	if(FlagPage!=1)
		return;
} } ```
</code></pre>

<p>  具体而言，例举logo界面的代码如下（因为logo界面代码最短）：</p>

<p>```
void logopage()	//logo界面，定时器还在工作，只是停留在logo界面s中后返回
{
	/<em>下面是显示初始化</em>/
	unsigned char i;
	code char logo0[]=”hello world!    “;
	code char logo1[]=”    hello nicek!”;
	wcom(0x80);
	for(i=0;logo0[i]!=’\0’;i++)
		wdat(logo0[i]);
	wcom(0x80+0x40);
	for(i=0;logo1[i]!=’\0’;i++)
		wdat(logo1[i]);</p>

<pre><code>timenum=15000;	//准备延时3s，这个变量会在定时器里每200us减1
while(timenum)	//等待延时结束，等待过程中仍然对一些按键进行相应
{
	switch(keynum)
	{
	case 5:	//按下返回键
		flagpage=0;	//返回后跳转到界面0
		return;	//返回
	case 6:	//按下灯光键
		led=0;	//点亮背光灯
		timenumlight=5;	//点亮5s，时间到了之后会在定时器中自动关闭灯光
		keynum=7;	//按键响应结束，标志没有按键按下
		break;
	}
}
flagpage=0;	//返回后跳转到界面0 } ```
</code></pre>

<p>  有了这些界面函数，也就构成了整个系统的基本框架，但是到目前为止还是没有用到定时器。下面就以“时间显示”界面为例，分析在这个界面中如何结合定时器完成相应功能。</p>

<h1 id="section-1">2. 结合定时器编程分析</h1>

<p>  先来讨论一下在时间显示界面里需要做的这么几个任务：<br />
  1602需要500ms刷新一次。小时和分钟之间有一个冒号“:”需要500ms闪动一次，因为不显示秒，所以当分钟发生变化时整屏也要刷新一次；<br />
  按键扫描5ms扫描一次。如果放在时间界面的主循环里进行按键扫描的话就不用考虑这么多，但是那样做有很多缺点，我这里是把按键扫描当做一个固定的进程，放在定时器中断处理函数里，其他所有界面都能用利用这个扫描结果；<br />
  电源管理500ms检测一次；<br />
  温度采集500ms一次，但比较复杂，涉及到所谓“任务分割”问题，由于比较复杂，会后面单独讨论。</p>

<p>  很自然地想到利用定时器计时来进行，那么定时器会以什么样的工作方式来调配整个系统呢？</p>

<p>  首先，定时器200us一次中断，需要有一个变量累加，当累加到5ms时，进行一次按键扫描；<br />
  然后继续累加，每累加到一个5ms都要进行一次按键扫描……当累加到500ms时进行一次按键扫描、1602刷新显示、电源管理，（温度采集暂且忽略）。</p>

<p>  那么，我们可以直接把这些代码写入中断处理程序吗？比如按键扫描我可以把这段代码写入中断处理程序吗：</p>

<p><code>
for(i=0;i&lt;=6;i++)	//总共7个独立按键
{
	if(P1&amp;pow2[i]==0)	//pow2[i]就是2的i次方
	{
		delay5(1);	//延时5ms，以确认是否真的按下
		if(P1&amp;pow2[i]==0)
		{
			keynum=i;
			break;
		}
	}
}
</code></p>

<p>  这是显然是不行的，执行完这段代码中的延时函数就有5ms了，而定时器是200us一次中断，一个中断周期里根本执行不完。<br />
  如果把这段代码放到时间界面主循环里是可以的，但是这样的话在其他界面就不能使用（除非也加入相同的代码），正如我上面所说：那样有很多缺点，我这里是把按键扫描当做一个固定的进程，其他所有任务都能用利用这个扫描结果。</p>

<p>  所以这里要提出一个定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间。</strong></p>

<p>  所以我们要想想办法，把按键扫描程序改成了如下，以下代码由中断处理函数调用，每5ms执行一次：</p>

<p><code>
static unsigned char reslast;	//保存上次扫描结果，0-没按下，1-按下
unsigned char res;
unsigned char i;
numforkey=0;
res=P1;
for(i=0;i&lt;=6;i++)
{
	if(((res&amp;pow2[i])==0)&amp;&amp;((reslast&amp;pow2[i])!=0))	//这次按下，上次断开
		break;
}
//从这里出来，如果i==7则表示没有按键按下，i&lt;=6的任意一个值表示那个键被按下了
keynum=i;
reslast=res;
</code></p>

<p>  这段代码里面没有延时，执行一次是很快的，而且也可以很好地完成按键扫描，比上面的那种延时扫描更有优势（不占用资源，而且稍加改造可以识别同时按下多个按键）。</p>

<p>  所以，把原则一加上一句，定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间，要想办法把任务改成不占用定时器时间的结构，给主进程让出更多的时间。</strong>关于把“任务改成不占用定时器时间”这个问题会在后面第4章“占用式与非占用式程序结构分析”里详细讨论。</p>

<hr />

<p>  按键扫描在中断处理程序里已经安置妥当了，但请注意当500ms来临时，需要完成的任务有 按键扫描、1602刷新显示、电源管理，（温度采集暂且忽略），定时器中断周期只有200us，现在一下子来了这么多任务，一个中断周期内可以处理完吗？</p>

<p>  为了避免这种风险，我们把定时器中断里的一些任务转移到主进程中（还有另一种方法将在后面“定时器执行任务”的章节中介绍），这就是定时器分配任务的程序结构原则二：<strong>当节拍时间到来时，要处理的任务真的很多，可以通过标志变量通知主进程执行。</strong> <em>但通知让主进程做的事对实时性要求不能太高。</em></p>

<p>  实际上我在电子钟里面把1602刷新就没有放在定时器中断里，而是放到了主进程。在程序里设置了一个flag500ms标志变量，定时器中断处理函数标记变量为1表示到了500ms，时间界面的主循环检测这个变量，当发现这个变量为1时就执行1602刷新。而按键扫描和电源管理由于在任何界面都会用到，并且代码执行速度快，所以把它们放在定时器中断里进行，1602刷新对实时性要求不高，所以可以用定时器通知主进程执行。</p>

<hr />

<p>  下面要说的就是温度采集了，上面为什么没讨论它，就是因为它比较复杂。它既不能满足原则一（在一个定时器中断时间内完成）也不能满足原则二（对实时性要求不高）。</p>

<p>  温度传感器用的是18b20，由单总线协议决定了对它进行一次读写大约需要18ms，而且对实时性要求也很高。</p>

<p>  这里隆重推出一个自己起名的概念——“任务分割”。顺便引出定时器分配任务的程序结构原则三：<strong>当既不满足原则一又不满足原则二，即既不能在一个定时器中断时间里完成又对实时性要求很高的任务，对它进行任务分割。</strong></p>

<p>  下一节将详细介绍任务分割的概念，以及如何对任务进行“分割”。</p>

<h1 id="section-2">3. 任务分割</h1>

<p>  所谓任务分割就是把不能在一个定时器中断时间里完成的任务分割成多个可以在一个定时器中断时间里完成的任务。在这里，把分割完成之后的任务函数仍然放在主进程里。<br />
  要完成任务分割，首先需要让定时器的计时功能可以被外部使用，设一个全局变量TimeNum，然后在定时器中断处理程序里让TimeNum自减：</p>

<p>```
unsigned char TimeNum=0;
void t0_int() interrupt 1
{
	/<em>Do Something</em>/</p>

<pre><code>if(TimeNum!=0)
	TimeNum--; } ```
</code></pre>

<p>  这样，外部就可以通过TimeNum变量使用定时器的计时资源了。在主进程里只要这么做就行：</p>

<p><code>
/*Do Something*/
TimeNum=100;	//准备等待个定时器中断周期
while(TimeNum)	//等待
{
	/*Do Something*/
}
/*继续 Do Something*/
</code></p>

<p>  可以利用定时器延时之后就可以对主进程里的长任务进行分割了，分割方法就是把原来顺序执行的任务函数，找到合适的节点，在节点处进行合适时间的延时。<br />
  这个步骤做起来是比较麻烦的，因为要进行任务分割的任务一般对时间精确性要求是比较高的（否则直接放到主进程就可以了），需要充分了解运行过程。<strong>既要保证每个节点之间的运行时间小于一个定时器中断周期，又要保证任务时序的正确性。</strong></p>

<p>  需要强调一下，任务分割这个方法是个下策，实在没办法的情况下才进行这种处理，我也只在这个电子钟工程的温度测量用过。<br />
  这种情况在操作系统中也是不好处理的，当某个不能被中断的函数的运行时间确实长于时钟节拍周期的话，也只有先关闭中断，等该函数运行结束后再打开中断。操作系统中把这种函数叫做“临界段”代码。而在电子钟这个例子中，由于要进行精确的计时，是不可以关闭中断的，只有进行任务分割（当然也有其他的处理方式，加个协处理器什么的）。</p>

<p>  下面截取18b20的一段代码，举例说明一下修改的原理。<br />
  修改前代码：</p>

<p><code>
bit ds18b20_init()
{
	bit dat=0;
	dq=1;
	delayusx2(5);
	dq=0;
	delayusx2(200);
	delayusx2(200);
	dq=1;
	delayusx2(50);
	dat=dq;
	delayusx2(25);
	return dat;
}
</code></p>

<p>  修改后代码：</p>

<p><code>
bit ds18b20_init()
{
	bit dat=0;
	dq=1;
	delayusx2(5);    //较短的延时不需要修改，可以在一个中断周期内完成
	dq=0;
	timenum=4;while(timenum);  //这里原来的800ms延时换成了结合定时器的等待
	dq=1;
	delayusx2(50);    //延时时间短，不需要分割
	dat=dq;
	delayusx2(25);    //上次分割到这里大约100us，本次延时时间50us，仍然不需要分割
	//到这里实际上init部分的协议已经完成，下面仍然加了一个分割是为了和定时器同步，在这里等待一次定时器中断，保证等待之后有充足的时间执行后续代码
	timenum=1;while(timenum);
	return dat;
}
</code></p>

<h1 id="section-3">4. 定时器分配任务程序结构总结</h1>

<p>  1、整个系统有一个主进程：main函数的主循环及其调用的所用任务函数，以及所有任务函数调用的子任务函数。<br />
  这个主进程的特点是所有函数都在一个函数调用链里，运行时精力只能放在一处；优先级低，任何中断所调用的任务都会使其停止工作。</p>

<p>  2、定时器也可开辟一道进程，所有由定时器直接调用的任务都属于这个进程。<br />
  定时器进程可以通过一些标志变量通知主进程进行某种动作，最常用的控制方法是用定时器产生节拍信号，通知主进程进行相应动作;<br />
  同时，定时器也可以直接调用一些函数，在定时器中断处理程序里完成任务。所有由定时器直接调用的程序都属于定时器进程，优先级高于主进程；<br />
  用定时器分配任务有一下三点原则：<br />
  定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间，要想办法把任务改成不占用定时器时间的结构，给主进程让出更多的时间。</strong><br />
  定时器分配任务的程序结构原则二：<strong>当节拍时间到来时，要处理的任务真的很多，可以通过标志变量通知主进程执行。</strong> <em>但通知让主进程做的事对实时性要求不能太高。</em><br />
  定时器分配任务的程序结构原则三：<strong>当既不满足原则一又不满足原则二，即既不能在一个定时器中断时间里完成又对实时性要求很高的任务，对它进行任务分割。</strong></p>

<p>  3、整个系统来看有两个并行的进程——主进程和定时器进程。主进程一次只能执行一个任务，而定时器进程由于任务一般比较小（如按键扫描、计时、数码管扫描等），所以认为定时器进程的任务也一并完成了。<br />
  看上去就像是多个进程在同时运行，这些进程之间可以通过公共变量进行通信，比如节拍时间的标识变量、计时产生的时间、按键扫描结果变量keynum等，所有其他进程可以有选择地对这些标识变量进行响应。类似于进程间通信。</p>

<hr />

<p>  用定时器命令主函数执行任务的原因有两点：1、利用定时器的时钟节拍使主函数也可以节拍性地执行任务。2、利用主函数构建的逻辑结构。<br />
  对于第1点，该任务的实时性确实会受影响，因为毕竟主函数是用查询方式查询标识变量的。<br />
  但是第2点带来的好处也是非常大的。还拿电子钟举例来说吧，电子钟里面的各个界面之间的逻辑是通过主函数构建出来的，定时器在任何界面都会中断，并且在定时器中执行的任务会通过标识变量向主函数发送信息（比如当前时间、按键扫描结果(我的按键扫描是放在定时器里执行的)等），虽然在各个界面向主函数发送的信息是一样的，但是主函数中的各个界面对这些信息的反应却是不同的（比如各个界面对同一按键的反应是不同的，对定时器提供的时间所做的的反应也是不同的）。
  这些都依赖于主函数所构建出的逻辑结构。</p>

<hr />

<p>  关于这种结构的介绍暂且到此吧，下面将引出一个新的问题。<br />
  注意在3.2节的分析中，有些任务是直接放在定时器里执行的，这些任务都有一些共同的特点——执行时间短。<br />
  执行时间短带来了什么？在1.2节有这么一句话：“任务执行的并行与否是相对而言的。”，在本节的总结中还有这句话：“定时器进程由于任务一般比较小（如按键扫描、计时、数码管扫描等），所以认为定时器进程的任务也一并完成了。”<br />
  定时器的中断处理函数的执行肯定不会被主进程阻挡，这里面的任务全都可以看成是并行的多个进程，它们各自完成不同的功能，把自己的运行结果作为资源供其他进程使用。<br />
  在第5章中将详细分析这种结构，在那一章，我们将会明确我们到底在追求什么，我们要追求的结构到底是什么样的？</p>

<p>  不过在此之前，先要补充一点理论知识，这就是下一章的内容。<br />
  下一章将会分析和明确那些“完成某个任务的函数”到底应该做些什么，哪些东西是有用的。并对这些函数进行改造，分析改造成不同形式的函数有什么样的特点。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第2章 “界面函数”结构]]></title>
    <link href="http://nicekwell.github.io/blog/20160919/di-2zhang-jie-mian-han-shu-jie-gou.html"/>
    <updated>2016-09-19T20:48:39+08:00</updated>
    <id>http://nicekwell.github.io/blog/20160919/di-2zhang-jie-mian-han-shu-jie-gou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 界面函数一般结构</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 更高的角度分析这种结构</a></li>
</ul>

<p>  这一章将介绍的是主循环调用任务函数的一种非常常用的结构。到目前为止，在主进程的构建方面，除了顺序调用我只用到过这一种构建方式，并且用得非常多。在2011年的电子设计大赛上，笔者就用了这种程序结构获得了安徽省第一的成绩，可见这种结构的威力。之所以叫它“界面函数”结构，是因为它各个函数就像一个个界面一样，在每个界面（函数）中完成某些特定的功能，我没找到这种结构的通用叫法。</p>

<!-- more -->

<p>  在第1章中介绍到由主循环顺序调用其他函数的结构，这种顺序执行的方式是最简单的情况了。当情况复杂时，各个函数之间存在着某种逻辑关系，一个函数执行完毕后可能要根据具体情况决定下一个要执行的是哪个函数，同时也可能由于外部原因需要立马切换到另一个函数里。</p>

<p>  为了让大家更好地理解，举这样一个例子：</p>

<p><em>  一个电子钟，上下左右4个方向键，一个 设置/确定 键，一个返回键，一个背光灯键。<br />
  在正常模式下，显示时间、日期等信息，此时忽略上下左右方向键和返回键，当按下设置键时进入设置模式；<br />
  在设置模式下，通过上下左右方向键来设置时间、日期，按下 设置/确定 键保存设置的信息并返回正常模式，按下返回键取消本次设置并返回正常模式；<br />
  在以上两个模式中的任意模式按下背光灯键就亮灯6秒。</em></p>

<p>  例子中有两个基本模式，每个模式中对外部资源（如按键）的响应方式不同。如果把两种模式代码混合在一起编程的话会造成程序混乱，所以很自然地就想到把两种模式分开控制。这就产生了“界面函数”这种结构，之所以叫它界面函数，是因为它们就像是一个个界面一样，每个界面完成不同的功能。下面先介绍一下这种程序结构的一般形式：</p>

<h1 id="section">1. 界面函数一般结构</h1>
<p>```
unsigned char FlagPage=0;</p>

<p>void main()
{
	/<em>初始化</em>/</p>

<pre><code>while(1)
{
	if(FlagPage==0)
		Task0();
	else if(FlagPage==1)
		Task1();
	else if(FlagPage==2)
		Task2();
	……
} }
</code></pre>

<p>void Task0()
{
	/<em>Do Something</em>/
	while(1)
	{
		/<em>Do Something</em>/
		if(FlagPage!=0)
			return;
	}
}
void Task1()
{
	/<em>Do Something</em>/
	while(1)
	{
		/<em>Do Something</em>/
		if(FlagPage!=1)
			return;
	}
}
void Task2()
{
	/<em>Do Something</em>/
	while(1)
	{
		/<em>Do Something</em>/
		if(FlagPage!=2)
			return;
	}
}
```
  可以看到，主循环其实不进行任何实际功能的处理，它完成的只是调用各个任务函数。对于比较大型复杂的系统，main函数的主循环里根本不放要实际处理的代码，而是把所有任务函数归到一起，根据选择进入相应的任务函数，当处理完该任务之后又会回到主循环，由主循环再次分配任务。<br />
  此时主循环的作用就是调配任务（当然用来调配任务的主循环本身也是一个最基本的任务），而在被调配的任务里面可能还会再次被该任务调配的子任务。<br />
  再来看看被调用的任务函数，这些函数已经不只是完成一些简单功能了，它并不是执行一些固定操作后返回，每个任务函数都有自己的一套控制逻辑，并且“不那么容易返回”。<br />
  这些任务函数同属于一个进程，但是同一时刻只有一个可以运行。当进入某个函数时，可以说进程被这个函数阻塞，其他函数得不到运行。但这也就是我们需要的效果，因为每个函数都有自己的一套控制逻辑，不需要考虑其他界面函数。<br />
  而在函数退出时，可以由该函数本身通过FlagPage指定下一个要进入的函数，或者本来就是由于外部（中断）修改了FlagPage变量才导致该函数退出的。<br />
  这种结构是非常常用的，并且尤其适合那些有多种界面（或者说多种工作模式）的场合。<br />
  比如电子钟里可能有时钟界面、设置界面，再复杂一点有秒表、定时器等界面，从一个界面进入到另一个界面都是由按键控制的。如：在时间界面按下设置键进入到设置界面，按下返回键就进入到logo界面。这一个个界面也就是任务函数，只不过这个任务函数不会自动跳出，而是根据按键情况决定是否跳出、并通知主循环要跳到哪。<strong>每个界面里也会有选择地对其他进程提供的信息进行处理，比如时间界面就会对时间累加进程所提供的时间信息进行显示，同时也会对按键扫描进程提供的按键序号进行处理；而logo界面只会对按键信息进行响应，忽略时间进程提供的时间，但是时间进程仍然在运行。这些进程都是由定时器进行的，在后面会说。</strong><br />
  再如电子设计大赛的小车程序就是，它分为领跑模式、跟随模式、超车模式等，每种模式就是一个界面函数，只不过在运行的过程中不允许有外部操作，完全由每个界面函数本身根据采集到的当前状态信息决定是否退出，并结合一些其他全局变量判断下一个要进入的模式。<br />
  以上把这个典型结构做了一个简单介绍。</p>

<h1 id="section-1">2. 更高的角度分析这种结构</h1>

<p>  在2.1节分析了一下界面函数这种典型结构，在此我想借这种结构分析一下整个系统的构成。把上述系统用下面这个图表示：
<img src="/images/dan-pian-ji-bian-cheng/chengxujiegou.jpg" alt="程序结构示意图" /></p>

<p>  这里面所有函数都是由主函数调用的，属于主进程，并且这些函数也都体现出了系统结构。<br />
  例如在函数1里面想进入函数2，不是直接调用函数2，而是先返回函数1，再由主循环分配到函数2。<br />
  正如前面所说，这种程序结构特别适合于多种“界面”的功能。一般情况下，主进程不会停留在主循环里，而是偶尔退出到主循环重新分配下一个将要进入的函数，大部分时间会停留在某个界面函数里。</p>

<p>  此外，这些函数之间<strong>有一些公共变量，这些变量的作用就是被各个函数使用，甚至用于函数间通信，辅助完成这些函数之间的逻辑结构的构建。</strong>比如1.1节中提到重要的FlagPage变量，这个标志变量就指明了当前工作于哪种工作模式下，任何函数（包括中断进程中的函数）都可以通过改变此变量来切换工作模式。<br />
  <strong>也有一些与函数对应的用于完成特定功能的变量。</strong>比如用于数码管或者显示屏显示的现存，这些显存是有特定用处的，一般其他函数不会使用（但确实是公共变量，是可以被使用的）。</p>

<p>  上面是把变量进行了分类，与之对应地我们也把函数进行分类。<br />
  图中的函数都是所谓的“界面函数”，是用于完成某一特定任务的函数，一般进入这个函数后主进程就会停在里面，当达到特殊目的后返回。而这些“界面函数”也会不断地调用其他函数完成功能，比如延时等。<br />
  这些<strong>被界面函数调用的函数把它们称作“工具函数”</strong>。这些功能函数中有一些是公用的，比如延时函数，很多地方都会用到。而<strong>也有一些是某一个界面函数才会用到的，用于完成这个特殊功能的函数</strong>，比如用于完成屏幕显示用到的屏幕驱动函数、字符显示函数等，这些函数在其他地方几乎不会被调用。<br />
  这些函数、变量结构是在编程中自然产生的，在此将它们明确分类一下，整个系统的构成有：</p>

<ul>
  <li>1、<strong>整体的程序框架是由各个界面函数和少数关键的全局变量构建起来的。</strong>这是构成系统的主体框架。</li>
  <li>2、每个界面函数在完成特定功能时，会携带一些为自己服务的“私有的”变量和函数。</li>
  <li>3、为整个框架服务的还有一些常用的变量和函数，它们完成的是一些通用功能，可以把它们理解为“库函数”。</li>
</ul>

<hr />

<p>  需要提一下，到目前为止讨论的程序结构都没有考虑中断，或者说到目前为止都是把中断当作程序运行过程中的特殊情况处理，并没有融入到整个系统构建的问题内讨论，但是中断确实是存在的。请大家思考一下这种情况会发生什么事情：主进程所构建的程序框架会有一些服务函数，这些服务函数在中断处理程序里也可能会被用到。比如主进程在调用延时函数时被中断，而中断处理程序也调用了该延时函数，这会怎么样呢？<br />
  这就是所谓“函数重入”问题，在此不想过多地讨论该问题，要知道51单片机的编译器keil默认是不支持函数重入的（事实上，如果你这样做了编译器会发出警告的）。<br />
  所以，至少对于51单片机编程来说，在遇到多个进程编程时要注意这样一个原则：中断处理程序不要调用到可能被中断的函数。必要时可以为中断进程单独写一个服务函数，函数内容可能跟主进程中的某个函数一模一样，但这样可以避免上述问题。</p>

<p>  以上就是对“界面函数”这个典型结构的介绍，也分析了整个系统的构成。但是，正如上面说过的，这些都是对一个进程的结构的讨论，并没有涉及到中断。后面的内容会引入中断，甚至到最后把所有的任务都放到中断处理函数里，你会发现把任务放到中断处理函数里有着巨大的优势。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第1章 主函数顺序调用]]></title>
    <link href="http://nicekwell.github.io/blog/20160919/di-1zhang-zhu-han-shu-shun-xu-diao-yong.html"/>
    <updated>2016-09-19T18:38:40+08:00</updated>
    <id>http://nicekwell.github.io/blog/20160919/di-1zhang-zhu-han-shu-shun-xu-diao-yong</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 主函数顺序调用的一般结构</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 主函数顺序调用结构的特点</a></li>
</ul>

<p>  写过单片机程序都知道，在main函数的结尾会有个 while(1) 循环，它就是单片机的归宿。</p>

<p>  在不考虑中断的情况下，整个单片机的最根本任务就是这个循环，由于在主函数里，在此我们称它为“主循环”，认为main函数及其调用的所有子函数（以及子函数调用的子函数）都在“主进程”里。</p>

<!-- more -->

<h1 id="section">1. 主函数顺序调用的一般结构</h1>

<p>  这种结构基本上都是在main函数开始完成一些初始化,然后在主循环里周期性地调用一些函数:</p>

<p><code>
void main()
{
    /*模块初始化*/
    while(1)
    {
        Fun1();
        Fun2();
        ......
    }
}
</code></p>

<p>  在初学单片机时，大部分精力都放在单片机和各个模块的驱动上，所以在开始相当长的一段时间里采用的都是这种程序结构。</p>

<p>  而Fun1、Fun2……这些函数完成的功能也都是比较简单的，每个函数完成一个简单的小功能，然后顺序执行就可以组合完成某个功能。</p>

<p>  这些函数虽然功能简单，但是占用CPU资源不一定少，比如最简单的一个独立按键扫描程序：</p>

<p><code>
sbit key=P1^0;
unsigned char keyscan()	//返回0代表按下，1代表没按下
{
    if(key==0)	//说明按键按下
    {
	delay5(1);	//延时5ms去抖
	if(key==0)	//确认按键按下
	{
            while(key==0);//等待按键释放
            return 0;
        }
    }
    return 1;
}
</code>
  这是一个功能很简单的函数，主函数调用它进行按键扫描。注意到：<br />
  1、这个程序里有一个5ms延时函数，在延时的这段时间里单片机运行一些无意义的指令消耗时间。在此期间其他任务得不到运行，整个进程阻塞在延时函数这个地方。<br />
  2、如果按键一直按下没有释放的话，程序将停留在while(key==0); 处，此时主进程里的其他函数都得不到执行。</p>

<h1 id="section-1">2. 主函数顺序调用结构的特点</h1>
<p>  第一点，正如这种结构的名称是“顺序调用”，任务之间的运行顺序是固定不变的，各个任务之间没有优先级的区别，它只适合完成周期性循环的工作。<br />
  第二点，一个任务运行时，其他任务得不到执行。如果其中某个任务由于某种原因卡住了，它将阻塞整个进程的运行。<br />
  第二点能否接受呢，要看具体情况。比如每个任务需要5ms的执行时间（内部可能有一些必要的延时函数），总共四个任务。如果整个单片机系统完成的只是简单的人机交互之类的功能，这是完全可以接受的，因为我们根本察觉不到每个任务在分开运行，在我们看来它们就是并行的。但是如果完成的是像通信协议之类的驱动的话，这是接受不了的，某个任务在执行的过程中可能其他任务有更迫切的需求。</p>

<p>  任务执行的并行与否是相对而言的，要根据具体的情况。如果我们的要求不高，用这种简单的结构当然是最方便的，但是这种简单的结构也确实存在很多不足，有很多可以改进的地方。这是接下来几章要讨论的问题。</p>

<p>  在此我们明确一下这种结构的特点：<br />
<strong>  1、由主循环调用的任务的执行顺序是固定的。<br />
  2、由主循环调用的任务都只能单独地运行，进入一个任务，就不能处理其他任务。<br />
  3、这些任务执行时间一般会比较长（相对后面几章改造过的任务函数而言），某一个任务里面的延时函数会造成整个进程被延时。</strong></p>

<p>  在操作系统的书籍中把这种结构也叫做“前后台系统”，他们把主循环称作后台，中断称作前台。用操作系统的语言来说“应用程序是一个无限的循环，循环中调用相应的函数完成相应的功能”。由于函数是循环调用的，所以“在最坏情况下的任务级响应时间取决于整个循环的执行时间”。<br />
  本文在这里没有考虑中断，也就纯粹讨论的是后台系统。</p>

<p>  第2章将介绍如何构建复杂的后台系统结构，并将程序框架和任务函数分立，明确系统的构建和任务函数的实现在整个单片机编程系统中的区别。而不要混为一谈盲目的构建系统。<br />
  在接下来的第3章到第6章将会发现程序的主体逐渐从后台转移到了前台，在转移的过程中会对任务函数进行改造，并明确这些改造的目的和优势。</p>

]]></content>
  </entry>
  
</feed>
