<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 单片机编程 | 生命不息 折腾不止]]></title>
  <link href="http://nicekwell.net/blog/categories/dan-pian-ji-bian-cheng/atom.xml" rel="self"/>
  <link href="http://nicekwell.net/"/>
  <updated>2017-11-22T20:03:52+08:00</updated>
  <id>http://nicekwell.net/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[谈一谈单片机开发的几种调试方案]]></title>
    <link href="http://nicekwell.net/blog/20170411/tan-%5B%3F%5D-tan-dan-pian-ji-kai-fa-de-ji-chong-diao-shi-fang-an.html"/>
    <updated>2017-04-11T20:59:27+08:00</updated>
    <id>http://nicekwell.net/blog/20170411/tan-[?]-tan-dan-pian-ji-kai-fa-de-ji-chong-diao-shi-fang-an</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">我们做调试工具追求的是什么</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">几种调试方案</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">1、加入屏和按键</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">2、串口+上位机</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">3、用树莓派</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">4、串口+通用终端工具</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">如何构建终端工具里的控制台界面</a>    <ul>
      <li><a href="#section-7" id="markdown-toc-section-7">1、构建界面用到的特殊字符串</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">2、封装好的库函数</a></li>
    </ul>
  </li>
  <li><a href="#endif" id="markdown-toc-endif">endif</a></li>
</ul>
<p>  </p>

<p>单片机开发过程中，有一个好的调试系统可以极大地提高开发效率。<br />
举个例子，做平衡系统时调节PID参数，你会选择 修改参数–&gt;编译–&gt;烧录–&gt;运行–&gt;修改…，还是做一个功能可以一边运行一边修改参数呢？<br />
调试的方法有多种，在这就来分别谈一下我在开发过程中使用过的几种调试方案。<br />
这里的调试方案也是一种交互方案，但此方案不是为了交互而设计，重在快速地搭建、方便地使用、高效地调试，换句话说长得丑无所谓。</p>

<!-- more -->

<h1 id="section">我们做调试工具追求的是什么</h1>

<p>做调试系统无非是为了两点：</p>

<ol>
  <li>实时显示一些必要信息。</li>
  <li>实时修改，其实也就是可以实时接收指令。</li>
</ol>

<p>为了提高开发效率，我们进一步希望：</p>

<ol>
  <li>调试系统搭建起来方便快捷，最好可以统一标准，方便移植。<br />
我们不希望在调试系统上花费太多工作量，不要太复杂，尽量轻量级。</li>
  <li>直观显示，看得清楚。</li>
  <li>方便输入，操作快捷。</li>
</ol>

<h1 id="section-1">几种调试方案</h1>

<h2 id="section-2">1、加入屏和按键</h2>

<p><img src="/images/misc/2017-04-12_1.jpg" alt="" /></p>

<p>最直接的方法就是在嵌入式系统中加入屏和按键，做出一个界面，显示信息和接收按键指令。<br />
【优点】跟随系统，不需要依赖其他设备，可以随时随地调试。</p>

<p>【缺点】</p>

<ol>
  <li>添加了硬件。硬件的设计和焊接还是需要花费一些精力的。</li>
  <li>构建界面同样也要花费不少精力。</li>
  <li>显示信息有限。<br />
加入的屏通常显示内容比较少，会受到一些限制。</li>
  <li>按键功能有限。<br />
加入的按键通常也不会太多，并且如果我们考虑到长按、组合键等操作的话构建程序也是比较复杂的。</li>
</ol>

<p>【总结】<br />
肯定不能算轻量级，功能有限，可移植性差，花费精力多，屏需要额外费用。<br />
唯一的优点就是跟随系统，没有其他依赖。</p>

<p>所以如果不是非要随时调试的话不建议用这种方法，单纯为了调试来说代价还是比较大的。</p>

<h2 id="section-3">2、串口+上位机</h2>

<p><img src="/images/misc/2017-04-12_2.jpg" alt="" /></p>

<p>单片机自己不负责显示，它把数据发送出去，由上位机显示；也不负责按键检测，由上位机负责并接收上位机指令。<br />
单片机和上位机之间需规定好通信协议。</p>

<p>通信方式可以是串口也可以是其他，上位机可以是图形也可以是命令行。</p>

<p>【优点】</p>

<ol>
  <li>对单片机来说做到了一定的轻量级。只需要考虑发送数据和接收指令的协议。</li>
  <li>对于比较复杂的功能，好的上位机，尤其是图形化的上位机可以很方便地调试。</li>
</ol>

<p>【缺点】</p>

<ol>
  <li>需要设计通信协议，双方都要位通信协议写代码。这需要花费一定的精力。</li>
  <li>制作上位机需要花费较多的精力，并且上位机不通用。</li>
</ol>

<p>【总结】<br />
由于上位机在电脑上，有丰富的显示和控制资源，做出一个好的上位机可以极其方便地提高效率。<br />
但制作上位机要花费大量精力。</p>

<p>所以，如果上位机是作为产品发布，是值得花精力去做的；但如果仅仅是为了调试时用一下，不值得这样做。</p>

<p><strong>到这里有没有注意到，其实我们是想找到一个通用的”显示器”，能够方便地把信息显示出来。
显示器是已经做好的，不需要我们再做什么，通信协议尽可能简单，最好能直接输出。
后面我们会找到这么一个好东西。</strong></p>

<h2 id="section-4">3、用树莓派</h2>

<p><img src="/images/misc/2017-04-12_3.jpg" alt="" /></p>

<p>用树莓派进行关键计算，我们关心的数据都在树莓派的程序里。<br />
由于树莓派里运行linux系统，在其连接网络后，我们可以用局域网里电脑的终端登陆树莓派，在树莓派的程序里直接打印接口显示出来。</p>

<p><em>注：<br />
在命令行下打印数据并不一定是一行一行地输出，也可以控制光标在指定位置输出，构建出一个简单的界面。这里不做介绍，具体可搜索”控制台编程”。<br />
命令行下接收键盘操作也不一定非要输入字符再回车，程序里可以直接监测键盘。<br />
总之在命令行中是可以构建出一个类似于 显示屏+按键 组合的”设备”的。</em></p>

<p>【优点】</p>

<ol>
  <li>终端就相当于是一个现成的、通用的显示屏，任意可登陆ssh的终端都可使用。</li>
  <li>程序里直接打印输出！这真是太方便的，c语言中一个printf即可，相当于是一个极其简单的通信协议。</li>
</ol>

<p>【缺点】</p>

<ol>
  <li>贵！一个小小的智能车都要塞个树莓派，树莓派价格都够好多个智能车了。</li>
  <li>树莓派本身是重量级。虽然程序本身是方便了，但使用之前需要配置树莓派，虽然一个树莓派只要配置一次。</li>
  <li>树莓派本身硬件功能有限，有些功能树莓派不能直接完成，还是需要借助单片机，并和单片机通信。<br />
比如记录车轮旋转的正交编码器，stm32有专门的硬件模块完成，树莓派没有，如果树莓派想要记录车轮旋转的话还是需要借助stm32，并且设计如何获取stm32记录的数据。</li>
</ol>

<p>【总结】</p>

<p>对于调试这一方面来说，树莓派是非常方便的，输出、输入都是直接完成。<br />
所以如果你的项目值得用树莓派，那调试是非常方便的；如果不需要用树莓派，光是为了调试方便而使用是不建议的，请考虑上面3个缺点。</p>

<p><strong>虽然树莓派本身不一定最合适，但我们找到了方向——终端。</strong></p>

<h2 id="section-5">4、串口+通用终端工具</h2>

<p>单片机能不能用终端呢？答案是肯定的。<br />
有多种终端工具可以通过串口使用，比如windows自带的超级终端，linux和osx下命令行里的minicom，以及夸三个平台的图形化终端secureCRT。<br />
这些终端工具的功能简单来说就是：1、当某个按键按下立刻发送该按键的键码出去，比如按下p键发送字符’p’。2、接收串口数据并显示出来。</p>

<p>说明：</p>

<ol>
  <li>这些终端工具的协议是相同的，可以认为是通用的显示器和键盘。</li>
  <li>单片机可以发送一些特殊字符串完成一些特殊操作，比如清屏、控制光标位置。利用这些功能可以构建出简单的界面。<br />
这些操作功能已经封装成了函数，会在本文后面给出。</li>
  <li>一般会先在单片机中实现printf功能，实现之后在程序中用printf即可直接在终端工具中显示信息。<br />
实现printf功能的方法在这里不介绍，具体可上网查找，工作量并不大。其实就是重定义一个函数，使printf函数通过指定串口输出字符串。</li>
  <li>串口通过蓝牙模块可快速实现无线传输。</li>
</ol>

<p>【优点】</p>

<ol>
  <li>单片机端轻量级，上位机端无工作量。<br />
具体来说单片机端要做的事情有：初始化串口，重定向printf，通过特殊字符串控制光标构建界面。</li>
  <li>上位机端通用，单片机端显示相关的代码方便移植。<br />
本文后文会给出显示相关的库函数。</li>
  <li>硬件扩展几乎没有。</li>
</ol>

<p>【缺点】</p>

<p>对比第1种方案，需要一台电脑。其他方面都具有很大优势。</p>

<p>【总结】</p>

<p>此方案是单片机开发调试的理想选择。</p>

<p>下面会介绍如何在终端工具里构建出界面。</p>

<h1 id="section-6">如何构建终端工具里的控制台界面</h1>

<h2 id="section-7">1、构建界面用到的特殊字符串</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">字符(串)</th>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">\r</td>
      <td style="text-align: center">光标移到行首</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">\b</td>
      <td style="text-align: center">退格</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[2J”</td>
      <td style="text-align: center">清屏</td>
      <td style="text-align: center"><strong>清屏后光标还在原来位置</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[2K]”</td>
      <td style="text-align: center">清除本行</td>
      <td style="text-align: center">清除后光标还在原来位置</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[H”</td>
      <td style="text-align: center">光标复位，回到左上角（1行1列）</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%d;%dH”, y, x</td>
      <td style="text-align: center">设置光标到y行x列</td>
      <td style="text-align: center">终端中的行和列都是从1开始数的</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dA”, y</td>
      <td style="text-align: center">光标上移y行</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dB”, y</td>
      <td style="text-align: center">光标下移y行</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dD”, x</td>
      <td style="text-align: center">光标左移x列</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dC”, x</td>
      <td style="text-align: center">光标右移x列</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[?25l”</td>
      <td style="text-align: center">隐藏光标</td>
      <td style="text-align: center">在secureCRT中测试无效</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[?25h”</td>
      <td style="text-align: center">显示光标</td>
      <td style="text-align: center">在secureCRT中测试无效</td>
    </tr>
  </tbody>
</table>

<p>注：</p>

<ol>
  <li>终端工具里的x、y坐标都是从1开始数的，同时等于0的话终端也会认为是1。</li>
  <li>\033代表的是八进制033，对应十进制是27，十六进制是0x1B。</li>
</ol>

<h2 id="section-8">2、封装好的库函数</h2>

<p>使用这个库函数的前提是：<br />
1、主函数完成了串口初始化，串口功能正常使用。<br />
2、重定向了printf函数，printf函数可通过串口输出字符串。</p>

<p>disp.h文件：</p>

<p>``` c
#ifndef <strong>DISP_H</strong>
#define <strong>DISP_H</strong>
/* 在主函数已经完成串口初始化，并且重定向printf函数之后，
   这里提供一些列函数用于操作终端工具显示，可在终端工具里构建界面。 */
#include <stm32f10x_lib.h></stm32f10x_lib.h></p>

<p>void disp_clean(void);
void disp_clean_line(void);     //清除当前航，并复位光标到行首
void disp_cursor_reset(void);        //复位光标位置，回到左上角（1行1列）
void disp_gotoxy(int x, int y);  //跳转到y行x列，x和y都是从1开始数。
void disp_cursor_up(int y);      //上移x行
void disp_cursor_down(int y);    //下移y行
void disp_cursor_left(int x);    //左移x列
void disp_cursor_right(int x);   //右移x列
void disp_cursor_hide(void);     //隐藏光标，在secureCRT中测试无效。
void disp_cursor_show(void);     //显示光标，在secureCRT中测试无效。</p>

<h1 id="endif">endif</h1>
<p>```
disp.c文件：</p>

<p>``` c
#include <disp.h>
#include <uart.h>
#include <stdio.h></stdio.h></uart.h></disp.h></p>

<p>void disp_clean(void)
{
    printf(“\033[2J”);
}
void disp_clean_line(void)      //清除当前行，并复位光标到行首
{
    printf(“\33[2K\r”);
}
void disp_cursor_reset(void)        //复位光标位置，回到左上角
{
    printf(“\033[H”);
}
void disp_gotoxy(int x, int y)  //跳转到y行x列
{
    printf(“\033[%d;%dH”, y, x);
}
void disp_cursor_up(int y)      //上移x行
{
    printf(“\033[%dA”, y);
}
void disp_cursor_down(int y)    //下移y行
{
    printf(“\033[%dB”, y);
}
void disp_cursor_left(int x)    //左移x列
{
    printf(“\033[%dD”, x);
}
void disp_cursor_right(int x)   //右移x列
{
    printf(“\033[%dC”, x);
}
void disp_cursor_hide(void)     //隐藏光标
{
    printf(“\033[?25l”);
}
void disp_cursor_show(void)     //显示光标
{
    printf(“\033[?25h”);
}
```</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第6章 面向对象思想+事件驱动结构]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou.html"/>
    <updated>2016-09-19T23:52:32+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 对象和事件</a></li>
  <li><a href="#c" id="markdown-toc-c">2. C语言对一个对象的封装</a></li>
  <li><a href="#define-list1listcount-3" id="markdown-toc-define-list1listcount-3">define List1_ListCount 3	//列表长度为固定</a></li>
  <li><a href="#endif" id="markdown-toc-endif">endif</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">3. 事件分配机制</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">4. 系统层构建</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">5. 库函数</a></li>
</ul>

<p>  先来看一下这个东西吧：<a href="http://v.youku.com/v_show/id_XNTk2NzExMjg4.html">http://v.youku.com/v_show/id_XNTk2NzExMjg4.html</a>。</p>

<p>  看完之后应该会觉得这个东西的结构非常复杂，这是笔者做过的最复杂的项目之一。由于是给公司开发的，所以和上一章一样不能公开源代码，但是会举一些简单的例子说明。<br />
  刚接到这个项目了解了大体功能后，第一反应是用“界面函数”的结构。确实，这个东西是非常适合用界面函数完成的，但是由于当时笔者正在自学C++，于是用C++的思路分析了一下这个项目：<br />
  1、总共有4个界面，而且有两个和列表框好像啊。<br />
  2、几乎所有的动作都是由旋转编码器触发的。<br />
  经过一番思考之后，笔者决定做一次尝试，用面向对象的思想加上事件驱动的机制完成它。</p>

<p>  下面就介绍一下这种结构，也希望能借此说明“对象”和“事件”的概念。</p>

<!-- more -->

<h1 id="section">1. 对象和事件</h1>

<p>  基本上每个面向对象语言的书都会把对象的概念说一下。在这个项目里有4个界面，把这四个界面看作四个对象，这四个对象的所有动作都由事件驱动。<br />
  什么又是“事件”呢？简单来说“一个对象发生了某个事情”就是这个对象的某种事件。事件一定是基于某个特定的对象而言的，不能简单地说“发生了某个事情”，应该说“某个对象发生了某个事情”。而我们要做的就是确定“每个对象有哪些事情会发生”，并完成“某个对象在发生某个事情时要做的事”。</p>

<p>  所以对于一个对象而言，它应该有：</p>

<ul>
  <li>1、与它对应的事件函数，用于执行“某个事件发生时要做的事”，一个对象所拥有的这些函数的个数和它可能发生的事件数是相等的。</li>
  <li>2、完成上述函数所需要的辅助函数。<br />
这些函数有些可能是公共的，是由系统提供的API或者其他工具函数；<br />
也可能是这个对象特有的，是对这个对象做的某种更改。</li>
  <li>3、每个对象都有自己的属性，这些属性在程序中的体现就是变量。</li>
</ul>

<p>  这里面，1和2的函数本质上都是一样的，都是这个对象所包含的函数。不同的是：<br />
  与事件相对应的函数称它为这个对象的“事件”，这些函数数量与这个对象的事件数是相等的；<br />
  完成某种特定操作的函数称它为这个对象的“方法”，也就是“这个对象可以做的事”。并且这些方法中，有些是允许被外界调用的，有些只允许在本对象内使用，所以又分为“公共方法”和“私有方法”。</p>

<p>  下面就以一张表来说明一个对象内部的组成，以及各个成员的含义：</p>

<p><img src="/images/dan-pian-ji-bian-cheng/duixiang.png" alt="对象的组成" /></p>

<p>  有了这些了解之后我们就可以开始构建整个系统了。</p>

<h1 id="c">2. C语言对一个对象的封装</h1>

<p>  在C++ 中有专门的对象结构，它可以把对象里的函数和变量分为公共、私有等类型。</p>

<p>  而在C语言中没有这样的结构，我们通过使用上的约定也可以达到同样的效果。比如一个内部的函数，我们约定有些函数外部可以调用，它就是公共函数；约定有些函数外部不要调用，它就是私有函数。</p>

<p>  下面是对象的各个部分在C语言中的形式及意义：</p>

<p><img src="/images/dan-pian-ji-bian-cheng/duixiang1.png" alt="对象的各个部分在C语言中的形式及意义" /></p>

<p>  公共方法和事件本质上都是对外公开的函数。公共方法完成对本对象的某一主动的操作，而事件是完成对外部被动的响应。<br />
  甚至可以把事件从对象的组成中取出来，把事件归到系统范畴。</p>

<hr />

<p>  下面就以一个简单的列表框的例子说明如何封装一个对象，假设这个列表框（对象）的名字叫做List1，一共只有3个列表项，每个列表项都有一个自己的名称和内容（0~255），有一个光标指示当前选中列表项，分配的事件有“列表项+1”“列表项-1”“列表项内容+1”“列表项内容-1”，并且这些改变是可以循环的（255+1=0，0-1=255）。</p>

<p>  假设屏幕显示的网格是4行16列，外部提供的绘图函数有：<br />
  Disp(r,c,unsigned char *)       //往r行c列写入一个字符串<br />
  Clear()        //清屏</p>

<p>  有了这些条件后，对这个对象的封装如下：</p>

<ul>
  <li>List1.c</li>
</ul>

<p><code>
/* List1 */
void Clear();	//清屏函数
void Disp(unsigned char r,unsigned char c,unsigned char *p);	//在r行c列显示字符串
/**************公共变量*****************/
#define List1_ListCount 3	//列表长度为固定
unsigned char List1_ListIndex=0;	//当前选中的列表项，从0开始数
#define List1_StartIndex 0	/*当前屏幕显示的第一个列表项序号，从开始数，
				由于屏幕能一次性把所有的3个列表项都显示出来，所以这里是固定的值。*/
unsigned char List1_ListData[3];	//三个列表项的数据
/**************私有变量***************/
unsigned char code List1_Name0[]="Power";	//第0号列表项的名称
unsigned char code List1_Name1[]="Mode ";	//第1号列表项的名称
unsigned char code List1_Name2[]="K    ";	//第2号列表项的名称
/**************私有方法***************/
void List1_DispName()	//在固定位置显示个列表项的名称
{
	Disp(0,1,ListName0);	//显示号列表项名称
	Disp(1,1,ListName1);	//显示号列表项名称
	Disp(2,1,ListName2);	//显示号列表项名称
}
void List1_DispCursor()	//在当前选中列表项前显示“&gt;”，没选中的显示空格
{
	unsigned char i;
	for(i=0;i&lt;List1_ListCount;i++)
	{
		if(i==List1_ListIndex)
			Disp(i,0,"&gt;");
		else
			Disp(i,0," ");
	}
}
void List1_DispData(unsigned char n)	//显示n号列表项的数据
{
	unsigned char vm[4];	//现存，以十进制显示，总共三位数
	//先计算现存
	vm[0]=List1_ListData[n]/100+0x30;	//计算百位的现存
	vm[1]=(List1_ListData[n]%100)/10+0x30;	//计算十位的现存
	vm[2]=List1_ListData[n]%10+0x30;	//计算个位的现存
	vm[3]='\0';	//字符串结尾
	//下面开始显示
	Disp(n,10,vm);	//从n行列开始写入数据
}
/***************公共方法************************/
void List1_Show()
{
	//先清屏
	Clear();
	//再显示所有列表项的名称
	List1_DispName();
	//再显示所有列表项的数据
	{
		unsigned char i;
		for(i=0;i&lt;List1_ListCount;i++)
			List1_DispData(i);
	}
	//再显示光标
	List1_DiapCursor();
}
void List1_Hide()
{
	Clear();
}
void List1_SelectedListP1()	//当前选中项内容+1
{
	List1_ListData[List1_ListIndex]++;
	List1_DispData(List1_ListIndex);
}
void List1_SelectedListM1()	//当前选中项内容-1
{
	List1_ListData[List1_ListIndex]--;
	List1_DispData(List1_ListIndex);
}
void List1_ListP1()	//选中项序号+1
{
	List1_ListIndex++;
	if(List1_ListIndex==3)	//实现循环
		List1_ListIndex=0;
	List1_DispCursor();	//刷新光标
}
void List1_ListM1()	//选中项序号-1
{
	List_ListIndex--;
	if(List_ListIndex==0xff)	//实现循环
		List1_ListIndex=2;
	List1_DispCursor();	//刷新光标
}
/**************事件******************/
void List1_Key0Down()	//0号键按下，让选中项序号-1
{
	List1_ListM1();
}
void List1_Key1Down()	//1号键按下，让选中项序号+1
{
	List1_ListP1();
}
void List1_Key2Down()	//2号键按下，让选中项内容-1
{
	List1_SelectedListM1();
}
void List1_Key3Down()	//3号键按下，让选中项内容+1
{
	List1_SelectedListP1();
}
</code></p>

<p>  在其他地方只要包含这个List1.c文件就可以调用该对象里的各种方法和事件函数了，里面的私有方法和私有变量虽然约定外部是不要使用的，但是外部确实是可以调用的。所以也可以为这个对象写一个List1.h文件，只把公开的部分进行声明：</p>

<ul>
  <li>List1.h</li>
</ul>

<p>```
/* List1 */
#ifndef LIST1_H
#define LIST1_H</p>

<h1 id="define-list1listcount-3">define List1_ListCount 3	//列表长度为固定</h1>
<p>unsigned char List1_ListIndex=0;	//当前选中的列表项，从开始数
#define List1_StartIndex 0	/<em>当前屏幕显示的第一个列表项序号，从开始数，
					由于屏幕能一次性把个列表项都显示出来，所以这里是固定。</em>/
unsigned char List1_ListData[3];	//三个列表项的数据
/<strong>**</strong><strong>**</strong><strong><em>公共方法</em></strong><strong>**</strong><strong>**</strong><strong>**</strong><strong><em>/
void List1_Show();
void List1_Hide();
void List1_SelectedListP1();	//当前选中项内容+1
void List1_SelectedListM1();	//当前选中项内容-1
void List1_ListP1();//选中项序号+1
void List1_ListM1();//选中项序号-1
/</em></strong><strong>**</strong><strong>**<em>事件</em></strong><strong>**</strong><strong>**</strong>***/
void List1_Key0Down();	//0号键按下，让选中项序号-1
void List1_Key1Down();	//1号键按下，让选中项序号+1
void List1_Key2Down();	//2号键按下，让选中项内容-1
void List1_Key3Down();	//3号键按下，让选中项内容+1</p>

<h1 id="endif">endif</h1>
<p>```</p>

<p>  如果采用了List1.h的话，要把List1.c文件里重复定义的部分给去掉。<br />
  每个对象有每个对象的特点，它们差别很大，构建方法也是大不相同的。但是每个对象构建好之后就是一个模板，它是非常独立的，在其他地方只要把代码直接复制过去做少量更改就可以使用了。</p>

<h1 id="section-1">3. 事件分配机制</h1>

<p>  一个工程中会有多个对象，每个对象都有一些可能会发生的事件，这些事件函数是由系统调用的，由系统来判断什么对象发生了什么事件。<br />
  比如在这个项目中，基本的事件有：左编码器按下、右编码器按下、左编码器左旋、左编码器右旋、右编码器左旋、右编码器右旋、左编码器按下左编码器左旋、左编码器按下左编码器右旋、右编码器按下右编码器左旋、右编码器按下右编码器右旋、串口接收数据事件、IIC接收数据事件。<br />
  由于旋转编码器的驱动本身用的就是外部中断，外部中断对单片机来说就是一种意外事件。所以只要在中断里判断当前进行的是什么操作，并记录当前哪个界面正在被使用，就可以调用相应对象的相应事件了。<br />
  然而，并不是所有的对象都一定具有所有的这些事件，根据该对象功能的需要，选用一部分有用的事件进行响应。比如在IIC界面里不考虑串口，这个界面就只响应IIC接收数据事件，而忽略串口接收数据事件。<br />
  事件并不一定非要由外部中断产生，也可能是系统虚拟的。<strong>总之事件分配有系统完成，系统利用各个资源抽象出事件概念，然后分配到相应对象上。</strong></p>

<p>  下面是一个完成事件分配的例子：</p>

<p><img src="/images/dan-pian-ji-bian-cheng/eint.png" alt="中断电路" /></p>

<p>  有两个按键，任意一个按键按下都会触发int0中断。假设共有2个对象，下面是事件分配的代码：</p>

<p>```
unsigned char FocusNum=0;	//标志当前获焦的对象序号，在此只有两个对象，范围是0~1
sbit kint0=P3^2;
sbit k0=P0^0;
sbit k1=P0^1;</p>

<p>……</p>

<p>void int0() interrupt 0
{
    EA=0;	//关中断</p>

<pre><code>if(k0==0)	//说明是k0按下
{
    switch(FocusNum)
    {
    case 0:	//对象0
        Form0_k0Down();
        break;
    case 1:	//对象1
        Form1_k0Down();
        break;
    }
}
else if(k1==0)	//说明是k1按下
{
    switch(FocusNum)
    {
    case 0:	//对象0
        Form0_k1Down();
        break;
    case 1:	//对象1
        Form1_k1Down();
        break;
    }
}

while(kint0==0);	//等待两个按键都释放     IE0=0;	//清除中断标志，防止在中断处理程序执行过程中再次触发了中断     EA=1;	//开中断 } ```
</code></pre>

<p>  采用FocusNum来记录当前激活的对象。</p>

<p>  在此想说明的是，k0和k1两个操作都是放在一个中断里的，具体产生什么事件则是再次通过代码判断的，这些代码属于系统层，是根据实际需要对事件的抽象。</p>

<p>  比如如果需要产生“两个按键同时按下”事件，则可按如下方式分配：</p>

<p>```
void int0() interrupt 0
{
    unsigned char 
    EA=0;	//关中断
    mdelay(200);    //这个延时是为了等待两个按键的状态都稳定，虽然我们是把两个按键同时按下，
                    //但肯定因为某个先按下触发中断，此时检测另一个按键不一定是按下的状态
    if(k0==0 &amp;&amp; k1!=0)	//说明是k0按下
    {
        switch(FocusNum)
        {
        case 0:	//对象0
            Form0_k0Down();
            break;
        case 1:	//对象1
            Form1_k0Down();
            break;
        }
    }
    else if(k1==0 &amp;&amp; k0!=0)	//说明是k1按下
    {
        switch(FocusNum)
        {
        case 0:	//对象0
            Form0_k1Down();
            break;
        case 1:	//对象1
            Form1_k1Down();
            break;
        }
    }
    else if(k0==0 &amp;&amp; k0==0)	//两个按键都按下
    {
        switch(FocusNum)
        {
        case 0:	//对象0
            Form0_BothDown();
            break;
        case 1:	//对象1
            Form1_BothDown();
            break;
        }
    }</p>

<pre><code>while(kint0==0);	//等待两个按键都释放
IE0=0;	//清除中断标志，防止在中断处理程序执行过程中再次触发了中断
EA=1;	//开中断 } ```
</code></pre>

<p>  甚至可以继续改，实现“k0按下时k1按下”“k1按下时k0按下”“k0长按”“k0连按”等事件，这里就不一个个实现了。<br />
  总之只要系统层能够识别的动作都可以抽象成事件。</p>

<h1 id="section-2">4. 系统层构建</h1>

<p>  在以前的编程中从来没把程序这么明确地分层，可能是因为这次项目比较复杂，并且用来面向对象的方法，所以这种结构自然就产生了。在各个对象中有一些公共方法，这些函数完成特定的功能，而他们都依赖于底层的支持。<br />
  当然可以让对象直接操作驱动函数，从最底层开始。但是这样的话，一方面用起来会很麻烦，另一方面可能不是所有的底层功能都会用到。<br />
  所以让系统层根据上层对象的需要把这些功能封装，并向上层提供使用接口。这是系统层做的事情之一。<br />
  另外系统层也会构建一些控制逻辑，这些功能并不在底层有实体的驱动函数，它是系统在软件层面抽象出来的。比如当前系统的数据显示进制、背光灯时间等，它们不对应底层的操作，仅在系统层抽象。对于上层的对象来说，根本不需要考虑这些，只要调用系统层提供的API就行了。<br />
  此外，系统层要做的当然还有事件分配，上一节介绍的事件分配系统是系统层核心的一部分，而系统层还有其他很多功能。事件分配系统是利用各个资源抽象出事件概念，并分配给各个对象。而本节讨论的系统层是利用各个资源，在底层驱动的支持下，根据需要构建出一些控制逻辑，并封装成系统API，供上层软件使用。</p>

<p>  综上，系统层做的事情有：<br />
  1、构建事件分配系统。<br />
  2、对底层驱动封装，并向上层提供操作接口。<br />
  3、根据需要再构建一些其他控制结构，并向上提供接口。</p>

<h1 id="section-3">5. 库函数</h1>

<p>  库函数也属于对系统对底层的封装。某些功能可能比较复杂，可以构成一整套体系，那么就可以把这些函数归位一类，作为完成某个功能的库函数。<br />
  这点和类似于操作系统的GTK库或者QT库，它们提供了大量的绘图函数。<br />
  在本项目中，使用了绘图库，它就是在底层对液晶屏操作的基础上建立的文字和图片显示函数，提供了在指定位置写入字符、汉字，以及反色写入、垂直镜像写入等功能。上层的对象调用这些函数会非常方便。<br />
  总结一下库的作用：利用系统层的API，或者跳过系统层直接调用驱动函数，构建出自己的一套控制逻辑，并对外提供基于这个控制逻辑的函数库。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第5章 定时器执行任务]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-5zhang-ding-shi-qi-zhi-xing-ren-wu.html"/>
    <updated>2016-09-19T22:52:11+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-5zhang-ding-shi-qi-zhi-xing-ren-wu</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 定时器执行任务的程序结构</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 定时器里面任务函数的特点</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3. 过程任务的定时器化</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4. 定时器执行任务程序结构总结</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">5. 我们追求的是什么</a></li>
</ul>

<p>  先来回顾一下：<br />
  在第2章中介绍了界面函数结构，它的思想是主进程为主体，外部的按键等作为特殊情况单独处理。但是当接触到的程序更复杂时，尤其是当程序里还要进行精确定时时，用单进程结构已经满足不了要求了，这就进一步产生了第3章的结构——定时器分配任务。<br />
  定时器分配任务结构在主进程结构基础上开辟了一个定时器进程，在这个进程里进行按键扫描任务、计时任务等。此时这些任务是不会被中断的，定时并且精确地每隔一段时间执行一次。当时的看法是：这些定时器里的进程完成任务后把结果保存，主进程可以选用这些结果进行处理。<br />
  此外定时器还要进行一个特殊的功能——给主进程下达命令，通知主进程进行某种动作。这个功能的本质就是向主进程提供了时间信息。<br />
  这种结构已经结合了定时器，并且已经把一些简短的代码直接放到了定时器中断处理程序里了，但还有相当一部分代码放在主进程里。不是说不能放在主进程里，而是当时没有明确出定时器中的各个进程是如何形成的，这些定时器中的任务有什么更深刻的特征。<br />
  本章就是专门讨论这些放在定时器里执行的任务。</p>

<!-- more -->

<p>  这种结构也有产生的背景，它源于一个“温度控制系统”的项目，具体内容大概有：数码管扫描、按键扫描、时间计时、蜂鸣器控制、温度控制，当温度低于某个值时启动一个固定功率的加热器，温度高于某个值时停止加热，温度更高时启动报警。<br />
  由于这是给公司做的项目，所以不公开源代码，不过不需要源代码也完全可以理解这个结构。<br />
  这个项目并不复杂，功能要求很明确，没有多个工作模式和界面。按开始的想法，这里面除了计时任务需要定时器外，其他任务都可以放在主进程里完成。但是这样的话可能就会出现各个任务之间的相互干扰，比如按下按键时进程被阻塞，数码管扫描就无法得到运行。<br />
  所以，在做这个项目时我尝试了另一种方法——把这些任务全部放在定时器中断处理程序里，由定时器驱动每个任务的运行，主循环什么也不做。<br />
  完成之后事实证明这种结构效果很不错，并且体现出了很多操作系统的思想。下面就来分析一下这种结构。</p>

<h1 id="section">1. 定时器执行任务的程序结构</h1>
<p>  【时间分配系统】
  这种结构的任务需要在定时器中断里执行，而定时器中断的时间不一定是任务想要调用的时间，并且不同的任务的调用时间可能不同。所以肯定有一个时间分配系统，这个系统在特定的时间调用不同的任务函数。<br />
  比如在这次的工程中，51单片机的定时器8位自动填装模式的定时时间不会太长，定时时间设为250us。而按键扫描、数码管扫描、蜂鸣器控制、温度控制、时间控制，这几个任务的执行时间是不一样的：</p>

<table>
  <tbody>
    <tr>
      <td>  </td>
      <td>任务名称</td>
      <td>调用时间</td>
    </tr>
    <tr>
      <td>  </td>
      <td>——</td>
      <td>——</td>
    </tr>
    <tr>
      <td>  </td>
      <td>按键扫描</td>
      <td>5ms一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>按键处理</td>
      <td>5ms一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>数码管扫描</td>
      <td>250us一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>蜂鸣器控制</td>
      <td>5ms一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>温度检测</td>
      <td>1s一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>温度控制</td>
      <td>1s一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>计时和时间控制</td>
      <td>1min一次</td>
    </tr>
  </tbody>
</table>

<p>  在这里请大家回顾一下，第三章里提到过这样一个问题：当500ms来临时，需要完成的任务有 按键扫描、1602刷新显示、电源管理，（温度采集暂且忽略），定时器中断周期只有200us，现在一下子来了这么多任务，一个中断周期内可以处理完吗？<br />
  当时采用的方法是把一些对时序要求不高的程序放到主进程里完成，而在这里我们还有另一种方法——把任务错开放在不同的定时器中断周期里。虽然这里面的每一个单独的任务都可以在一个定时器中断周期里完成，但是可能会有某个定时器周期里同时来了多个任务，这有可能会导致在一个定时器周期里不能处理完，所以一定要注意时间分配系统要把任务错开放在不同的定时器周期里。<br />
  比如按键扫描和蜂鸣器控制都是5ms执行一次，但是它们却不在同一次定时器中断内执行，因为定时器中断周期是250us，如果在一个中断时处理多个任务可能时间比较长，不能在250us内处理完，所以将它们错开分到不同的时间段内执行，但是周期仍然是5ms。</p>

<p>  时间分配代码如下：</p>

<p>```
void t0() interrupt 1 	//250us一次中断
{
    static unsigned char numto5ms=0;	//用于5ms计时
    static unsigned char numto1min=0;	//用于1min计时
    /<strong><em>数码管扫描任务</em></strong>/	//数码管扫描，每次中断都执行，这里省略数码管扫描代码</p>

<pre><code>numto5ms++;
if(numto5ms==5)	//5ms一次，温度检测
{
    /***温度检测任务***/
}
else if(numto5ms==10)	//5ms一次，蜂鸣器发生
{
    /***蜂鸣器发声任务***/
}
else if(numto5ms==15)	//5ms一次，按键扫描
{
    /***按键扫描任务***/
}
else if(numto5ms==20)	//5ms到了，进行分钟判断，此时numto5ms要清
{
    numto5ms=0;
    numto1min++;
    if(numto1min==12000)	//1min到了
    {
        numto1min=0;
        /***时间处理任务***/
    }
} } ```
</code></pre>

<p>  【任务执行函数】</p>

<p>  任务执行函数就是在定时器里调用的用于完成某种任务的函数。<br />
  这个函数的具体特点将在下节介绍，因为很重要。</p>

<h1 id="section-1">2. 定时器里面任务函数的特点</h1>

<p>  首先分析一下这种任务函数的特点和要求：</p>

<ul>
  <li>1、这些函数由定时器调用，所以对于它们的调用时间是很精确地每隔固定时间调用一次。</li>
  <li>2、由于这些函数是放在定时器里，所以<strong>这些函数必须简短，不能占用过长时间，必须可以在一个定时器中断周期内全部处理完。</strong></li>
  <li>3、与在主进程连续执行的任务函数相比，这种函数的调用是周期、间断的，这种周期间断性的调用，决定它自己<strong>必须具有记忆以前的状态的能力</strong>，只有这样才能在本次被调用时决定应该进行什么样的操作。<br />
在上一章“占用式与非占用式程序结构分析”中已经明确了非占用式程序结构的优势，并且也明确了其内部结构：<br />
<img src="/images/dan-pian-ji-bian-cheng/feizhanyongshichengxu.jpg" alt="非占用式程序的一般结构" title="非占用式程序的一般结构" /><br />
  有了上一章的基础就好理解这些在定时器里的任务函数了，实际上这些任务函数和在主进程连续执行的任务函数相比，就是把它们改为了非占用式程序放在定时器里执行。</li>
  <li>4、由于要保证每个任务都要在很短的时间内执行结束，所以就要求每个任务不能阻塞进程，不论这个任务当前处于什么情况，应当执行一次之后立马退出。<br />
这样，<strong>不论某个进程的执行情况如何，其他进程绝对都会继续执行，也就把各个进程独立开了，保证每个进程都会得到及时的执行。</strong></li>
  <li>5、各个进程相对独立，但各个进程间也有通信。比如按键扫描进程把按键码传递给其他进程；蜂鸣器进程通过变量接收外部下达的响铃指令。<br />
要注意一个特点：<strong>由于定时器里面的任务函数是被周期性的调用的，所以如果想使用某个进程的功能，必然不可能像以前那样通过调用函数来实现，因为它本身就一直在被调用着，必然是通过这个进程对外设置的接口变量来实现。</strong></li>
</ul>

<h1 id="section-2">3. 过程任务的定时器化</h1>

<p>  这里讨论如何把一个过程化的程序改成定时器化的程序。<br />
  没有找到通用的方法，可以确定的是定时器化的任务结构肯定就是像非占用式程序结构那样。<br />
  下面举几个定时器化的程序的例子。</p>

<ul>
  <li>数码管扫描</li>
</ul>

<p>```
void smgdisp()
{
	static unsigned char n;
	n++;
	if(n==8)
		n=0;</p>

<pre><code>smgndisp(n,?); } ```
</code></pre>

<p>  用静态变量n记忆点亮的数码管序号，这样轮换点亮完成扫描。<br />
  还想举一下上一章里面的扫描全彩点阵的程序：</p>

<p>```
void refresh7()
{
	static unsigned char r=0;
	static unsigned char flagrgb=0;	//当前需要点亮的颜色，0-R,1-G,2-B
	static unsigned char num=0;
	num++;
	if(num==32)
	{
		num=0;
		flagrgb++;
		if(flagrgb==3)	//说明三种颜色都扫描完了
		{
			flagrgb=0;	//从红色开始扫描
			r++;		//开始扫描下一行
			if(r==8)	//如果发现行都扫描结束则从第行开始扫描
				r=0;
		}
	}</p>

<pre><code>if(num&lt;light7)	//说明需要点亮
{
	switch(flagrgb)
	{
	case 0:	//扫描红色
		DPw = ~(0x01&lt;&lt;r);
		DPr = ~vm7r[r];//送入R灯IO接口显示
		break;
	case 1:	//扫描绿色	
		DPw = ~(0x01&lt;&lt;r);
		DPg = ~vm7g[r];
		break;
	case 2:	//扫描蓝色
		DPw = ~(0x01&lt;&lt;r);
		DPb = ~vm7b[r];
		break;
	}
}
else	//说明不需要点亮
{
	DPw=0xff;
	DPr=0xff;
	DPg=0xff;
	DPb=0xff;
} } ```
</code></pre>

<p>  也是通过静态变量记忆，完成某行某个颜色的亮度判断。</p>

<ul>
  <li>按键扫描</li>
</ul>

<p>  简单的一个按键扫描程序在上一章也例举过：</p>

<p><code>
static unsigned char keylast;	//保存上次的按键值
if(key==0 &amp;&amp; keylast==1)	//检测到一个下降沿
{
	/*do something*/
}
keylast=key;
</code></p>

<p>  下面例举一个增强型的按键扫描程序，它可以识别多个按键按下、释放：</p>

<p>```
void keyscan()	//5ms调用一次</p>

<p>{
	static unsigned int key;	//本次扫描结果
	static unsigned int keylast=0xffff;	//上次扫描结果
	unsigned char i,j;</p>

<pre><code>//开始扫描
for(i=0;i&lt;=3;i++)
{
	DPkey=~pow2[i];    //pow[]是一个数组，代表2^i
	for(j=4;j&lt;=7;j++)
	{
		if(DPkey&amp;pow2[j])	//是1
		{
			key|=pow2[4*i+7-j];
		}
		else	//是0
		{
			key&amp;=~pow2[4*i+7-j];
		}
	}
}
//开始判断上升沿和下降沿
if(key^keylast)	//说明按键状态有变化
{
	for(i=0;i&lt;=15;i++)
	{
		if((key&amp;pow2[i])==0 &amp;&amp; (keylast&amp;pow2[i]))	//下降沿，按键按下
		{
			/****在此添加i号按键按下时要做的事****/
		}
		else if((key&amp;pow2[i]) &amp;&amp; (keylast&amp;pow2[i])==0)	//上升沿，按键释放
		{
			/****在此添加i号按键释放时要做的事****/
		}
	}
}

keylast=key; } ```
</code></pre>

<p>  在这里我想说明的是，任何复杂的功能都可以写成这种“定时器化”的形式。<br />
  <em>如果希望更多的功能则需要添加其他结构，比如想要识别按键长按，则需要添加静态变量记忆按键状态并进行计时。</em><br />
  <strong>不管需要的功能如何，都是可以用这种结构实现的。</strong></p>

<ul>
  <li>蜂鸣器控制</li>
</ul>

<p>  这个相比较于上面两个比较特别，因为上面两个结构比较简单，目的明确，要干什么很清楚。而这个蜂鸣器控制任务平时不工作，当外部下达指令时才会发声。<br />
  所以想以此为例，再次说明<strong>任意功能都可以写成定时器内部任务的结构</strong>。虽然没有证明它，但看起来是这样的。<br />
  对于这个蜂鸣器控制进程来说，需要有一下几种功能：短响1声、短响2声、短响3声、长响1s。<br />
  这些功能在定时器任务里完成，通过一个变量通知这个进程执行哪种任务。<br />
  具体完成代码如下：</p>

<p>```
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**<em>以下是蜂鸣器任务相关</em></strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>
蜂鸣器的任务函数会由定时器5ms调用一次，由一个标志变量标志完成什么样的声音，使用时只要修改一下变量就行了。
总共有这么及几种声音：
	短响1声、短响2声、短响3声、长响1s
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><em>**</em>/
unsigned char music=0;	/<em>对外接口，外部想要发声直接修改这个变量就可以了。
			0-不响
			1-短响声
			2-短响声
			3-短响声
			4-长响1s		*/
void beep()	//发声任务，由定时器每5ms调用一次
{
	static unsigned char flagDoing=0;	/</em>标志当前是否正在执行某个任务，0-不在，1-在
						当检测到music变量不为时说明有任务，此时将此变量置，标志正在执行；
						具体执行哪个任务根据music变量指示；
						当任务执行完毕时清此变量，标志没有任务，是空闲状态，清零music变量，标志没有任务将要执行。	*/</p>

<pre><code>if(music==0)	//没有任务
{
	buzzer=1;	//关闭蜂鸣器，	buzzer是蜂鸣器控制引脚，0-响，1-不响
}
else	//说明有任务
{
	if(flagDoing==0)	//如果当前没有任务正在执行，则给当前任务赋值为想要执行的任务
		flagDoing=music;

	if(flagDoing==1)	//短响声
	{
		static unsigned char count=0;	//用来计时
		buzzer=0;	//打开蜂鸣器
		count++;
		if(count==20)	//任务结束判断条件
		{
			count=0;	//为下次任务做准备
			buzzer=1;	//关闭蜂鸣器
			flagDoing=0;
			music=0;
		}
	}
	else if(flagDoing==2)	//短响声
	{
		static unsigned char count=0;
		count++;
		if(count&lt;=20)
			buzzer=0;	//打开蜂鸣器
		else if(count&gt;20 &amp;&amp; count&lt;=30)
			buzzer=1;	//关闭
		else if(count&gt;30 &amp;&amp; count&lt;=50)
			buzzer=0;	//打开
		else	//执行结束
		{
			count=0;
			buzzer=1;
			flagDoing=0;
			music=0;
		}
	}
	else if(flagDoing==3)	//短响声
	{
		static unsigned char count=0;
		count++;
		if(count&lt;=20)
			buzzer=0;	//打开蜂鸣器
		else if(count&gt;20 &amp;&amp; count&lt;=30)
			buzzer=1;	//关闭
		else if(count&gt;30 &amp;&amp; count&lt;=50)
			buzzer=0;	//打开
		else if(count&gt;50 &amp;&amp; count&lt;=60)
			buzzer=1;	//关闭
		else if(count&gt;60 &amp;&amp; count&lt;=80)
			buzzer=0;
		else	//执行结束
		{
			count=0;
			buzzer=1;
			flagDoing=0;
			music=0;
		}
	}
	else if(flagDoing==4)	//长响s
	{
		static unsigned char count=0;
		buzzer=0;	//打开蜂鸣器
		count++;
		if(count==140)	//结束条件
		{
			count=0;
			buzzer=1;
			flagDoing=0;
			music=0;
		}
	}
} } ```
</code></pre>

<p>  用一个变量music来作为对外的API，通过它通知本进程执行哪个任务；<br />
  <strong>music和具体任务之间有一个中间变量flagDoing，这个变量是用来缓冲外部对此进程发送的指令的，只有当进程内部的某个任务执行结束后才会响应下一个任务请求；<br />
  本进程的各个分支是一个小任务，每个小任务中都各自有自己的静态变量，用于完成各自特定的功能；</strong><br />
  <em>在每个小任务执行结束后，都会做一些处理，让本进程准备好接收下一个任务。</em><br />
  总之，不管什么复杂的控制结构，都是可以写成这种被间断调用的“定时器化”的形式。</p>

<h1 id="section-3">4. 定时器执行任务程序结构总结</h1>

<p>  1、每个任务函数不会因外部状态不同而阻塞，<strong>不管外部状态如何，这个任务的本次执行都能够顺利通畅地执行完。</strong><br />
  2、每个任务函数执行时间都很短，有时间限制，都有自己的时间段。<strong>所以不管一个进程的状态如何，它绝对不会影响到其他进程的执行</strong>，整个系统不会因为一个进程而停下来，仍然随着定时器的节拍不断地运行。<br />
  3、在这种结构中，所有被执行的代码都是高效的，因为没有延时等函数。<br />
  4、可以用一个定时器完成多个精确的时间控制任务，事实上整个系统都在精确的时间控制下运行。</p>

<h1 id="section-4">5. 我们追求的是什么</h1>

<p>  从第3章开始，程序的主体逐渐从主进程转移到了定时器中断（从后台转移到前台），也对任务函数进行了一系列改造。</p>

<p>  首先，我想强调这些都是在大量编程时自然产生的，是整个系统越来越复杂的必然结果。</p>

<p>  另外，我们进行了这么多改变到底是在追求什么？我们渴望的系统结构是什么样的？</p>

<p>  在此我想引用《底层工作者手册之嵌入式操作系统内核》中的一段话，也算是为操作系统做个铺垫：<br />
  “在没有操作系统的情况下，C语言是以函数为单位实现功能的，一个函数一个函数串行地执行，一个完整的功能会由多个函数共同完成。然而当软件系统的功能变得多而庞大的时候，这种方法几乎无法使用，因为此时各个功能之间必然会有千丝万缕的联系，不可能依次串行地完成每个功能，各个功能必然需要交替执行。以函数为功能单元的程序很难在执行一个函数的时候转而去执行另外一个不相关的函数，即使是使用一些技巧实现了，也会使整个软件的结构变得混乱不堪，不利于软件的维护和扩展。函数的工作方式就决定了并不适合以它为功能单元运行复杂的程序，在这种情况下就要使用操作系统了。操作系统是对函数运行管理的系统，它可以在一个函数还没有运行完就转而去执行另一个函数，并且还可以恢复到原来的函数继续执行，这样就可以根据需要及时调整到需要运行的函数来满足各种要求。”</p>

<p>  这段话的大概意思是：<br />
  1、传统的过程式程序是以函数为单位执行的。<br />
  2、以函数为单位的程序，在一个函数的执行过程中不能立刻跳转到另一个函数，也就是说可能会耽误另一个函数的响应。<br />
  3、就算在一个函数中嵌入了另一个函数的代码使得另一个函数也能及时得到响应，那也会是整个程序结构混乱，不利于维护和扩展。<br />
  而相比之下，操作系统具有很大的好处：<br />
  1、操作系统中的编程是以功能为单位的。在实现一个任务时根本不需要考虑其他的任务函数，更不需要在一个任务里嵌入另一个任务的代码。<br />
  2、操作系统可以在一个函数没有运行完之前直接跳转到另一个地方运行，并且以后可以恢复到原来地方继续运行。这样就可以及时对重要的函数进行响应。</p>

<hr />

<p>  再来回头看看我们做的更改，我们把占用式程序改为了非占用式程序，实际上就是细化了各个任务，让每个任务函数的单次执行时间很短，也就可以及时地响应其他任务。对比第1章所说的主函数顺序调用的结构，如果把里面的函数全都换成非占用式结构，就能大幅缩短循环时间。当时有么一句话：“在最坏情况下的任务级响应时间取决于整个循环的执行时间”，为什么这里把这句话搬过来，你懂的。</p>

<p>  另外一点，在改为定时器执行任务后，保证了各个任务都有自己固定的时间段执行，每个任务都绝对不会阻塞进程、绝对不会影响到其他任务的运行。这一点和操作系统相比甚至更有优势，因为操作系统的高优先级任务是可以阻塞低优先级任务的，而定时器执行任务结构中的所有任务都一定会及时得到执行。只要能够把这个任务以“定时器化”的形式写入到定时器中断处理程序里，它就绝对不会因为意外而被阻塞（这也是对任务函数的要求之一）。</p>

<hr />

<p>  我们的追求和操作系统是一样的，我们希望各个任务功能独立实现，不要相互影响。同时各个任务都能够及时得到响应。操作系统采用将寄存器入栈的方式保存状态信息，而在定时器执行任务的结构中是用静态变量的方式保存任务信息。</p>

<p>  从第3章到这里介绍的都是定时器中断相关的结构，下一章将介绍一种以外部中断为核心的编程结构。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第4章 占用式与非占用式程序结构]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-4zhang-zhan-yong-shi-yu-fei-zhan-yong-shi-cheng-xu-jie-gou.html"/>
    <updated>2016-09-19T21:39:56+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-4zhang-zhan-yong-shi-yu-fei-zhan-yong-shi-cheng-xu-jie-gou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 什么是占用式程序</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 占用式程序的缺点</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3. 对占用式程序的改造</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4. 改造的本质</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">5. 非占用式程序结构的优势</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">6. 非占用式程序的一般结构</a></li>
</ul>

<h1 id="section">1. 什么是占用式程序</h1>
<p>  一个进程在一个时刻只能处理一个任务。</p>

<p>  每个任务是为了完成一个功能，如果这个功能的实现过程是一直占用进程处理资源的话，就称这个任务函数是占用式程序结构。</p>

<p>  最常见的占用式程序结构就是延时函数了，比如最常用的5ms延时函数</p>

<!-- more -->

<p><code>
void delay5(unsigned char n)
{
    unsigned int i;
    for(;n&gt;0;n--)
        for(i=4700;i&gt;0;i--);	//12MHz，1T
}
</code></p>

<p>  在完成5ms功能过程中是一直占用调用它的进程处理资源的，在此期间不能进行其他任务。<br />
  还有一个很常见的占用式程序——数码管扫描，不过在这里我不举数码管扫描的例子，而举更为复杂一点的8*8彩色点阵屏的扫描程序：</p>

<p><code>
void refresh7()
{
    unsigned char r;
    for(r=0;r&lt;8;r++)
    {
        //扫描红色
        DPw = ~(0x01&lt;&lt;r);    //导通指定的行
        DPr = ~vm7r[r];    //输出r行8个灯中红色led
        DELAY7 (light7);    //亮灯时间长度，时间越长亮度越高
        DPw=0xff;
        DPr=0xff;
        DPg=0xff;
        DPb=0xff;
        DELAY7 (32-light7);//灭灯时间长度
        //为了简洁，这里把绿色和蓝色的扫描程序省略，它们的结构和红色扫描是一样的 
    }
}
</code></p>

<p>  这个函数是7色模式下的屏幕扫描程序，调用一次此函数会把整个屏幕扫描一遍。<br />
  r代表行数，r循环8次代表屏幕的8个行；在每次循环里，先导通对应的行和需点亮的灯，然后延时light7个单位，再关闭所有显示，再延时32-light7个单位。</p>

<h1 id="section-1">2. 占用式程序的缺点</h1>

<p>  占用式程序最大的缺点就是执行时间太长，耽误对其他任务的响应。另外就是资源浪费，很多时间浪费在执行中的延时上。<br />
  当然，可以在这些占用式程序中嵌入其他代码以及时处理其他任务，但是这样会造成程序结构混乱，嵌入的其他代码还会影响本程序的执行。如果嵌入的代码功能简单还好，如果功能复杂，尤其是当嵌入的代码也是占用式的，就会严重影响程序执行速度。</p>

<h1 id="section-2">3. 对占用式程序的改造</h1>

<p>  在此还以上面的扫描程序为例，对其进行改造。<br />
  首先，每次调用就扫描8行，耗时太长，现将其改成每次扫描一行：</p>

<p>```
void refresh7()
{
    static unsigned char r=0;
    //扫描红色
    DPw = ~(0x01«r);	//修改完了再导通指定行
    DPr = ~vm7r[r];//送入R灯IO接口显示
    DELAY7 (light7);//显示时间长度
    DPw=0xff;
    DPr=0xff;
    DPg=0xff;
    DPb=0xff;
    DELAY7 (32-light7);//灭灯时间长度
    //为了简洁，这里把绿色和蓝色的扫描程序省略，它们的结构和红色扫描是一样的</p>

<pre><code>r++;
if(r==8)
    r=0;    } } ```
</code></pre>

<p>  用一个静态变量r来记忆行数，这样每次调用此函数只需扫描一行，执行速度是原来的8倍，可以比较快地响应其他任务了。<br />
  但是这样还不够，每次扫描都会扫描三种颜色，时间还是有点长，下面再次改造，改为每次只扫描一种颜色：</p>

<p>```
void refresh7()
{
	static unsigned char r=0;
	static unsigned char flagrgb=0;	//当前需要点亮的颜色，0-R,1-G,2-B
	flagrgb++;
	if(flagrgb==3)	//说明三种颜色都扫描完了
	{
		flagrgb=0;	//从红色开始扫描
		r++;		//开始扫描下一行
		if(r==8)	//如果发现行都扫描结束则从第行开始扫描
			r=0;
	}</p>

<pre><code>switch(flagrgb)
{
case 0:	//扫描红色
	DPw = ~(0x01&lt;&lt;r);	//修改完了再导通指定行
	DPr = ~vm7r[r];//送入R灯IO接口显示
	DELAY7 (light7);//显示时间长度
	DPw=0xff;
	DPr=0xff;
	DPg=0xff;
	DPb=0xff;
	DELAY7 (32-light7);//灭灯时间长度
	break;
case 1:	//扫描绿色	
	/*省略代码*/
	break;
case 2:	//扫描蓝色
	/*省略代码*/
	break;
} } ```
</code></pre>

<p>  改造完成之后，执行时间再次缩短，变成了刚才的1/3。<br />
  这下还没完，我们发现每次扫描中都有延时，延时过程中什么也不做，这是极大的浪费，我们需要再此改造，把延时去掉：</p>

<p>```
void refresh7()
{
	static unsigned char r=0;
	static unsigned char flagrgb=0;	//当前需要点亮的颜色，0-R,1-G,2-B
	static unsigned char num=0;
	num++;
	if(num==32)
	{
		num=0;
		flagrgb++;
		if(flagrgb==3)	//说明三种颜色都扫描完了
		{
			flagrgb=0;	//从红色开始扫描
			r++;		//开始扫描下一行
			if(r==8)	//如果发现行都扫描结束则从第行开始扫描
				r=0;
		}
	}</p>

<pre><code>if(num&lt;light7)	//说明需要点亮
{
	switch(flagrgb)
	{
	case 0:	//扫描红色
		DPw = ~(0x01&lt;&lt;r);
		DPr = ~vm7r[r];//送入R灯IO接口显示
		break;
	case 1:	//扫描绿色	
		DPw = ~(0x01&lt;&lt;r);
		DPg = ~vm7g[r];
		break;
	case 2:	//扫描蓝色
		DPw = ~(0x01&lt;&lt;r);
		DPb = ~vm7b[r];
		break;
	}
}
else	//说明不需要点亮
{
	DPw=0xff;
	DPr=0xff;
	DPg=0xff;
	DPb=0xff;
} } ```
</code></pre>

<p>  现在，这个函数中没有任何延时和循环，执行所消耗的时间是非常少的，可以很快地响应响应其他任务。</p>

<h1 id="section-3">4. 改造的本质</h1>

<p>  上面我们对这个项目的扫描程序进行了“三大改造”，分别是：1、各个行扫描的分离；2、各个颜色扫描的分离；3、延时函数的消除。<br />
  这些改造的本质都是对原程序的分割，把一大坨程序分成多个步骤分别执行，以减小耗时，提高对外部的响应速度。<br />
  还记得在第一章说的主函数顺序调用吗？最后说过这样一句话：“在最坏情况下的任务级响应时间取决于整个循环的执行时间”，而通过这样的改造之后，其实就是在缩短这个循环的时间。<br />
  <strong>但就整个进程的执行来看，有效代码的比例是降低的</strong>，包括上面“三大改造”的第三点 延时函数的消除，看上去是消除了延时函数，提高了执行效率，但从“扫描一次整屏”这个任务来看，其执行的代码量反而是增加的。（但并不是所有的改造都一定会使效率降低，有些改造确实可以达到“消除延时函数”的目的）<br />
  那为什么还要对其进行改造呢，见下节分析。</p>

<h1 id="section-4">5. 非占用式程序结构的优势</h1>

<p>  1、非占用式程序相比于占用式程序，增加了一定的代码，虽然会使整体效率降低，但是提高了各个任务之间的切换速度，可以对各个任务都能很快地响应。这点类似于操作系统，虽然降低了效率，但是各个任务间的快速切换可以达到各个任务“并行处理”的效果，光是这点的好处就已经很大了。</p>

<p>  2、非占用式程序结构可以放进定时器<br />
  第3章已经发现用定时器分配任务的好处，有些简短的代码可以直接放进定时器里。<br />
  在改造之前的扫描程序是不适合放在定时器中断处理程序里执行的，因为太长，可能还没执行完就来了下一个中断。就算勉强执行完了，留给主进程处理其他事情的时间也不多了。<br />
  而改为非占用式之后，可以在中断处理程序里直接调用扫描程序，它会很快地执行完，然后有充足的时间留给其他任务。</p>

<p>  3、非占用式程序并不是一定会降低效率。<br />
  就拿“三大改造”的第三点说明，它虽然形式上消除了延时函数，但是每次调用此函数时对num变量的处理，以及有其产生的相关判断语句，总的代码量比原来的要多。<br />
  但是，这真的就仅仅是这样了吗？改造之前的函数，执行完退出之后所有的led全是熄灭的，只有在此函数执行过程中（延时阶段）才会点亮（传统数码管扫描亦是如此）。<br />
  而改造之后的函数，它的功能就是指定一下每个灯的亮灭，然后立马退出，在执行其他任务的过程中该点亮的灯是在点亮的状态。这样就提高了整体的亮度，在执行其他任务的过程中，从某种意义上说也是在执行当前任务。</p>

<p>  这可能还不能太清楚地说明问题，下面再举一例，传统的按键扫描一般是这样：
<code>
if(key==0)	//key是某个引脚
{
    delay5(1);
    if(key==0)	//确认按键已按下
    {
        /*do something*/
    }
}
</code></p>

<p>  这段代码也是很浪费时间的，中间有个5ms延时白白浪费。<br />
  通过对它改造之后，结合定时器，可以几乎完全地把这5ms时间省出来，把如下代码放进定时器中断处理程序：</p>

<p><code>
static unsigned char keylast;	//保存上次的按键值
if(key==0 &amp;&amp; keylast==1)	//检测到一个下降沿
{
    /*do something*/
}
keylast=key;
</code></p>

<p>  这段代码每5ms执行一次，而执行的时间是非常短的，剩下有大量的时间可留给其他任务。<br />
  <strong>结合定时器进行改造，是真的可以把占用式函数的延时时间节省出来的。</strong></p>

<h1 id="section-5">6. 非占用式程序的一般结构</h1>
<p>  非占用式程序将占用式程序分割执行，需要用到静态变量对当前步骤进行记忆，其一般结构如下：</p>

<p><img src="/images/dan-pian-ji-bian-cheng/feizhanyongshichengxu.jpg" alt="非占用式程序的一般结构" title="非占用式程序的一般结构" /></p>

<p>  逻辑变量计算就是根据任务功能构建出一个合理的逻辑结构。<br />
  对逻辑变量的响应就是对构建好的逻辑结构的结果的响应和执行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第3章 定时器分配任务]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-3zhang-ding-shi-qi-fen-pei-ren-wu.html"/>
    <updated>2016-09-19T21:08:13+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-3zhang-ding-shi-qi-fen-pei-ren-wu</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 用界面函数构成的基础框架</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 结合定时器编程分析</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3. 任务分割</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4. 定时器分配任务程序结构总结</a></li>
</ul>

<p>  在前两章的内容里都没有考虑中断，本章将引入定时器。引入定时器的原因一些功能需要计时，最常见的就是电子钟了。</p>

<!-- more -->

<p><img src="/images/dan-pian-ji-bian-cheng/dianzizhong.jpeg" alt="电子钟" /></p>

<p>  这是博主2012年的作品，本章将以这个电子钟为背景介绍用定时器分配任务的程序结构，源代码也会在<a href="http://download.csdn.net/detail/nicekwell/6668033" title="从单片机编程到操作系统产生》的附件">附件</a>中给出。</p>

<h1 id="section">1. 用界面函数构成的基础框架</h1>

<p>  这个电子钟的大体硬件租成有：按键、1602显示屏、18b20温度传感器、电源管理模块（两个AD转换和一路PWM输出），由于没用时钟芯片，采用的是8位自动填装定时器每隔200us一次中断来计时的（很准哦）。<br />
  任务处理方面，除计时和日期计算以外，要处理的任务还有：1602显示、按键扫描、温度采集和电源管理（控制电池充放电）。<br />
  需要显示界面有时间显示界面、时间设置界面、电源管理界面和logo界面。每个界面完成不同的功能，时间显示界面就是上图所示的样子，时间设置界面用来完成时间的设置，电源管理界面用来查看当前电池状态以及设置一些充放电参数，logo界面显示3秒后自动跳转到时间显示界面。<br />
  这些界面是如何完成的呢？没错！它就是在主进程里用界面函数完成的。每个界面函数先初始化本界面显示，然后在实现本界面具体功能：</p>

<p>```
void Page1()
{
	/<em>显示初始化</em>/
	/<em>其他初始化</em>/</p>

<pre><code>while(1)
{
	/*本界面任务*/

	if(FlagPage!=1)
		return;
} } ```
</code></pre>

<p>  具体而言，例举logo界面的代码如下（因为logo界面代码最短）：</p>

<p>```
void logopage()	//logo界面，定时器还在工作，只是停留在logo界面s中后返回
{
	/<em>下面是显示初始化</em>/
	unsigned char i;
	code char logo0[]=”hello world!    “;
	code char logo1[]=”    hello nicek!”;
	wcom(0x80);
	for(i=0;logo0[i]!=’\0’;i++)
		wdat(logo0[i]);
	wcom(0x80+0x40);
	for(i=0;logo1[i]!=’\0’;i++)
		wdat(logo1[i]);</p>

<pre><code>timenum=15000;	//准备延时3s，这个变量会在定时器里每200us减1
while(timenum)	//等待延时结束，等待过程中仍然对一些按键进行相应
{
	switch(keynum)
	{
	case 5:	//按下返回键
		flagpage=0;	//返回后跳转到界面0
		return;	//返回
	case 6:	//按下灯光键
		led=0;	//点亮背光灯
		timenumlight=5;	//点亮5s，时间到了之后会在定时器中自动关闭灯光
		keynum=7;	//按键响应结束，标志没有按键按下
		break;
	}
}
flagpage=0;	//返回后跳转到界面0 } ```
</code></pre>

<p>  有了这些界面函数，也就构成了整个系统的基本框架，但是到目前为止还是没有用到定时器。下面就以“时间显示”界面为例，分析在这个界面中如何结合定时器完成相应功能。</p>

<h1 id="section-1">2. 结合定时器编程分析</h1>

<p>  先来讨论一下在时间显示界面里需要做的这么几个任务：<br />
  1602需要500ms刷新一次。小时和分钟之间有一个冒号“:”需要500ms闪动一次，因为不显示秒，所以当分钟发生变化时整屏也要刷新一次；<br />
  按键扫描5ms扫描一次。如果放在时间界面的主循环里进行按键扫描的话就不用考虑这么多，但是那样做有很多缺点，我这里是把按键扫描当做一个固定的进程，放在定时器中断处理函数里，其他所有界面都能用利用这个扫描结果；<br />
  电源管理500ms检测一次；<br />
  温度采集500ms一次，但比较复杂，涉及到所谓“任务分割”问题，由于比较复杂，会后面单独讨论。</p>

<p>  很自然地想到利用定时器计时来进行，那么定时器会以什么样的工作方式来调配整个系统呢？</p>

<p>  首先，定时器200us一次中断，需要有一个变量累加，当累加到5ms时，进行一次按键扫描；<br />
  然后继续累加，每累加到一个5ms都要进行一次按键扫描……当累加到500ms时进行一次按键扫描、1602刷新显示、电源管理，（温度采集暂且忽略）。</p>

<p>  那么，我们可以直接把这些代码写入中断处理程序吗？比如按键扫描我可以把这段代码写入中断处理程序吗：</p>

<p><code>
for(i=0;i&lt;=6;i++)	//总共7个独立按键
{
	if(P1&amp;pow2[i]==0)	//pow2[i]就是2的i次方
	{
		delay5(1);	//延时5ms，以确认是否真的按下
		if(P1&amp;pow2[i]==0)
		{
			keynum=i;
			break;
		}
	}
}
</code></p>

<p>  这是显然是不行的，执行完这段代码中的延时函数就有5ms了，而定时器是200us一次中断，一个中断周期里根本执行不完。<br />
  如果把这段代码放到时间界面主循环里是可以的，但是这样的话在其他界面就不能使用（除非也加入相同的代码），正如我上面所说：那样有很多缺点，我这里是把按键扫描当做一个固定的进程，其他所有任务都能用利用这个扫描结果。</p>

<p>  所以这里要提出一个定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间。</strong></p>

<p>  所以我们要想想办法，把按键扫描程序改成了如下，以下代码由中断处理函数调用，每5ms执行一次：</p>

<p><code>
static unsigned char reslast;	//保存上次扫描结果，0-没按下，1-按下
unsigned char res;
unsigned char i;
numforkey=0;
res=P1;
for(i=0;i&lt;=6;i++)
{
	if(((res&amp;pow2[i])==0)&amp;&amp;((reslast&amp;pow2[i])!=0))	//这次按下，上次断开
		break;
}
//从这里出来，如果i==7则表示没有按键按下，i&lt;=6的任意一个值表示那个键被按下了
keynum=i;
reslast=res;
</code></p>

<p>  这段代码里面没有延时，执行一次是很快的，而且也可以很好地完成按键扫描，比上面的那种延时扫描更有优势（不占用资源，而且稍加改造可以识别同时按下多个按键）。</p>

<p>  所以，把原则一加上一句，定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间，要想办法把任务改成不占用定时器时间的结构，给主进程让出更多的时间。</strong>关于把“任务改成不占用定时器时间”这个问题会在后面第4章“占用式与非占用式程序结构分析”里详细讨论。</p>

<hr />

<p>  按键扫描在中断处理程序里已经安置妥当了，但请注意当500ms来临时，需要完成的任务有 按键扫描、1602刷新显示、电源管理，（温度采集暂且忽略），定时器中断周期只有200us，现在一下子来了这么多任务，一个中断周期内可以处理完吗？</p>

<p>  为了避免这种风险，我们把定时器中断里的一些任务转移到主进程中（还有另一种方法将在后面“定时器执行任务”的章节中介绍），这就是定时器分配任务的程序结构原则二：<strong>当节拍时间到来时，要处理的任务真的很多，可以通过标志变量通知主进程执行。</strong> <em>但通知让主进程做的事对实时性要求不能太高。</em></p>

<p>  实际上我在电子钟里面把1602刷新就没有放在定时器中断里，而是放到了主进程。在程序里设置了一个flag500ms标志变量，定时器中断处理函数标记变量为1表示到了500ms，时间界面的主循环检测这个变量，当发现这个变量为1时就执行1602刷新。而按键扫描和电源管理由于在任何界面都会用到，并且代码执行速度快，所以把它们放在定时器中断里进行，1602刷新对实时性要求不高，所以可以用定时器通知主进程执行。</p>

<hr />

<p>  下面要说的就是温度采集了，上面为什么没讨论它，就是因为它比较复杂。它既不能满足原则一（在一个定时器中断时间内完成）也不能满足原则二（对实时性要求不高）。</p>

<p>  温度传感器用的是18b20，由单总线协议决定了对它进行一次读写大约需要18ms，而且对实时性要求也很高。</p>

<p>  这里隆重推出一个自己起名的概念——“任务分割”。顺便引出定时器分配任务的程序结构原则三：<strong>当既不满足原则一又不满足原则二，即既不能在一个定时器中断时间里完成又对实时性要求很高的任务，对它进行任务分割。</strong></p>

<p>  下一节将详细介绍任务分割的概念，以及如何对任务进行“分割”。</p>

<h1 id="section-2">3. 任务分割</h1>

<p>  所谓任务分割就是把不能在一个定时器中断时间里完成的任务分割成多个可以在一个定时器中断时间里完成的任务。在这里，把分割完成之后的任务函数仍然放在主进程里。<br />
  要完成任务分割，首先需要让定时器的计时功能可以被外部使用，设一个全局变量TimeNum，然后在定时器中断处理程序里让TimeNum自减：</p>

<p>```
unsigned char TimeNum=0;
void t0_int() interrupt 1
{
	/<em>Do Something</em>/</p>

<pre><code>if(TimeNum!=0)
	TimeNum--; } ```
</code></pre>

<p>  这样，外部就可以通过TimeNum变量使用定时器的计时资源了。在主进程里只要这么做就行：</p>

<p><code>
/*Do Something*/
TimeNum=100;	//准备等待个定时器中断周期
while(TimeNum)	//等待
{
	/*Do Something*/
}
/*继续 Do Something*/
</code></p>

<p>  可以利用定时器延时之后就可以对主进程里的长任务进行分割了，分割方法就是把原来顺序执行的任务函数，找到合适的节点，在节点处进行合适时间的延时。<br />
  这个步骤做起来是比较麻烦的，因为要进行任务分割的任务一般对时间精确性要求是比较高的（否则直接放到主进程就可以了），需要充分了解运行过程。<strong>既要保证每个节点之间的运行时间小于一个定时器中断周期，又要保证任务时序的正确性。</strong></p>

<p>  需要强调一下，任务分割这个方法是个下策，实在没办法的情况下才进行这种处理，我也只在这个电子钟工程的温度测量用过。<br />
  这种情况在操作系统中也是不好处理的，当某个不能被中断的函数的运行时间确实长于时钟节拍周期的话，也只有先关闭中断，等该函数运行结束后再打开中断。操作系统中把这种函数叫做“临界段”代码。而在电子钟这个例子中，由于要进行精确的计时，是不可以关闭中断的，只有进行任务分割（当然也有其他的处理方式，加个协处理器什么的）。</p>

<p>  下面截取18b20的一段代码，举例说明一下修改的原理。<br />
  修改前代码：</p>

<p><code>
bit ds18b20_init()
{
	bit dat=0;
	dq=1;
	delayusx2(5);
	dq=0;
	delayusx2(200);
	delayusx2(200);
	dq=1;
	delayusx2(50);
	dat=dq;
	delayusx2(25);
	return dat;
}
</code></p>

<p>  修改后代码：</p>

<p><code>
bit ds18b20_init()
{
	bit dat=0;
	dq=1;
	delayusx2(5);    //较短的延时不需要修改，可以在一个中断周期内完成
	dq=0;
	timenum=4;while(timenum);  //这里原来的800ms延时换成了结合定时器的等待
	dq=1;
	delayusx2(50);    //延时时间短，不需要分割
	dat=dq;
	delayusx2(25);    //上次分割到这里大约100us，本次延时时间50us，仍然不需要分割
	//到这里实际上init部分的协议已经完成，下面仍然加了一个分割是为了和定时器同步，在这里等待一次定时器中断，保证等待之后有充足的时间执行后续代码
	timenum=1;while(timenum);
	return dat;
}
</code></p>

<h1 id="section-3">4. 定时器分配任务程序结构总结</h1>

<p>  1、整个系统有一个主进程：main函数的主循环及其调用的所用任务函数，以及所有任务函数调用的子任务函数。<br />
  这个主进程的特点是所有函数都在一个函数调用链里，运行时精力只能放在一处；优先级低，任何中断所调用的任务都会使其停止工作。</p>

<p>  2、定时器也可开辟一道进程，所有由定时器直接调用的任务都属于这个进程。<br />
  定时器进程可以通过一些标志变量通知主进程进行某种动作，最常用的控制方法是用定时器产生节拍信号，通知主进程进行相应动作;<br />
  同时，定时器也可以直接调用一些函数，在定时器中断处理程序里完成任务。所有由定时器直接调用的程序都属于定时器进程，优先级高于主进程；<br />
  用定时器分配任务有一下三点原则：<br />
  定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间，要想办法把任务改成不占用定时器时间的结构，给主进程让出更多的时间。</strong><br />
  定时器分配任务的程序结构原则二：<strong>当节拍时间到来时，要处理的任务真的很多，可以通过标志变量通知主进程执行。</strong> <em>但通知让主进程做的事对实时性要求不能太高。</em><br />
  定时器分配任务的程序结构原则三：<strong>当既不满足原则一又不满足原则二，即既不能在一个定时器中断时间里完成又对实时性要求很高的任务，对它进行任务分割。</strong></p>

<p>  3、整个系统来看有两个并行的进程——主进程和定时器进程。主进程一次只能执行一个任务，而定时器进程由于任务一般比较小（如按键扫描、计时、数码管扫描等），所以认为定时器进程的任务也一并完成了。<br />
  看上去就像是多个进程在同时运行，这些进程之间可以通过公共变量进行通信，比如节拍时间的标识变量、计时产生的时间、按键扫描结果变量keynum等，所有其他进程可以有选择地对这些标识变量进行响应。类似于进程间通信。</p>

<hr />

<p>  用定时器命令主函数执行任务的原因有两点：1、利用定时器的时钟节拍使主函数也可以节拍性地执行任务。2、利用主函数构建的逻辑结构。<br />
  对于第1点，该任务的实时性确实会受影响，因为毕竟主函数是用查询方式查询标识变量的。<br />
  但是第2点带来的好处也是非常大的。还拿电子钟举例来说吧，电子钟里面的各个界面之间的逻辑是通过主函数构建出来的，定时器在任何界面都会中断，并且在定时器中执行的任务会通过标识变量向主函数发送信息（比如当前时间、按键扫描结果(我的按键扫描是放在定时器里执行的)等），虽然在各个界面向主函数发送的信息是一样的，但是主函数中的各个界面对这些信息的反应却是不同的（比如各个界面对同一按键的反应是不同的，对定时器提供的时间所做的的反应也是不同的）。
  这些都依赖于主函数所构建出的逻辑结构。</p>

<hr />

<p>  关于这种结构的介绍暂且到此吧，下面将引出一个新的问题。<br />
  注意在3.2节的分析中，有些任务是直接放在定时器里执行的，这些任务都有一些共同的特点——执行时间短。<br />
  执行时间短带来了什么？在1.2节有这么一句话：“任务执行的并行与否是相对而言的。”，在本节的总结中还有这句话：“定时器进程由于任务一般比较小（如按键扫描、计时、数码管扫描等），所以认为定时器进程的任务也一并完成了。”<br />
  定时器的中断处理函数的执行肯定不会被主进程阻挡，这里面的任务全都可以看成是并行的多个进程，它们各自完成不同的功能，把自己的运行结果作为资源供其他进程使用。<br />
  在第5章中将详细分析这种结构，在那一章，我们将会明确我们到底在追求什么，我们要追求的结构到底是什么样的？</p>

<p>  不过在此之前，先要补充一点理论知识，这就是下一章的内容。<br />
  下一章将会分析和明确那些“完成某个任务的函数”到底应该做些什么，哪些东西是有用的。并对这些函数进行改造，分析改造成不同形式的函数有什么样的特点。</p>

]]></content>
  </entry>
  
</feed>
