<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[生命不息 折腾不止]]></title>
  <link href="http://nicekwell.net/atom.xml" rel="self"/>
  <link href="http://nicekwell.net/"/>
  <updated>2017-11-24T13:31:45+08:00</updated>
  <id>http://nicekwell.net/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-树莓派的i2c配置]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shu-mei-pai-de-i2cpei-zhi.html"/>
    <updated>2017-11-23T20:35:11+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shu-mei-pai-de-i2cpei-zhi</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#i2c" id="markdown-toc-i2c">1、开启树莓派i2c设备</a></li>
  <li><a href="#i2c-1" id="markdown-toc-i2c-1">2、确认i2c模块加载成功</a></li>
  <li><a href="#i2c-detecti2c" id="markdown-toc-i2c-detecti2c">3、i2c detect检测i2c设备</a></li>
  <li><a href="#i2c-2" id="markdown-toc-i2c-2">4、i2c的波特率</a></li>
</ul>
<p>  </p>

<p>介绍如何在树莓派上配置i2c，包括开关、波特率，以及i2cdetect的简单使用。</p>

<!-- more -->

<h3 id="i2c">1、开启树莓派i2c设备</h3>
<p>树莓派的i2c默认是关闭的。网上找了很多打开i2c的方法，基本上都是：<br />
1、修改 /etc/modules，添加i2c模块开机自动启动。<br />
2、修改 /etc/modprobe.d/raspi-blacklist.conf 黑名单中去掉i2c模块。<br />
但是怎么改都不行，可能是树莓派系统升级了，和以前的设置方法不一样了。<br />
正确的方法是：<br />
1、sudo raspi-config<br />
2、Advanced Options –&gt; I2C –&gt; 开启i2c设备 –&gt; 重启。<br />
加载成功的话会生成 <strong>/dev/i2c-x</strong> 文件，x是总线序号。</p>

<h3 id="i2c-1">2、确认i2c模块加载成功</h3>
<p><strong>lsmod</strong><br />
会看到 i2c_dev 和 i2c_bcm2708 两项。</p>

<h3 id="i2c-detecti2c">3、i2c detect检测i2c设备</h3>
<p>linux下有个i2c工具程序可以方便地检测i2c设备。<br />
1、 安装 i2c-tools<br />
<strong>sudo apt-get install i2c-tools</strong><br />
2、列出所有i2c总线<br />
<strong>i2cdetect -l</strong><br />
如果i2c设备成功打开，将会看到<br />
i2c-1   i2c   3f804000.i2c    I2C adapter<br />
3、列出i2c总线上的所有i2c设备<br />
<strong>i2cdetect -y &lt;总线&gt;</strong><br />
列出总线上所有地址上的设备，形如：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
</span><span class="line">00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- -- 
</span><span class="line">40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span></code></pre></td></tr></table></div></figure>

<p><strong>这个功能会启动i2c检测电路，电路上实际连接了哪些设备这里就会显示哪些设备。电路上不连接设备的话在这里是不会显示的。</strong><br />
<strong>检测到的是7位的i2c地址。</strong></p>

<p>i2ctools的其他使用在linux里的工具使用中有专门介绍。</p>

<h3 id="i2c-2">4、i2c的波特率</h3>
<p>获取当前波特率：<br />
<strong>sudo cat /sys/module/i2c_bcm2708/parameters/baudrate</strong><br />
设置波特率：<br />
<strong>sudo emacs /etc/modprobe.d/custom.conf</strong><br />
添加一行设置：<br />
<strong>options i2c_bcm2708 baudrate=100000</strong><br />
设置后需要重启才能生效。</p>

<p> </p>

<p>实际测量clk引脚的结果：</p>

<table>
  <tbody>
    <tr>
      <td>设置的频率</td>
      <td>示波器测量的脉宽</td>
      <td>周期</td>
      <td>示波器测量的频率</td>
      <td>传输addr+cmd+20字节所需要的时间</td>
      <td> </td>
    </tr>
    <tr>
      <td>32000(32k)</td>
      <td>25us</td>
      <td>50us</td>
      <td>20kHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>100000(100k)</td>
      <td>8us</td>
      <td>16us</td>
      <td>41.67kHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>1000000(1M)</td>
      <td>800ns</td>
      <td>1600ns</td>
      <td>417KHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>2000000(2M)</td>
      <td>400ns</td>
      <td>800ns</td>
      <td>833.4kHz</td>
      <td> </td>
      <td>波形略有失真，可能和外部电路设计也有关系。</td>
    </tr>
    <tr>
      <td>3000000(3M)</td>
      <td>250ns</td>
      <td>500ns</td>
      <td>1.894MHz</td>
      <td> </td>
      <td>波形已经失真严重，设备接收异常。</td>
    </tr>
  </tbody>
</table>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-UART串口]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-uartchuan-kou.html"/>
    <updated>2017-11-23T20:05:37+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-uartchuan-kou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">0、包含头文件</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">1、打开串口</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">2、写入（发送）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">3、读取（接收）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">4、缓冲区操作</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">5、关闭串口</a></li>
</ul>
<p>  </p>

<p>前面介绍了python操作串口的方法，是通过通用的串口库实现的。<br />
用c语言当然也可以通过通用串口接口实现，而wiringPi也提供了自己的一套串口操作函数，可以很方便地操作串口。<br />
事实上，wiringPi就是在上层利用通用串口操作接口，封装了一套自己的库函数。</p>

<!-- more -->

<h3 id="section">概述</h3>

<p>在前面python串口编程处就介绍了，树莓派3B的板载串口被蓝牙占用，但可以方便地使用USB串口模块。</p>

<p>树莓派的板载串口是给系统登录使用的，我们要先把这个功能关掉。<br />
<strong>sudo raspi-config</strong><br />
Advanced Options –&gt; Serial –&gt; 关闭串口 –&gt; 重启</p>

<p>树莓派上有两个串口，一个硬件串口，工作稳定，但是分配给了蓝牙；还有一个“mini-uart”，这个串口的时钟是由内核提供，所以不太稳定 。 在树莓派3B上，蓝牙和硬件串口是不能兼得。<br />
这个链接(http://ukonline2000.com/?p=880)有介绍如何把硬件串口分配到GPIO14、GPIO15上，这里不做介绍了。</p>

<p>总之，在树莓派3B上，想要使用板载硬件串口是比较麻烦的，我们这里使用的是USB转串口模块，也能很方便地使用串口。</p>

<h3 id="section-1">0、包含头文件</h3>

<p><strong>#include &lt;wiringSerial.h&gt;</strong></p>

<h3 id="section-2">1、打开串口</h3>

<p><strong>&lt;fd&gt; = serialOpen(char* device, int buad);</strong><br />
【功能】<br />
打开串口文件，并设置波特率，返回文件编号。<br />
【输入】</p>

<table>
  <tbody>
    <tr>
      <td>*device</td>
      <td>设备路径的字符串。比如 “/dev/ttyUSB0”</td>
    </tr>
    <tr>
      <td>buad</td>
      <td>波特率，是一个数值。可以设置为：2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</td>
    </tr>
  </tbody>
</table>

<p>【输出】一个文件编号，代表这个串口设备文件，后面对这个串口的操作都会用到。<br />
【说明】<br />
1、wiringPi提供的设置（以及后面的读写功能）是简化的文件操作，可以满足大部分需求。<br />
2、这里的<file编号>是标准的linux文件描述符，可以使用linux标准的文件操作函数write()、read()等来操作。</file编号></p>

<p>后面也会有说明，wiringPi提供的读写功能是简化的，不提供二进制数值读写，但是可以使用linux标准的读写函数来操作。</p>

<h3 id="section-3">2、写入（发送）</h3>

<p><strong>void serialPutchar(int fd, unsigned char c) ;</strong><br />
【功能】发送一个字节数据。<br />
【输入】<br />
fd是打开串口时的文件描述符。<br />
输入的就是一个字节数据，可以用字符表示，也可以用十六进制数表示。</p>

<p><strong>void serialPuts(int fd, char *s) ;</strong><br />
【功能】发送字符串。<br />
【输入】<br />
fd是打开串口时的文件描述符。<br />
*s 是一个字符串，会发送该字符串，直到’\0’结束。<strong>‘\0’不会发送出去。</strong></p>

<p><strong>void serialPrintf(int fd, char *message, …) ;</strong><br />
【功能】功能类似于printf，可以同时发送多个字符串。</p>

<p> </p>

<p>注意：<strong>以上两个发送函数只是把数据推送到发送缓冲区里，不会等待串口发送完成。</strong>后续程序如果要用到用到串口返回数据应当要考虑到串口传输时间。<br />
<strong>并且最好等之前的数据全部发送完成后再发送新数据，否则可能会出问题，这也要考虑到串口发送数据的时间，可能需要等待。</strong><br />
关键是上层还没有找到判断串口发送完成的方法。</p>

<h3 id="section-4">3、读取（接收）</h3>

<p><strong>int serialDataAvail(int fd) ;</strong><br />
【功能】获取接收缓冲区里的字节数。<br />
【输入】创建串口设备文件时的文件描述符。<br />
【输出】接收缓冲区里所存放的数据字节数。</p>

<p><strong>int serialGetchar(int fd) ;</strong><br />
【功能】从接收缓冲区里读取一个字节数据。<br />
【输入】创建串口设备文件时的文件描述符。<br />
【输出】读取到的一个字节内容。虽然是一个字节内容，但仍然定义为了int型。<br />
【说明】<br />
<strong>如果缓冲区里没有数据，则会等待10s，相当于python里把timeout设置为10s。<br />
10s过后如果还没有数据的话，则会返回 -1，十六进制显示为 0xffffffff。</strong>
这里的10s是wiringPi默认的，查看源代码可以看到：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-23-shu-mei-pai-wiringpi-uartchuan-kou/1.png" alt="1.png" /></p>

<h3 id="section-5">4、缓冲区操作</h3>
<p><strong>void serialFlush(int fd) ;</strong><br />
清空缓冲区，放弃所有数据。</p>

<h3 id="section-6">5、关闭串口</h3>
<p><strong>void serialClose(int fd) ;</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-优先级&amp;中断&amp;线程]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng.html"/>
    <updated>2017-11-23T19:48:00+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi库真是包含了各个方面，甚至提供了进程操作接口。<br />
使用wiringPi的接口可以很方便地创建新进程。</p>

<!-- more -->

<p> </p>

<p><strong>int piHiPri (int priority) ;</strong><br />
设置进程优先级。范围是0~99，数字越大优先级越高，默认是0。<br />
返回0代表成功，返回-1代表失败。<br />
注：必须已root身份运行，否则无效。</p>

<p> </p>

<p><strong>int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;</strong><br />
设置某个pin作为中断脚，当触发中断时调用指定函数。<br />
估计实现原理是后台用了一个定时器不断扫描这个引脚。<br />
pin是引脚序号，编号方式在Setup时决定。<br />
edgeType是中断触发方式：</p>

<table>
  <tbody>
    <tr>
      <td>INT_EDGE_FALLING</td>
      <td>下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_RISING</td>
      <td>上升沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_BOTH</td>
      <td>上升沿和下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_SETUP</td>
      <td>未设置</td>
    </tr>
  </tbody>
</table>

<p>中断处理函数传入函数指针即可。</p>

<p> </p>

<p><strong>int piThreadCreate (PI_THREAD func) ;</strong><br />
创建一个线程执行func函数。要求func函数用PI_THREAD声明。<br />
返回0代表创建成功，非0代表失败。<br />
例：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">PI_THREAD</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span>    <span class="c1">//注意这种声明方式，函数名用括号括起来，不带参数</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line">	<span class="n">piThreadCreate</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p> </p>

<p><strong>piLock (int keyNum) ;</strong><br />
<strong>piUnlock (int keyNum) ;</strong><br />
获取锁和释放锁。wiringPi-C提供了4个锁，keyNum范围是0~3。<br />
默认所有所都是释放状态，当调用piLock()想要获取锁时，如果这个锁没有被释放则会一直等待，直到这个锁被释放才会拿到这个锁并继续运行下去。<br />
这里的锁可以理解为某个资源，使用该资源时调用piLock()标志该资源正在被使用，使用结束后调用piUnlock()表示释放该资源。其他地方想要使用该资源也必须先获取这个锁，如果没有获取到则等待使用者释放资源后再使用。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-时间函数]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu.html"/>
    <updated>2017-11-23T19:27:41+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi不仅提供硬件操作的接口，同时也提供了一些时间管理函数。</p>

<!-- more -->

<p> </p>

<p><strong>void delay (unsigned int howLong)</strong><br />
延时ms，最大传入32位无符号型整数，大约49天。<br />
实际上是睡眠，不占用cpu。<br />
由于linux是多任务的，所以实际延时时间可能会更长。</p>

<p> </p>

<p><strong>void delayMicroseconds (unsigned int howLong)</strong><br />
延时微秒，最大传入32位无符号型整数，大约71分钟。</p>

<p>wiringPi的库文件中有这样一个函数：</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">delayMicrosecondsHard</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">howLong</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tNow</span><span class="p">,</span> <span class="n">tLong</span><span class="p">,</span> <span class="n">tEnd</span> <span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="n">gettimeofday</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tNow</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">;</span>
</span><span class="line">  <span class="n">tLong</span><span class="p">.</span><span class="n">tv_sec</span>  <span class="o">=</span> <span class="n">howLong</span> <span class="o">/</span> <span class="mi">1000000</span> <span class="p">;</span>
</span><span class="line">  <span class="n">tLong</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">howLong</span> <span class="o">%</span> <span class="mi">1000000</span> <span class="p">;</span>
</span><span class="line">  <span class="n">timeradd</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tNow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tLong</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tEnd</span><span class="p">)</span> <span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="k">while</span> <span class="p">(</span><span class="n">timercmp</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tNow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tEnd</span><span class="p">,</span> <span class="o">&lt;</span><span class="p">))</span>
</span><span class="line">    <span class="n">gettimeofday</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tNow</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>其实 delayMicroseconds 函数会判断传入时间如果小于100us就使用 delayMicrosecondsHard 占用式延时，否则会调用 nanosleep 函数。<br />
如果我们想要精确延时，是可以使用 delayMicrosecondsHard 函数的，这个函数在.h文件里没有声明，但已经编译完成，只要用 void delayMicrosecondsHard (unsigned int howLong); 把此函数声明一下就可以使用了。</p>

<p> </p>

<p><strong>unsigned int millis (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是ms。</p>

<p> </p>

<p><strong>unsigned int micros (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是us。<br />
<strong>测试发现这个函数获取时间速度是很快地，此函数执行时间大约1us，也就是说连续执行两次此函数时间相差大约1us。</strong>在用树莓派处理对时间比较敏感的任务时可能会在意这些时间。</p>

<p>树莓派中经常需要精确地周期性执行某个动作，可以用如下方式精确定时，类似于单片机里的定时器：</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define INTERVAL 20000 </span><span class="c1">//间隔时间，单位是us</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="n">tim</span><span class="p">;</span>
</span><span class="line">    <span class="cm">/* do something */</span>
</span><span class="line">    <span class="n">tim</span> <span class="o">=</span> <span class="n">micros</span><span class="p">();</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="k">if</span><span class="p">(</span><span class="n">micros</span><span class="p">()</span> <span class="o">-</span> <span class="n">tim</span> <span class="o">&gt;=</span> <span class="n">INTERVAL</span><span class="p">)</span>
</span><span class="line">      <span class="p">{</span>
</span><span class="line">            <span class="n">tim</span> <span class="o">+=</span> <span class="n">INTERVAL</span><span class="p">;</span>
</span><span class="line">            <span class="cm">/* do something */</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-GPIO]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio.html"/>
    <updated>2017-11-22T20:07:42+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p>GPIO接口在官网有详细的说明：<a href="http://wiringpi.com/reference/core-functions/">http://wiringpi.com/reference/core-functions/</a></p>

<p>wiringPi的GPIO序号如下：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/1.jpg" alt="1.jpg" /></p>

<p> </p>

<p><strong>void pinMode (int pin, int mode) ;</strong><br />
设置GPIO模式。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
mode可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>INPUT</td>
    </tr>
    <tr>
      <td>OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>GPIO_CLOCK</td>
    </tr>
    <tr>
      <td>SOFT_PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>SOFT_TONE_OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_TONE_OUTPUT</td>
    </tr>
  </tbody>
</table>

<p>只有具有相应功能的引脚才能设置为该功能。</p>

<p> </p>

<p><strong>void pullUpDnControl (int pin, int pud) ;</strong><br />
设置上下拉。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
pud是上下拉配置，可设置为：</p>

<table>
  <tbody>
    <tr>
      <td>PUD_OFF</td>
      <td>无上下拉</td>
    </tr>
    <tr>
      <td>PUD_UP</td>
      <td>上拉，3.3v，50kΩ</td>
    </tr>
    <tr>
      <td>PUD_DOWN</td>
      <td>下拉，50kΩ</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p><strong>void digitalWrite (int pin, int value) ;</strong><br />
设置指定引脚的输出。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
value是输出值，可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>HIGH 或 非0</td>
      <td>高电平（3.3v）</td>
    </tr>
    <tr>
      <td>LOW 或 0</td>
      <td>低电平</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>void digitalWriteByte (int value) ;</p>

<p> </p>

<p><strong>int digitalRead (int pin) ;</strong><br />
读取指定引脚。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
返回的是该引脚的电平，返回HIGH或LOW。</p>

<p> </p>

<p><strong>void pwmWrite (int pin, int value) ;</strong><br />
设置pwn输出占空比。<br />
pin是引脚序号，以何种方式编号在前面决定。（最新的树莓派里面好像把pwm功能去掉了）<br />
value是占空比，范围是0~1023。<br />
？？？在哪设置pwm的周期呢？</p>

<p> </p>

<p><strong>analogRead (int pin) ;</strong><br />
读入模拟量（AD）。<br />
<strong>analogWrite (int pin, int value) ;</strong><br />
输出模拟量（DA）。<br />
<em>以上两个功能需要外加芯片</em>，这里略去。</p>

<p> </p>

<p><strong>wiringPi-C控制GPIO的速度</strong><br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/2.png" alt="2.png" /><br />
高低电平变化响应速度大约是80ns。（raspberry-gpio-python的速度大约是2us，大约是它的25倍）<br />
注意，wiringPi-C也是在上层的程序，输出的波形同样是不稳定的。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPI-设置引脚编号模式]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi.html"/>
    <updated>2017-11-22T19:52:38+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi</id>
    <content type="html"><![CDATA[<p>  </p>

<p>前面说过树莓派在不同的库下对引脚的编号方式是不同的，wiringPi支持设置各种不同的引脚编号方式。</p>

<!-- more -->

<p>安装好wiringPi之后，不仅在系统中添加了头文件和库，同时也安装了命令行工具。<br />
在shell中可以用 <strong>gpio readall</strong> 命令获取到以下信息：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi/1.png" alt="1.png" /></p>

<p>wiringPi提供三种引脚排序方式：wPi、BCM、Phy。<br />
必须在程序开始时指明使用哪种排序方式。</p>

<ol>
  <li>wiringPi排序方式<br />
<strong>int wiringPiSetup (void) ;</strong><br />
调用此函数即可设置为wiringPi排序。</li>
  <li>BCM排序方式<br />
<strong>int wiringPiSetupGpio (void) ;</strong><br />
调用此函数即可。</li>
  <li>物理排序方式（和 raspberry-gpio-python 的排序相同）<br />
<strong>int wiringPiSetupPhys (void) ;</strong><br />
按照引脚顺序排序，没有GPIO的引脚是无法控制的。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-编译&amp;头文件&amp;lib]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-bian-yi-and-tou-wen-jian-and-lib.html"/>
    <updated>2017-11-22T19:40:06+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-bian-yi-and-tou-wen-jian-and-lib</id>
    <content type="html"><![CDATA[<p>  </p>

<p>安装好之后想要使用wiringPi的接口，就必须要包含wiringPi的头文件、链接wiringPi库，本文介绍如何正确编译。</p>

<!-- more -->

<p>安装好之后，会生成以下头文件：</p>

<table>
  <tbody>
    <tr>
      <td>/usr/local/include/wiringPi.h</td>
      <td>提供基础的服务，包括GPIO。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiI2C.h</td>
      <td>提供I2C相关支持。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiSPI.h</td>
      <td>提供SPI相关支持。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiShift.h</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>生成以下库：</p>

<table>
  <tbody>
    <tr>
      <td>/usr/local/lib/libwiringPiDev.so</td>
    </tr>
    <tr>
      <td>等</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>在编写C程序时：</p>

<ol>
  <li>要 include 头文件，直接用&lt;&gt;即可，不需要指明路径。<br />
如：#include <wiringPi.h>  
编译器会自动从/usr/local/include/目录下寻找头文件。</wiringPi.h></li>
  <li>编译时要连接wiringPi的库。<br />
如：gcc gpio.c -o gpio -<strong>lwiringPi</strong><br />
编译器会自动从/usr/local/lib/目录下寻找库。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-说明和安装]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang.html"/>
    <updated>2017-11-22T19:16:22+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">说明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">原理</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">安装</a></li>
</ul>
<p>  </p>

<p>wiringPi是树莓派上层提供gpio、串口、i2c等硬件操作的一套库，经过其封装后的接口函数使用起来非常方便。<br />
wiringpi已经不局限于C语言了，也提供了其他各种语言的接口，甚至提供了命令行工具，直接在命令行操作GPIO。<br />
我们这里介绍的是wiringPi的C接口。</p>

<!-- more -->

<h3 id="section">说明</h3>

<p>wiringPi是树莓派上层提供gpio、串口、i2c等硬件操作的一套库，经过其封装后的接口函数使用起来非常方便。<br />
wiringpi已经不局限于C语言了，也提供了其他各种语言的接口，甚至提供了命令行工具，直接在命令行操作GPIO。<br />
我们这里介绍的是wiringPi的C接口。</p>

<p>官方首页：<a href="http://wiringpi.com/">http://wiringpi.com/</a><br />
wiringPi-c的github主页：<a href="https://github.com/WiringPi/WiringPi">https://github.com/WiringPi/WiringPi</a><br />
官方说明文档：<a href="http://wiringpi.com/reference/">http://wiringpi.com/reference/</a></p>

<h3 id="section-1">原理</h3>

<p>通过wiringPi 的源码可以看出，<strong>wiringPi是一个在现有的上层接口基础上封装的一层库函数</strong>。上层不通过wiringPi也可以直接通过linux标准接口完成功能，wiringPi封装的好处是使用比较方便（但也裁剪了很多功能）。<br />
如：<br />
  GPIO库，实际上是通过操作GPIO节点实现：<br />
  <img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang/1.png" alt="1.png" /></p>

<p>  serial库，实际上也是通过标准的open、write等函数实现：<br />
  <img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang/2.png" alt="2.png" /></p>

<h3 id="section-2">安装</h3>

<p>1、用git把代码拖下来<br />
<strong>git clone git://git.drogon.net/wiringPi</strong><br />
也可以从github拖下来：<br />
<strong>git clone git@github.com:WiringPi/WiringPi.git</strong></p>

<p>对比发现作者在这两个地方都进行维护，代码内容完全一样。</p>

<p> </p>

<p>2、安装
进入目录，直接<br />
<strong>./build</strong><br />
不需要sudo权限。</p>

<p>安装过后，就可以使用命令行和C接口了。具体怎么使用见后面内容。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-UART串口]]></title>
    <link href="http://nicekwell.net/blog/20171120/shu-mei-pai-pypi-uartchuan-kou.html"/>
    <updated>2017-11-20T19:37:15+08:00</updated>
    <id>http://nicekwell.net/blog/20171120/shu-mei-pai-pypi-uartchuan-kou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#pythonpyserial" id="markdown-toc-pythonpyserial">python通用串口库——pyserial</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">一、安装</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">二、使用</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">1、打开串口并创建对象</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">2、缓冲区操作</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">3、波特率设置</a></li>
          <li><a href="#section-6" id="markdown-toc-section-6">4、从串口发送数据</a></li>
          <li><a href="#section-7" id="markdown-toc-section-7">5、从串口接收数据</a></li>
          <li><a href="#section-8" id="markdown-toc-section-8">6、关闭串口</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>树莓派在linux上层支持通用的串口接口，用linux上通用的串口编程即可操作。<br />
树莓派3B的板载串口被蓝牙占用，但可以方便地使用USB串口模块。</p>

<!-- more -->

<h2 id="section">概述</h2>

<p>树莓派的板载串口是给系统登录使用的，我们要先把这个功能关掉。<br />
<strong>sudo raspi-config</strong><br />
Advanced Options –&gt; Serial –&gt; 关闭串口 –&gt; 重启</p>

<p>树莓派上有两个串口，一个硬件串口，工作稳定，但是分配给了蓝牙；还有一个“mini-uart”，这个串口的时钟是由内核提供，所以不太稳定  。
在树莓派3B上，蓝牙和硬件串口是不能兼得的。<br />
这个链接(<a href="http://ukonline2000.com/?p=880">http://ukonline2000.com/?p=880</a>)有介绍如何把硬件串口分配到GPIO14、GPIO15上，这里不做介绍了。</p>

<p>总之，在树莓派3B上，想要使用板载硬件串口是比较麻烦的，我们这里使用的是USB转串口模块，也能很方便地使用串口。</p>

<p>pypi库没有提供串口操作函数，我们使用串口的思路是通过linux上层通用的串口接口。</p>

<h2 id="pythonpyserial">python通用串口库——pyserial</h2>

<p>这里介绍的是第三方库 pyserial 的安装和使用。<br />
ubuntu、mac和树莓派上，只要安装了python都可以用此方法操作串口。</p>

<p>官网：<a href="http://pyserial.sourceforge.net/">http://pyserial.sourceforge.net/</a><br />
github主页：<a href="https://github.com/pyserial/pyserial">https://github.com/pyserial/pyserial</a></p>

<h3 id="section-1">一、安装</h3>

<p>网上有很多pip安装的方法，但那些好像都是针对python2的，python3安装不了，正确方法如下：<br />
<strong>mac下也可以用这种方法安装，但mac需要先安装驱动，我用的是PL2303，从官网下载的驱动，安装完成后的节点是 /dev/tty.usbserial。</strong></p>

<p>1、从github clone代码<br />
<strong>git clone git@github.com:pyserial/pyserial.git</strong></p>

<p>2、进入安装目录安装<br />
<strong>sudo python3 setup.py install</strong><br />
（在mac下安装不用sudo权限也行）</p>

<p>3、python3中import模块<br />
<strong>import serial</strong><br />
如果没有安装成功的话 import 会报错。</p>

<h3 id="section-2">二、使用</h3>

<p>首先要 <strong>import serial</strong></p>

<h4 id="section-3">1、打开串口并创建对象</h4>

<p><strong>[串口对象] = serial.Serial(‘[串口设备文件]’,<br />
              baudrate=[波特率],<br />
              bytesize=[数据位],<br />
              parity=’[校验]’,<br />
              stopbits=[停止位],<br />
              timeout=[timeout])</strong></p>

<ul>
  <li>串口设备文件就是/dev/目录下的设备文件，传入的是一个字符串，比如 ‘/dev/ttyUSB0’。</li>
  <li>budrate是波特率，<strong>传入的是数值</strong>。可以选择：<br />
2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</li>
  <li>bytesize是数据位，<strong>传入的是数值</strong>。<br />
可以省略，默认是8。</li>
  <li>parity是校验，传入的是字符串。可以设置为：<br />
<strong>‘N’    不校验<br />
‘O’    奇校验（ODD）<br />
‘E’    偶校验（EVEN）</strong><br />
可以省略，默认是’N’。</li>
  <li>stopbits是停止位个数，<strong>传入的是数值</strong>，一般都是设成1。<br />
可以生录入，默认是1。</li>
  <li>timeout是超时等待，在接收数据时，如果接收到的字符不满足返回条件则会等待，超时后返回。</li>
</ul>

<p>  例1，指明所有参数：<br />
  <em>ser = serial.Serial(‘/dev/ttyUSB1’,<br />
           baudrate=9600,<br />
           bytesize=8,<br />
           parity=’N’,<br />
           stopbits=1,<br />
           timeout=3)</em><br />
  例2，只指定某些参数：<br />
  <em>ser = serial.Serial(‘/dev/ttyUSB1’, 9600, timeout=3)</em></p>

<h4 id="section-4">2、缓冲区操作</h4>

<p>  python对串口接收数据和单片机有所不同。<br />
  单片机接收到数据后会产生中断，然后在中断中处理数据。<br />
  <strong>python是不会产生串口中断的，接收到的数据会存放在缓冲区，然后python程序主动检查缓冲区读取数据。</strong>读取数据方法也有多种。<br />
  <strong>每次新打开一个串口，之前的缓冲区就会被清空。</strong><br />
  缓冲区有输入缓冲区和输出缓冲区。<br />
  缓冲区的大小是：</p>

<p>  <strong>[串口对象].flushInput()</strong><br />
  清除接收缓冲区，放弃接收到的所有内容。<br />
  <strong>[串口对象].flushOutput()</strong><br />
  清除发送缓冲区，放弃输出。</p>

<p>  <strong>[串口对象].inWaiting()</strong><br />
  【功能】获取缓冲区里的字节数。<br />
  【输出】返回一个数值，代表缓冲区里有多少数据。</p>

<h4 id="section-5">3、波特率设置</h4>

<p>  <strong>[串口对象].setBaudrate([波特率])</strong><br />
  设置已经打开的串口的波特率，传入的是数值，可以选择：<br />
  2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</p>

<h4 id="section-6">4、从串口发送数据</h4>

<p>  <strong>[串口对象].write([单字节数组])</strong><br />
  <strong>发送的数据必须是单字节数据</strong>，可以是单字节组成的list，也可以是单字节编码的字符串（如ASCII、UTF-8）。
  返回的是写入的字节数。<br />
  例1，发送16进制数据：<br />
  <em>list1 = [0x01,0x02,0x03,0x10]<br />
  ser.write(list1)</em><br />
  会把这几个16进制数依次通过串口发出，另一端会接收到一模一样的数据。<br />
  例2，发送单字节编码的字符串：<br />
  <em>ser.write(b’abcdefg’)</em><br />
  把字符串’abcdefg’的ascii码发出，另一端收到：0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67。</p>

<h4 id="section-7">5、从串口接收数据</h4>

<p>  <strong>[串口对象].read([长度])</strong><br />
  【功能】从缓冲区读取指定长度内容。<br />
  【输入】<br />
  [长度] 是一个数值，代表要从缓冲区读取的字节数。<br />
  这个参数可以省略，默认是1。<br />
  【输出】输出的是一连串单字节数据。<br />
  【说明】<strong>如果缓冲区内容小于读取的长度则会等待，直到timeout后读取仅有的全部内容返回。</strong></p>

<p>  <strong>[串口对象].readall()</strong><br />
  【功能】读取缓冲区的所有数据。<br />
  【输出】输出的是一连串单字节数据。<br />
  <strong>这个函数必然会等待一个timeout时间，把之前缓冲区里所有内容和等待阶段接收到的所有内容读出。</strong></p>

<p>  <strong>[串口对象].readline()</strong><br />
  【功能】从缓冲区里读取一行。<br />
  【输出】输出的是一连串单字节数据。<br />
  【说明】<br />
  读取时会找到第一个’\n’结束，如果缓冲区里的数据没有’\n’，则会等待，知道timeout后返回仅有的所有内容。</p>

<h4 id="section-8">6、关闭串口</h4>

<p>  <strong>[串口对象].close()</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-GPIO]]></title>
    <link href="http://nicekwell.net/blog/20171119/shu-mei-pai-pypi-gpio.html"/>
    <updated>2017-11-19T22:44:47+08:00</updated>
    <id>http://nicekwell.net/blog/20171119/shu-mei-pai-pypi-gpio</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1、导入模块</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2、设置引脚排列方式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3、设置某个引脚的输入输出</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4、输入</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">5、输出</a></li>
  <li><a href="#pythongpio" id="markdown-toc-pythongpio">python控制GPIO的速度</a></li>
</ul>
<p>  </p>

<!-- more -->

<h3 id="section">1、导入模块</h3>

<p><strong>import RPi.GPIO as GPIO</strong></p>

<h3 id="section-1">2、设置引脚排列方式</h3>

<p>1、主板编号方式<br />
<strong>GPIO.setmode(GPIO.BOARD)</strong><br />
就是按照主板的引脚顺序：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/1.png" alt="1.png" /><br />
注意有些引脚是没有GPIO功能的，这些引脚仍然为它们分配了序号，但控制时使用这些非GPIO的序号是会报错的。</p>

<p>2、BCM编号方式<br />
<strong>GPIO.setmode(GPIO.BCM)</strong><br />
按照BCM方式编号。<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/2.jpg" alt="2.jpg" /></p>

<h3 id="section-2">3、设置某个引脚的输入输出</h3>

<p><strong>GPIO.setup([gpio], GPIO.[dir])</strong><br />
[GPIO]是一个引脚的序号，按照上面的编号方式决定。<br />
GPIO.[dir]是方向，可以设置：</p>

<table>
  <tbody>
    <tr>
      <td><strong>GPIO.IN</strong></td>
      <td>输入</td>
    </tr>
    <tr>
      <td><strong>GPIO.OUT</strong></td>
      <td>输出</td>
    </tr>
  </tbody>
</table>

<p>同时设置多个通道：<br />
<strong>chan_list = [[gpio1], [gpio2], …]</strong><br />
<strong>GPIO.setup(chan_list, GPIO_[dir]]</strong></p>

<h3 id="section-3">4、输入</h3>

<p><strong>GPIO.input([gpio])</strong><br />
获取指定通道的电平，返回的是一个数值，0或1。</p>

<h3 id="section-4">5、输出</h3>

<p>单通道输出：<br />
<strong>GPIO.output([gpio], GPIO.[level])</strong><br />
[gpio]是一个引脚的序号，按照上面的编号方式决定。<br />
GPIO.[level]是引脚的电平：</p>

<table>
  <tbody>
    <tr>
      <td><strong>GPIO.LOW</strong></td>
      <td>低电平</td>
    </tr>
    <tr>
      <td><strong>GPIO.HIGH</strong></td>
      <td>高电平（3.3v）</td>
    </tr>
  </tbody>
</table>

<p>同时设置多通道输出：<br />
<strong>chan_list = [[gpio1], [gpio2], …]</strong><br />
<strong>GPIO.output(chan_list, (GPIO.HIGH, GPIO.LOW, …))</strong><br />
第一个参数是list，第二个参数是tuple。</p>

<h3 id="pythongpio">python控制GPIO的速度</h3>

<p>设置python控制一个GPIO循环输出高低电平（不加延时），波形如下：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/3.png" alt="3.png" /></p>

<p>高低电平切换响应速度大约2us。<br />
但是注意，<strong>由于python是在上层运行的，所以波形输出不太稳定</strong>，上面是最理想的状态，实际上程序会受到影响，波形输出不稳定。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-说明和安装]]></title>
    <link href="http://nicekwell.net/blog/20171116/shu-mei-pai-pypi-shuo-ming-he-an-zhuang.html"/>
    <updated>2017-11-16T15:44:09+08:00</updated>
    <id>http://nicekwell.net/blog/20171116/shu-mei-pai-pypi-shuo-ming-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">安装</a></li>
</ul>
<p>  </p>

<p>这个库完整的名字是raspberry-gpio-python，通过这个库可以方便地用python操作树莓派的GPIO，但没有提供SPI、i2c等操作接口。</p>

<!-- more -->

<h3 id="section">安装</h3>

<ul>
  <li>
    <p>1、安装python3<br />
<strong>sudo apt-get install python-dev python3-dev</strong></p>
  </li>
  <li>
    <p>2、下载pypi库:<br />
官方下载：<a href="https://pypi.python.org/pypi/RPi.GPIO">https://pypi.python.org/pypi/RPi.GPIO</a></p>
  </li>
  <li>
    <p>3、放到树莓派里，解压<br />
<strong>tar zxvf RPi.GPIO-0.6.2.tar.gz</strong></p>
  </li>
  <li>
    <p>4、进入解压后的目录，执行安装<br />
<strong>sudo python3 setup.py install</strong><br />
可参考解压后目录中的INSTALL.txt文档说明。</p>
  </li>
</ul>

<p>安装成功后就可以使用 RPi.GPIO模块了。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-硬件和功能-功耗]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-gong-hao.html"/>
    <updated>2017-11-15T20:37:34+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-gong-hao</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p>3代B型：</p>

<table>
  <tbody>
    <tr>
      <td>几乎0%使用</td>
      <td>270mA</td>
    </tr>
    <tr>
      <td>单核100%</td>
      <td>320mA，每隔几秒跳一次400mA</td>
    </tr>
    <tr>
      <td>双核100%</td>
      <td>360mA，每隔几秒跳一次510mA</td>
    </tr>
    <tr>
      <td>三个100%</td>
      <td>410mA，每隔几秒跳一次630mA</td>
    </tr>
    <tr>
      <td>四核100%</td>
      <td>460mA，每隔几秒跳一次760mA</td>
    </tr>
  </tbody>
</table>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-硬件和功能-硬件和功能]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng.html"/>
    <updated>2017-11-15T20:25:20+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p><strong>树莓派引脚电平是3.3V。</strong></p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/1.png" alt="1.png" /></p>

<p>关于引脚的编号，不同的库会有不同的编号：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/2.jpg" alt="2.jpg" /></p>

<p>老的树莓派1代引脚如下：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/3.png" alt="3.png" /></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-概述和使用-配置和使用]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong.html"/>
    <updated>2017-11-15T19:52:47+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#ssh" id="markdown-toc-ssh">打开ssh</a></li>
  <li><a href="#section" id="markdown-toc-section">树莓派配置命令</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">默认用户</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">修改主机名</a></li>
  <li><a href="#sd" id="markdown-toc-sd">扩展sd卡空间</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">更新源</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">设置时区</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">支持中文</a></li>
</ul>
<p>  </p>

<p>本文介绍树莓派的常用设置，经常是一些开机后必须设置的项目。</p>

<!-- more -->

<h3 id="ssh">打开ssh</h3>

<p>第一次开机网络都没配置，这一步肯定要连接显示器才能配置的。</p>

<p>从2016.11.25开始，树莓派默认关闭ssh，导致不能远程登陆，需要手动开启ssh功能，方法是在 /boot/ 分区下建立一个名为“ssh的空文件。<br />
方法1：在树莓派上直接打开ssh：<strong>sudo touch /boot/ssh</strong><br />
方法2：在电脑上打开ssh：插入sd卡后有个boot分区，在里面创建一个名为“ssh”的文件<br />
树莓派重启后会删掉此文件，但已经可以使用ssh登陆了。</p>

<h3 id="section">树莓派配置命令</h3>

<p>打开命令行，用 <strong>sudo raspi-config</strong> 命令可开启树莓派配置程序。</p>

<h3 id="section-1">默认用户</h3>

<p>pi@raspberrypi，密码 raspberry。</p>

<h3 id="section-2">修改主机名</h3>

<p>多个树莓派分不清，可以修改主机名称区分。<br />
sudo raspi-config –&gt; 9 Advanced Options –&gt; A2 Hostname<br />
2017年stretch新版设置路径是：<br />
sudo raspi-config –&gt;2 Hostname</p>

<h3 id="sd">扩展sd卡空间</h3>
<p>2017年stretch已经不需要此步骤了，老的版本需要执行以下操作后才能使用全部sd卡空间。</p>

<p>安装好系统后默认的系统空间很小，几乎仅能放下系统，而sd卡有很多空间没有用到：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/1.png" alt="1.png" /><br />
使用 raspi-config 的“Expand Filesystem”功能可以把sd卡的全部空间用起：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/2.png" alt="2.png" /><br />
此修改需要重启树莓派，重启之后：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/3.png" alt="3.png" /></p>

<h3 id="section-3">更新源</h3>

<p>使用不同的 raspbian 版本，对应的更新源是不一样的，可以从网上查找。<br />
stretch版本的源：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi  
</span><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span></code></pre></td></tr></table></div></figure>

<p>修改方法和ubuntu、debian相同：<br />
1、修改 /etc/source.list 文件<br />
2、sudo apt-get update</p>

<h3 id="section-4">设置时区</h3>

<p>网上找到的linux下通用设置方法 tzselect 设置无效，最后用 raspi-config 设置完成：<br />
sudo raspi-config –&gt; 5 Internationalisation … –&gt; I2 Change Timezone –&gt; Asia –&gt; ShangHai –&gt; OK<br />
2017年stretch版本设置路径：<br />
sudo raspi-config –&gt; 4 Localisation Options –&gt; I2 Change Timezone –&gt; Asia –&gt; ShangHai –&gt; OK</p>

<h3 id="section-5">支持中文</h3>

<p>2017年stretch版本已经不需要设置了。</p>

<p>默认的命令行不支持中文，git log查看提交记录都不能显示中文。修改方法：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">pi@raspberrypi:~$ sudo apt-get install ttf-wqy-zenhei  #安装字体
</span><span class="line">pi@raspberrypi:~$ sudo fc-cache       #刷新字库缓存
</span><span class="line">pi@raspberrypi:~$ sudo dpkg-reconfigure locales        #字体配置</span></code></pre></td></tr></table></div></figure>
<p>然后用上下方向键选中以下5项：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">en-GB.UTF-8 UTF-8
</span><span class="line">zh_CN.GB2312
</span><span class="line">zh.CN.GB18030 GB18030
</span><span class="line">zh_CN.GBK GBK
</span><span class="line">zh_CN.UTF-8 UTF-8</span></code></pre></td></tr></table></div></figure>
<p>选中后回车，会让你选择默认的字体，<br />
  如果想要系统语言是中文，则选择“zh_CN.UTF-8 UTF-8 ”回车<br />
  如果想要系统语言是英文，则选择“en_GB.UTF-8”回车。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-概述和使用-下载和安装]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang.html"/>
    <updated>2017-11-15T19:22:54+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">下载镜像</a></li>
  <li><a href="#mac" id="markdown-toc-mac">mac下安装</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">启动树莓派</a></li>
</ul>
<p>  </p>

<p>本文介绍如何下载树莓派镜像，并安装到sd卡，实现开机。</p>

<!-- more -->

<h3 id="section">下载镜像</h3>

<p>官网：<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a><br />
下载页面：<a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br />
推荐下载raspbian：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/1.png" alt="1.png" /></p>

<p>这是基于debian jessie的系统，有Full desktop版本和Minimal版本：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/2.png" alt="2.png" /><br />
full desktop版本有图形界面；Minimal版本没有图形界面，是精简版。<br />
由于后面要配置网络等配置项，用图形界面会方便很多，推荐使用不带LITE的desktop版。</p>

<h3 id="mac">mac下安装</h3>

<ul>
  <li>
    <p><strong>1、不插入sd卡查看当前磁盘情况</strong>
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/3.png" alt="3.png" /></p>
  </li>
  <li>
    <p><strong>2、插入sd卡查看当前磁盘情况</strong>
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/4.png" alt="4.png" /><br />
多出来的 /dev/disk2s1 就是sd卡的分区。</p>
  </li>
  <li>
    <p><strong>3、卸载这个分区</strong><br />
<strong>diskutil unmount /dev/[disk*s*]</strong><br />
卸载是为了待会写入这个分区时不会被其他程序的读写干扰。<br />
卸载之后可以通过  diskutil list 命令查看设备：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/5.png" alt="5.png" /><br />
可以看到我们的sd卡对应的设备是 /dev/disk2。</p>
  </li>
  <li>
    <p><strong>4、使用dd命令写入镜像</strong><br />
<strong>sudo dd bs=4m if=[镜像].img of=/dev/<code>[磁盘的字符设备]</code></strong><br />
注意，磁盘的字符设备是 r 开头的，网上有个说法：/dev/disk2s1是分区，/dev/disk2是块设备，/dev/rdisk2是原始字符设备。<br />
由于文件很大，写入过程会比较长。成功之后会显示如下界面：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/6.png" alt="6.png" /></p>
  </li>
  <li>
    <p><strong>5、卸载sd卡设备</strong><br />
<strong>diskutil unmountDisk /dev/[disk*]</strong><br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/7.png" alt="7.png" /></p>
  </li>
</ul>

<p>ubuntu下安装步骤和mac下类似，由于没有实际操作过，这里不介绍ubuntu下的安装。</p>

<h3 id="section-1">启动树莓派</h3>

<p>安装好之后把sd卡插在树莓派上，接通电源即可启动。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[把已有的repo工程提交到服务器]]></title>
    <link href="http://nicekwell.net/blog/20171112/ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi.html"/>
    <updated>2017-11-12T23:19:32+08:00</updated>
    <id>http://nicekwell.net/blog/20171112/ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、基础知识</a>    <ul>
      <li><a href="#git" id="markdown-toc-git">1、git</a></li>
      <li><a href="#repo" id="markdown-toc-repo">2、repo</a></li>
      <li><a href="#manifestxml" id="markdown-toc-manifestxml">3、manifest.xml文件</a></li>
    </ul>
  </li>
  <li><a href="#repo-1" id="markdown-toc-repo-1">二、把已有的repo工程提交到自己的服务器</a>    <ul>
      <li><a href="#python3" id="markdown-toc-python3">1、客户端和服务端都安装python3</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">2、客户端准备一个干净的工程</a></li>
      <li><a href="#manifestgit" id="markdown-toc-manifestgit">3、服务器端创建manifest.git工程</a></li>
      <li><a href="#manifestxml-1" id="markdown-toc-manifestxml-1">4、客户端修改并上传manifest.xml文件</a></li>
      <li><a href="#manifestxml-2" id="markdown-toc-manifestxml-2">5、服务端分析manifest.xml文件，批量创建工程</a></li>
      <li><a href="#manifestxml-3" id="markdown-toc-manifestxml-3">6、客户端分析manifest.xml文件，批量上传到服务器</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">7、测试</a></li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>  repo是google开发的工具，用来管理多个git工程，最常用在Android源码管理上。<br />
  本文介绍的是如何把一个已有的repo工程提交到自己的服务器，在自己的服务器上管理这些源代码，同时保留原来repo组织这些代码仓库的结构。</p>

<!-- more -->

<h1 id="section">一、基础知识</h1>

<h2 id="git">1、git</h2>

<p>  git的详细使用方法这里不介绍，这里只要知道git服务器端建立git仓库的命令：<br />
   <code>git init --bare [仓库名].git</code></p>

<p>  而客户端创建工程、关联远程仓库、第一次提交的方法是：<br />
  <strong>创建工程：</strong><br />
  git init<br />
  <strong>关联远程仓库：</strong><br />
  git remote add origin [远程仓库地址]<br />
  <strong>第一次提交：</strong><br />
  git push -u origin master</p>

<h2 id="repo">2、repo</h2>

<p>  repo的详细使用方法这里也不介绍，repo要用到的命令有：</p>

<p>  <strong>repo init -u [manifest仓库地址]</strong><br />
  初始化repo工程，会把manifest.git仓库拖下来。<br />
  我们搭建好自己的repo服务器后，也可以使用此命令拖下来自己的repo仓库。</p>

<p>  <strong>repo sync</strong><br />
  同步代码。<br />
  搭建好自己的服务器后，用此命令同步时将会从自己的repo仓库同步代码。</p>

<h2 id="manifestxml">3、manifest.xml文件</h2>

<p>  这个文件要好好介绍一下，我们将会对这个文件进行解析，解析出各个git仓库的服务器地址、本地路径，并根据解析的结果创建和同步这些git仓库代码。</p>

<p><strong>1、开头会定义remote</strong></p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/1.png" alt="1.png" /><br />
  可以设置多个remote地址，用后面的name区分。<br />
  后面可以选择使用哪一个remote地址。</p>

<p><strong>2、指定默认参数</strong></p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/2.png" alt="2.png" /><br />
   remote=””   来指定使用哪一个remote地址。<br />
   revision    指定分支，从remote地址拖工程时指定拖哪个分支。<br />
   sync -j      指定同步线程数</p>

<p><strong>3、后面一大堆内容都是指定远程工程路径，以及拖下来的位置</strong></p>

<p>  瑞芯微的文件：</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/3.png" alt="3.png" /></p>

<p>  android原生文件：</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/4.png" alt="4.png" /><br />
  path：本地相对路径，可以不指定，不指定的话表示和name相同。<br />
  name：远程相对与remote地址的路径。<br />
  version：<br />
  groups：<br />
  upstream：<br />
  这里的每个name就代表一个git子工程，整个android工程有很多个git子工程组成，这里指定了各个子工程相对于remote的路径、版本、拖下来后的本地路径。</p>

<h1 id="repo-1">二、把已有的repo工程提交到自己的服务器</h1>

<p>  从上面得知，各个子工程的远程和本地路径都保存在manifest.xml文件里，那么我们只要解析这个文件就能获取服务器端和本地的文件结构。<br />
  在服务器端解析manifes.xml文件，获取所有git工程的远程路径，在服务器端批量创建这些git工程；<br />
  本地解析manifest.xml文件，获取各个git工程的本地路径和远程路径，在本地初始化git工程，并关联、提交到远程。</p>

<h2 id="python3">1、客户端和服务端都安装python3</h2>

<p>  对于ubuntu：sudo apt-get install python3<br />
  后面的脚本基于python3。</p>

<h2 id="section-1">2、客户端准备一个干净的工程</h2>

<p>  客户端是一个已有的repo工程，先准备好干净的代码准备提交，执行以下步骤：</p>

<p>  1、<strong>.repo/repo/repo sync</strong><br />
  2、删掉所有的.git目录<br />
    <code>find . -name ".git" | xargx rm -rf</code><br />
    因为待会会重新初始化这些git工程，所以以前的git信息不需要了。<br />
  3、复制出.repo/manifest.xml文件，删除.repo目录<br />
    repo工程里都会有一个.repo目录，此目录不再需要，但manifest.xml文件记录的各个工程信息是我们需要的，后面会解析此文件，把这个文件复制出来找个地方放一下。</p>

<h2 id="manifestgit">3、服务器端创建manifest.git工程</h2>

<p>  每个repo工程都会有一个 manifest.git 工程，此工程内容就是 manifest.xml 文件，manifest.xml文件记录了各个git子工程的信息。<br />
  我们在服务器创建一个 manifest.git 工程就是用于存放我们自己的 repo 工程的manifest.xml文件。<br />
  一般放在大工程目录下。</p>

<p>  <code>git init --bare /home/git/[工程目录]/manifest.git</code></p>

<h2 id="manifestxml-1">4、客户端修改并上传manifest.xml文件</h2>

<p>  1、把刚刚创建的manifest.git工程拖下来<br />
    <strong>git clone git@[ip]:[proj]/manifest.git</strong></p>

<p>  2、把已有的repo工程里的manifest.xml文件复制过来，并重命名为default.xml<br />
    就是前面删除本地.repo目录时备份的manifest.xml文件。</p>

<p>  3、修改default.xml里面的remote地址，改成新的服务器地址，分支改成master</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/5.png" alt="5.png" /></p>

<p>    注意地址格式写法，只有最后一行的写法是正确的。<br />
    添加新地址后，后面的default配置也要改，remote改成新添加的地址，revision改成master（我们将要保存的分支是master）。</p>

<p>  4、用脚本去掉default.xml里面的version等信息<br />
    默认的xml文件的工程可能带有一些remote、version信息，以后我们放在服务器都是在服务器的master上，这些信息需要清除。</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/6.png" alt="6.png" /></p>

<p>    用这个脚本：<a href="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/del_remote_version.py">del_remote_version.py</a></p>

<p>    把这个脚本复制到manifest.git工程目录，然后执行这个脚本：<br />
    <strong>./del_remote_version.py default.xml</strong></p>

<p>    此脚本会查找default.xml文件中的 remote、revision、upstream信息，并删除。执行后文件如下：</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/7.png" alt="7.png" /></p>

<p>  5、提交manifest工程<br />
    只需要提交default.xml文件即可，脚本不需要提交。</p>

<h2 id="manifestxml-2">5、服务端分析manifest.xml文件，批量创建工程</h2>

<p>  获取到manifest.xml文件的所有name信息（代表所有git子工程），然后用脚本批量创建git工程。</p>

<p>  1、把上面的default.xml文件用scp上传到服务端，放到工程目录下。<br />
  2、进入大工程目录，用 getnames_and_create_project.py 脚本分析 default.xml文件，并创建工程：<br />
    用这个脚本：<a href="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/getnames_and_create_project.py">getnames_and_create_project.py</a></p>

<p>    <strong>./getnames_and_create_project.py default.xml</strong></p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/8.png" alt="8.png" /></p>

<p>    脚本执行完成后会新建很多目录出来：</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/9.png" alt="9.png" /></p>

<h2 id="manifestxml-3">6、客户端分析manifest.xml文件，批量上传到服务器</h2>

<p>  刚刚在服务器上已经创建好了各个git子工程，这里把它们上传。<br />
  分析manifest.xml文件，获取到所有name信息（代表所有git子工程），然后用脚本批量上传git子工程。</p>

<p>  1、进入上面创建好的干净的工程目录，把上面建立好的default.xml文件复制到这里。<br />
  2、把客户端的id_rsa.pub加入到服务端的 authorized_keys里。<br />
  3、进入大工程目录，客制化以下脚本：<br />
    <a href="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/getnames_and_init_push_git_proj.py">getnames_and_init_push_git_proj.py</a></p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/10.png" alt="10.png" /></p>

<p>    修改这里的远程地址，后面会把工程提交到这里。<br />
    这里的地址应当和上面服务器端建立工程的地址相同。</p>

<p>  4、运行脚本</p>

<p>    <strong>./getnames_and_init_push_git_proj.py default.xml</strong><br />
    此脚本会解析default.xml里的name和path，<br />
    会先分析本地path是否为空目录，如果是空目录的话则会创建一个“.gitignore”文件，防止空目录提交失。<br />
    然后初始化本地path路径的代码，作为git工程提交到服务器端的name指定路径下。</p>

<h2 id="section-2">7、测试</h2>

<p>  找一个干净的地方，用 <strong>repo init -u [服务端manifest.git地址]</strong>，<br />
  然后 <strong>repo sync</strong>，此时应该可以同步所有git子工程。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-内核开发-说明 下载代码 编译 替换内核]]></title>
    <link href="http://nicekwell.net/blog/20171108/shu-mei-pai-nei-he-kai-fa-shuo-ming-xia-zai-dai-ma-bian-yi-ti-huan-nei-he.html"/>
    <updated>2017-11-08T19:21:11+08:00</updated>
    <id>http://nicekwell.net/blog/20171108/shu-mei-pai-nei-he-kai-fa-shuo-ming-xia-zai-dai-ma-bian-yi-ti-huan-nei-he</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、概述</a></li>
  <li><a href="#ubuntu" id="markdown-toc-ubuntu">二、ubuntu里交叉编译</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1、获取交叉编译工具和源码</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">2、配置编译环境变量</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">2.1 手动配置环境变量</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">2.2 自动配置环境变量</a></li>
        </ul>
      </li>
      <li><a href="#config" id="markdown-toc-config">3、配置config</a>        <ul>
          <li><a href="#config-1" id="markdown-toc-config-1">3.1 使用源码里自带的config</a></li>
          <li><a href="#config-2" id="markdown-toc-config-2">3.2 获取当前树莓派的config</a></li>
        </ul>
      </li>
      <li><a href="#section-5" id="markdown-toc-section-5">4、编译</a></li>
      <li><a href="#sddirectly-sd" id="markdown-toc-sddirectly-sd">5、挂载树莓派sd卡，并安装编译出的DIRECTLY 到sd卡</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">三、树莓派本地编译</a>    <ul>
      <li><a href="#section-7" id="markdown-toc-section-7">1、获取源码</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">2、配置编译环境</a></li>
      <li><a href="#config-3" id="markdown-toc-config-3">3、配置config</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">4、编译</a></li>
      <li><a href="#section-10" id="markdown-toc-section-10">5、更新系统</a></li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>树莓派运行linux系统，内核代码开源，我们可以自己修改内核代码、编写驱动。</p>

<p>本文介绍如何获取linux内核代码，并完成编译、内核替换。</p>

<!-- more -->

<h1 id="section">一、概述</h1>

<p>树莓派的github主页：<a href="https://github.com/raspberrypi">https://github.com/raspberrypi</a>，里面包含了linux源码、交叉编译工具链等内容。</p>

<p>对于我们要用到的有两个仓库：</p>

<p><a href="https://github.com/raspberrypi/linux">https://github.com/raspberrypi/linux</a> 内核源码</p>

<p><a href="https://github.com/raspberrypi/tools">https://github.com/raspberrypi/tools</a> 交叉编译工具链（仅在交叉编译时用到）</p>

<p>注：<br />
1、树莓派里安装的系统镜像版本要和kernel代码对应。因为树莓派系统是在不断开发和升级的，如果你的树莓派使用的是某个时间的系统镜像，那么最好也使用当时的kernel代码。<br />
2、关于内核编译方法，官网有很详细的介绍：<a href="https://www.raspberrypi.org/documentation/linux/kernel/building.md">https://www.raspberrypi.org/documentation/linux/kernel/building.md</a>，这里算是翻译和补充。<br />
3、以下编译过程在树莓派1和树莓派3B上测试ok。</p>

<h1 id="ubuntu">二、ubuntu里交叉编译</h1>

<h2 id="section-1">1、获取交叉编译工具和源码</h2>

<p>源码：<strong>git clone git@github.com:raspberrypi/linux</strong></p>

<p>交叉编译工具：<strong>git clone git@github.com:raspberrypi/tools</strong></p>

<h2 id="section-2">2、配置编译环境变量</h2>

<h3 id="section-3">2.1 手动配置环境变量</h3>

<p>编译工具下载后，在64位ubuntu上编译我们需要的编译工具bin文件在：tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin 目录下，将此目录添加到环境变量PATH中，添加方法：</p>

<p><strong>PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</strong></p>

<p>如果是在32位系统中编译则要选择32位的交叉编译工具。</p>

<p>配置完成之后可以用编译工具命令查看到版本号：<br />
arm-linux-gnueabihf-gcc -v</p>

<p>之后，所有的make命令都要指明一些环境变量：<br />
<strong>ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7</strong></p>

<table>
  <tbody>
    <tr>
      <td>ARCH=arm</td>
      <td>指明当前要编译arm，虽然树莓派是64位的，这里仍然选择arm，而不是arm64。</td>
    </tr>
    <tr>
      <td>CROSS_COMPILE</td>
      <td>指明交叉工具链名称。</td>
    </tr>
    <tr>
      <td>KERNEL</td>
      <td>指明kernel类型，<strong>树莓派1设置为kernel，树莓派2、3设置为kernel7。</strong></td>
    </tr>
  </tbody>
</table>

<p>每次make都需要指明这些环境变量，如：<br />
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig<br />
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage</p>

<h3 id="section-4">2.2 自动配置环境变量</h3>

<p>上面这些环境变量每次命令都要写很麻烦，可以通过export一次设置：<br />
 export PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7<br />
之后在本终端里执行的所有命令都带有这些环境变量信息。</p>

<p>此 export 命令可以写成一个脚本，然后在编译前在终端里source一下这个脚本即可设置好所有的环境变量。就像android编译前也要先source一下envsetup.sh一样。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c">#!/bin/bash</span>
</span><span class="line"><span class="nv">DIR</span><span class="o">=</span><span class="s2">&quot;$( cd &quot;</span><span class="k">$(</span> dirname <span class="s2">&quot;${BASH_SOURCE[0]}&quot;</span> <span class="k">)</span><span class="s2">&quot; &amp;&amp; pwd )&quot;</span>
</span><span class="line"><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;$PATH:$DIR/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/&quot;</span>
</span><span class="line"><span class="nb">export </span><span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- <span class="nv">KERNEL</span><span class="o">=</span>kernel7
</span></code></pre></td></tr></table></div></figure>

<p>上述命令中的路径可能和你实际不同，注意修改。</p>

<p>export环境变量后，在本终端里的后续命令都可以不用再指明这些环境变量，如：<br />
配置之前的命令：ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig<br />
配置之后的命令：make menuconfig</p>

<h2 id="config">3、配置config</h2>

<p>linux源码中有很多工程：<br />
树莓派1的工程是<strong>bcmrpi_defconfig</strong>；<br />
树莓派2、3的工程是<strong>bcm2709_defconfig</strong>。</p>

<h3 id="config-1">3.1 使用源码里自带的config</h3>

<p>ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make bcm2709_defconfig</p>

<p>此命令功能是获取bcm2709_defconfig的配置到 .config里。<br />
我们可以直接用工程里的配置，但这样的话可能会丢失原来使用的树莓派的配置，这里提供一个方法可以获取当前正在使用的树莓派的config。</p>

<h3 id="config-2">3.2 获取当前树莓派的config</h3>

<p>已经开机的树莓派上会有这个节点：<strong>/proc/config.gz</strong>，从这个节点可以获取本树莓派的config。<br />
如果没有这个节点的话则需要先加载模块：<strong>sudo modprobe configs</strong></p>

<p>把 config.gz 内容复制到要编译的电脑上：<br />
scp pi@[ip]:/proc/config.gz .</p>

<p>解压，保存为.confg文件。<br />
zcat config.gz &gt; .config<br />
注：必须在linux环境下解压，在mac下会乱码。</p>

<p>把此config文件复制到linux源码的根目录。</p>

<h2 id="section-5">4、编译</h2>

<p>安装必要的库：<br />
sudo apt-get install bc<br />
sudo apt-get install libncurses5-dev libncursesw5-dev<br />
sudo apt-get install zlib1g:i386<br />
sudo apt-get install libc6-i386 lib32stdc++6 lib32gcc1 lib32ncurses5</p>

<p><strong>1、执行menuconfig</strong><br />
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 <strong>make menuconfig</strong><br />
如果没什么改的就不用执行这一步。</p>

<p><strong>2、编译</strong><br />
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 <strong>make -j4 zImage modules dtbs</strong> 2&gt;&amp;1 | tee build.log<br />
以n进程编译。不指明几进程的话则默认以单进程编译。</p>

<p><strong>3、打包zImage文件</strong><br />
直接用linux源码包里的工具：<br />
./scripts/mkknlimg arch/arm/boot/zImage ./kernel_new.img<br />
在本目录生成一个kernel_new.img文件，这个文件就是要放到sd卡中的文件。<br />
注：网上很多地方说的用 tools/mkimage/imagetool-uncompressd.py 的方法不行！！</p>

<h2 id="sddirectly-sd">5、挂载树莓派sd卡，并安装编译出的DIRECTLY 到sd卡</h2>

<p>把树莓派的sd卡插入ubuntu系统电脑，树莓派的sd卡有两个分区：<br />
一个fat分区，是boot相关的内容，kernel的img文件就放在这个分区里；<br />
一个是ext4分区，也就是系统的根目录分区。</p>

<p>我们生成的文件涉及到这两个分区的内容，一般插入ubuntu后会自动挂载，fat分区可以不用root权限操作，ext4分区需要root权限操作。<br />
两个分区具体挂载在什么地方可以自己决定，以下用[fat]表示boot挂载的路径，[ext4]表示ext4挂载的路径。</p>

<p><strong>1、安装modules</strong><br />
sudo ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make INSTALL_MOD_PATH=[ext4] modules_install<br />
操作ext4分区，需要root权限。</p>

<p><strong>2、更新 kernel.img 文件</strong><br />
前面已经用 mkknlimg 工具打包了kernel_new.img文件了，把它复制到boot分区并配置使用即可：<br />
cp kernel_new.img [fat]/<br />
编辑 [fat]/config.txt 文件，在最后加入一行：<br />
kernel=kernel_new.img</p>

<p><strong>3、复制其他相关文件</strong><br />
cp arch/arm/boot/dts/<em>.dtb [fat]/<br />
cp arch/arm/boot/dts/overlays/</em>.dtb* [fat]/overlays/<br />
cp arch/arm/boot/dts/overlays/README [fat]/overlays/</p>

<p>更新完成后插回树莓派即可开机，开机后可以用 uname -a 命令查看kernel信息已经改变。</p>

<h1 id="section-6">三、树莓派本地编译</h1>

<p>树莓派上本地编译和上面交叉编译原理基本相同，由于是本地编译，在编译工具和环境变量配置方面还简单一些。<br />
树莓派上编一次内核花了将近2小时。</p>

<h2 id="section-7">1、获取源码</h2>

<p>git clone git@github.com:raspberrypi/linux</p>

<h2 id="section-8">2、配置编译环境</h2>

<p>在ubuntu里交叉编译时需要配置的环境变量有：</p>

<ul>
  <li>PATH: 添加交叉工具链的目录</li>
  <li>ARCH: 配置成arm</li>
  <li>CROSS_COMPILE: 配置成ubuntu上使用的交叉工具链arm-linux-gnueabihf- KERNEL=kernel7</li>
  <li>KERNEL: 配置成kernel7</li>
</ul>

<p>而在树莓派本地编译：<br />
关于交叉工具链，本身的编译工具就可以编译给自己使用，所以不用配置；<br />
只需要配置 KERNEL=kernel7 即可。</p>

<p>和上面相同，可以用 export KERNEL=kernel7，一次设置之后此终端里所有命令都带有此环境变量。<br />
也可以更进一步写成脚本，不过这里这一行命令很简单，不写脚本也可以。</p>

<h2 id="config-3">3、配置config</h2>
<p>和上面一样，<br />
树莓派1使用的是 <strong>bcmrpi_defconfig</strong>，<br />
树莓派2、3使用的是 <strong>bcm2709_defconfig</strong>。<br />
例：KERNEL=kernel7 make bcm2709_defconfig</p>

<p>如果要使用树莓派自带的config的话：<br />
<strong>sudo modprobe configs</strong>    # 加载模块<br />
<strong>zcat config.gz &gt; .config</strong>      # 获取配置</p>

<h2 id="section-9">4、编译</h2>
<p>安装必要的库：<br />
sudo apt-get install bc<br />
sudo apt-get install libncurses5-dev libncursesw5-dev<br />
sudo apt-get install zlib1g<br />
sudo apt-get install libc6</p>

<p>1、执行menuconfig<br />
<strong>KERNEL=kernel7 make menuconfig</strong><br />
没什么要改的话就不用执行这一步。</p>

<p>2、编译<br />
<strong>KERNEL=kernel7 make -j4 zImage modules dtbs 2&gt;&amp;1 | tee build.log</strong><br />
以n进程编译。不指明几进程的话则默认以单进程编译。</p>

<p>3、打包zImage文件<br />
直接用linux源码包里的工具：<br />
<strong>./scripts/mkknlimg arch/arm/boot/zImage ./kernel_new.img</strong><br />
在本目录生成一个kernel_new.img文件，这个文件就是要放到sd卡中的文件。</p>

<h2 id="section-10">5、更新系统</h2>

<p>1、安装模块<br />
<strong>sudo make modules_install</strong></p>

<p>2、复制dtb文件<br />
<strong>sudo cp arch/arm/boot/dts/<em>.dtb /boot/
sudo cp arch/arm/boot/dts/overlays/</em>.dtb* /boot/overlays/
sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/</strong></p>

<p>3、更新kernel.img文件<br />
<strong>sudo cp arch/arm/boot/zImage /boot/$KERNEL.img</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈一谈单片机开发的几种调试方案]]></title>
    <link href="http://nicekwell.net/blog/20170411/tan-%5B%3F%5D-tan-dan-pian-ji-kai-fa-de-ji-chong-diao-shi-fang-an.html"/>
    <updated>2017-04-11T20:59:27+08:00</updated>
    <id>http://nicekwell.net/blog/20170411/tan-[?]-tan-dan-pian-ji-kai-fa-de-ji-chong-diao-shi-fang-an</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">我们做调试工具追求的是什么</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">几种调试方案</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">1、加入屏和按键</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">2、串口+上位机</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">3、用树莓派</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">4、串口+通用终端工具</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">如何构建终端工具里的控制台界面</a>    <ul>
      <li><a href="#section-7" id="markdown-toc-section-7">1、构建界面用到的特殊字符串</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">2、封装好的库函数</a></li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>单片机开发过程中，有一个好的调试系统可以极大地提高开发效率。<br />
举个例子，做平衡系统时调节PID参数，你会选择 修改参数–&gt;编译–&gt;烧录–&gt;运行–&gt;修改…，还是做一个功能可以一边运行一边修改参数呢？<br />
调试的方法有多种，在这就来分别谈一下我在开发过程中使用过的几种调试方案。<br />
这里的调试方案也是一种交互方案，但此方案不是为了交互而设计，重在快速地搭建、方便地使用、高效地调试，换句话说长得丑无所谓。</p>

<!-- more -->

<h1 id="section">我们做调试工具追求的是什么</h1>

<p>做调试系统无非是为了两点：</p>

<ol>
  <li>实时显示一些必要信息。</li>
  <li>实时修改，其实也就是可以实时接收指令。</li>
</ol>

<p>为了提高开发效率，我们进一步希望：</p>

<ol>
  <li>调试系统搭建起来方便快捷，最好可以统一标准，方便移植。<br />
我们不希望在调试系统上花费太多工作量，不要太复杂，尽量轻量级。</li>
  <li>直观显示，看得清楚。</li>
  <li>方便输入，操作快捷。</li>
</ol>

<h1 id="section-1">几种调试方案</h1>

<h2 id="section-2">1、加入屏和按键</h2>

<p><img src="http://nicekwell.net/images/misc/2017-04-12_1.jpg" alt="" /></p>

<p>最直接的方法就是在嵌入式系统中加入屏和按键，做出一个界面，显示信息和接收按键指令。<br />
【优点】跟随系统，不需要依赖其他设备，可以随时随地调试。</p>

<p>【缺点】</p>

<ol>
  <li>添加了硬件。硬件的设计和焊接还是需要花费一些精力的。</li>
  <li>构建界面同样也要花费不少精力。</li>
  <li>显示信息有限。<br />
加入的屏通常显示内容比较少，会受到一些限制。</li>
  <li>按键功能有限。<br />
加入的按键通常也不会太多，并且如果我们考虑到长按、组合键等操作的话构建程序也是比较复杂的。</li>
</ol>

<p>【总结】<br />
肯定不能算轻量级，功能有限，可移植性差，花费精力多，屏需要额外费用。<br />
唯一的优点就是跟随系统，没有其他依赖。</p>

<p>所以如果不是非要随时调试的话不建议用这种方法，单纯为了调试来说代价还是比较大的。</p>

<h2 id="section-3">2、串口+上位机</h2>

<p><img src="http://nicekwell.net/images/misc/2017-04-12_2.jpg" alt="" /></p>

<p>单片机自己不负责显示，它把数据发送出去，由上位机显示；也不负责按键检测，由上位机负责并接收上位机指令。<br />
单片机和上位机之间需规定好通信协议。</p>

<p>通信方式可以是串口也可以是其他，上位机可以是图形也可以是命令行。</p>

<p>【优点】</p>

<ol>
  <li>对单片机来说做到了一定的轻量级。只需要考虑发送数据和接收指令的协议。</li>
  <li>对于比较复杂的功能，好的上位机，尤其是图形化的上位机可以很方便地调试。</li>
</ol>

<p>【缺点】</p>

<ol>
  <li>需要设计通信协议，双方都要位通信协议写代码。这需要花费一定的精力。</li>
  <li>制作上位机需要花费较多的精力，并且上位机不通用。</li>
</ol>

<p>【总结】<br />
由于上位机在电脑上，有丰富的显示和控制资源，做出一个好的上位机可以极其方便地提高效率。<br />
但制作上位机要花费大量精力。</p>

<p>所以，如果上位机是作为产品发布，是值得花精力去做的；但如果仅仅是为了调试时用一下，不值得这样做。</p>

<p><strong>到这里有没有注意到，其实我们是想找到一个通用的”显示器”，能够方便地把信息显示出来。
显示器是已经做好的，不需要我们再做什么，通信协议尽可能简单，最好能直接输出。
后面我们会找到这么一个好东西。</strong></p>

<h2 id="section-4">3、用树莓派</h2>

<p><img src="http://nicekwell.net/images/misc/2017-04-12_3.jpg" alt="" /></p>

<p>用树莓派进行关键计算，我们关心的数据都在树莓派的程序里。<br />
由于树莓派里运行linux系统，在其连接网络后，我们可以用局域网里电脑的终端登陆树莓派，在树莓派的程序里直接打印接口显示出来。</p>

<p><em>注：<br />
在命令行下打印数据并不一定是一行一行地输出，也可以控制光标在指定位置输出，构建出一个简单的界面。这里不做介绍，具体可搜索”控制台编程”。<br />
命令行下接收键盘操作也不一定非要输入字符再回车，程序里可以直接监测键盘。<br />
总之在命令行中是可以构建出一个类似于 显示屏+按键 组合的”设备”的。</em></p>

<p>【优点】</p>

<ol>
  <li>终端就相当于是一个现成的、通用的显示屏，任意可登陆ssh的终端都可使用。</li>
  <li>程序里直接打印输出！这真是太方便的，c语言中一个printf即可，相当于是一个极其简单的通信协议。</li>
</ol>

<p>【缺点】</p>

<ol>
  <li>贵！一个小小的智能车都要塞个树莓派，树莓派价格都够好多个智能车了。</li>
  <li>树莓派本身是重量级。虽然程序本身是方便了，但使用之前需要配置树莓派，虽然一个树莓派只要配置一次。</li>
  <li>树莓派本身硬件功能有限，有些功能树莓派不能直接完成，还是需要借助单片机，并和单片机通信。<br />
比如记录车轮旋转的正交编码器，stm32有专门的硬件模块完成，树莓派没有，如果树莓派想要记录车轮旋转的话还是需要借助stm32，并且设计如何获取stm32记录的数据。</li>
</ol>

<p>【总结】</p>

<p>对于调试这一方面来说，树莓派是非常方便的，输出、输入都是直接完成。<br />
所以如果你的项目值得用树莓派，那调试是非常方便的；如果不需要用树莓派，光是为了调试方便而使用是不建议的，请考虑上面3个缺点。</p>

<p><strong>虽然树莓派本身不一定最合适，但我们找到了方向——终端。</strong></p>

<h2 id="section-5">4、串口+通用终端工具</h2>

<p>单片机能不能用终端呢？答案是肯定的。<br />
有多种终端工具可以通过串口使用，比如windows自带的超级终端，linux和osx下命令行里的minicom，以及夸三个平台的图形化终端secureCRT。<br />
这些终端工具的功能简单来说就是：1、当某个按键按下立刻发送该按键的键码出去，比如按下p键发送字符’p’。2、接收串口数据并显示出来。</p>

<p>说明：</p>

<ol>
  <li>这些终端工具的协议是相同的，可以认为是通用的显示器和键盘。</li>
  <li>单片机可以发送一些特殊字符串完成一些特殊操作，比如清屏、控制光标位置。利用这些功能可以构建出简单的界面。<br />
这些操作功能已经封装成了函数，会在本文后面给出。</li>
  <li>一般会先在单片机中实现printf功能，实现之后在程序中用printf即可直接在终端工具中显示信息。<br />
实现printf功能的方法在这里不介绍，具体可上网查找，工作量并不大。其实就是重定义一个函数，使printf函数通过指定串口输出字符串。</li>
  <li>串口通过蓝牙模块可快速实现无线传输。</li>
</ol>

<p>【优点】</p>

<ol>
  <li>单片机端轻量级，上位机端无工作量。<br />
具体来说单片机端要做的事情有：初始化串口，重定向printf，通过特殊字符串控制光标构建界面。</li>
  <li>上位机端通用，单片机端显示相关的代码方便移植。<br />
本文后文会给出显示相关的库函数。</li>
  <li>硬件扩展几乎没有。</li>
</ol>

<p>【缺点】</p>

<p>对比第1种方案，需要一台电脑。其他方面都具有很大优势。</p>

<p>【总结】</p>

<p>此方案是单片机开发调试的理想选择。</p>

<p>下面会介绍如何在终端工具里构建出界面。</p>

<h1 id="section-6">如何构建终端工具里的控制台界面</h1>

<h2 id="section-7">1、构建界面用到的特殊字符串</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">字符(串)</th>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">\r</td>
      <td style="text-align: center">光标移到行首</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">\b</td>
      <td style="text-align: center">退格</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[2J”</td>
      <td style="text-align: center">清屏</td>
      <td style="text-align: center"><strong>清屏后光标还在原来位置</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[2K]”</td>
      <td style="text-align: center">清除本行</td>
      <td style="text-align: center">清除后光标还在原来位置</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[H”</td>
      <td style="text-align: center">光标复位，回到左上角（1行1列）</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%d;%dH”, y, x</td>
      <td style="text-align: center">设置光标到y行x列</td>
      <td style="text-align: center">终端中的行和列都是从1开始数的</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dA”, y</td>
      <td style="text-align: center">光标上移y行</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dB”, y</td>
      <td style="text-align: center">光标下移y行</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dD”, x</td>
      <td style="text-align: center">光标左移x列</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dC”, x</td>
      <td style="text-align: center">光标右移x列</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[?25l”</td>
      <td style="text-align: center">隐藏光标</td>
      <td style="text-align: center">在secureCRT中测试无效</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[?25h”</td>
      <td style="text-align: center">显示光标</td>
      <td style="text-align: center">在secureCRT中测试无效</td>
    </tr>
  </tbody>
</table>

<p>注：</p>

<ol>
  <li>终端工具里的x、y坐标都是从1开始数的，同时等于0的话终端也会认为是1。</li>
  <li>\033代表的是八进制033，对应十进制是27，十六进制是0x1B。</li>
</ol>

<h2 id="section-8">2、封装好的库函数</h2>

<p>使用这个库函数的前提是：<br />
1、主函数完成了串口初始化，串口功能正常使用。<br />
2、重定向了printf函数，printf函数可通过串口输出字符串。</p>

<p>disp.h文件：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#ifndef __DISP_H__</span>
</span><span class="line"><span class="cp">#define __DISP_H__</span>
</span><span class="line"><span class="cm">/* 在主函数已经完成串口初始化，并且重定向printf函数之后，</span>
</span><span class="line"><span class="cm">   这里提供一些列函数用于操作终端工具显示，可在终端工具里构建界面。 */</span>
</span><span class="line"><span class="cp">#include &lt;stm32f10x_lib.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_clean</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_clean_line</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>     <span class="c1">//清除当前航，并复位光标到行首</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>        <span class="c1">//复位光标位置，回到左上角（1行1列）</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_gotoxy</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">//跳转到y行x列，x和y都是从1开始数。</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">);</span>      <span class="c1">//上移x行</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_down</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">);</span>    <span class="c1">//下移y行</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_left</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>    <span class="c1">//左移x列</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_right</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>   <span class="c1">//右移x列</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_hide</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>     <span class="c1">//隐藏光标，在secureCRT中测试无效。</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_show</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>     <span class="c1">//显示光标，在secureCRT中测试无效。</span>
</span><span class="line">
</span><span class="line"><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>
<p>disp.c文件：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;disp.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;uart.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_clean</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[2J&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_clean_line</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>      <span class="c1">//清除当前行，并复位光标到行首</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\33</span><span class="s">[2K</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>        <span class="c1">//复位光标位置，回到左上角</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[H&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_gotoxy</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="c1">//跳转到y行x列</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%d;%dH&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>      <span class="c1">//上移x行</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%dA&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_down</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>    <span class="c1">//下移y行</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%dB&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_left</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>    <span class="c1">//左移x列</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%dD&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_right</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>   <span class="c1">//右移x列</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%dC&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_hide</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>     <span class="c1">//隐藏光标</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[?25l&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_show</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>     <span class="c1">//显示光标</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[?25h&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通用舵机控制器（pwm信号发生器）]]></title>
    <link href="http://nicekwell.net/blog/20161228/tong-yong-duo-ji-kong-zhi-qi-(pwmxin-hao-fa-sheng-qi-).html"/>
    <updated>2016-12-28T14:49:53+08:00</updated>
    <id>http://nicekwell.net/blog/20161228/tong-yong-duo-ji-kong-zhi-qi-(pwmxin-hao-fa-sheng-qi-)</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">功能</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">硬件</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">程序结构</a></li>
</ul>
<p>  </p>

<p>拿到一个机械臂时你会怎么办？搭电路，写程序，控制这个机械臂，然后这套电路一直放在机械臂上。<br />
拿到一个电调呢？找航模遥控器来测试电调？也是一个不错的办法~然而有没有更方便的办法呢？</p>

<p>博主最近很空虚，冥冥之中感觉生命中缺少一个美妙的通用舵机控制器，能够让我把舵机和电调快速地撸起来~</p>

<!-- more -->

<p>工程放在github上：<a href="https://github.com/nicekwell/servo_controller">https://github.com/nicekwell/servo_controller</a><br />
可以直接下载此工程：<a href="https://github.com/nicekwell/servo_controller/archive/master.zip">https://github.com/nicekwell/servo_controller/archive/master.zip</a></p>

<p>有关PPM信号相关的知识可参考：<a href="http://nicekwell.net/blog/20161223/ppmxin-hao-jie-shao.html">PPM信号介绍</a></p>

<p>演示视频：</p>

<p><br /></p>
<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMTg4NzQ0MDA5Mg?color=white&amp;theme=light"></iframe>

<p><br /></p>
<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMTg4NzUyNDA0OA?color=white&amp;theme=light"></iframe>

<p>  </p>

<p>  </p>

<p>以下内容从工程README复制：</p>

<h1 id="section">功能</h1>
<p>可以产生7路PWM信号。<br />
周期固定为20ms，脉宽可调，精度为10us。<br />
上方7路输出通道，最上面为信号脚，中间是VCC，下面是GND。<br />
下方7个按钮选择当天调节哪路信号，按下按钮后，上方对应通道的led灯点亮，同时显示屏相应通道也会有闪烁。<br />
右边5个按钮调节当前通道的脉宽，从上到下功能依次为：加100，加10，复位（设置为1500us），减10，减100。<br />
<strong>脉宽调节没有范围限制！！</strong>所以调节时一定要注意。<br />
开机后默认所有路通道脉宽为1500us。</p>

<h1 id="section-1">硬件</h1>
<p>【单片机】12C5A32S2<br />
【晶振】24MHz<br />
【引脚连接】</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">引脚</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">舵机控制脚1</td>
      <td style="text-align: center">P1.6</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚2</td>
      <td style="text-align: center">P1.5</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚3</td>
      <td style="text-align: center">P1.4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚4</td>
      <td style="text-align: center">P1.3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚5</td>
      <td style="text-align: center">P1.2</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚6</td>
      <td style="text-align: center">P1.1</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚7</td>
      <td style="text-align: center">P1.0</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led1</td>
      <td style="text-align: center">P0.6</td>
      <td style="text-align: center">推挽输出，高电平点亮，所有负极接在一起串联了电阻，一次只能点亮一个灯</td>
    </tr>
    <tr>
      <td style="text-align: center">led2</td>
      <td style="text-align: center">P0.5</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led3</td>
      <td style="text-align: center">P0.4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led4</td>
      <td style="text-align: center">P0.3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led5</td>
      <td style="text-align: center">P0.2</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led6</td>
      <td style="text-align: center">P0.1</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led7</td>
      <td style="text-align: center">P0.0</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关1</td>
      <td style="text-align: center">P2.0</td>
      <td style="text-align: center">所有开关按下是低电平</td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关2</td>
      <td style="text-align: center">P2.1</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关3</td>
      <td style="text-align: center">P2.2</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关4</td>
      <td style="text-align: center">P2.3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关5</td>
      <td style="text-align: center">P2.4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关6</td>
      <td style="text-align: center">P2.5</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关7</td>
      <td style="text-align: center">P2.6</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关-100</td>
      <td style="text-align: center">P3.7</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关-10</td>
      <td style="text-align: center">P3.6</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关复位</td>
      <td style="text-align: center">P3.5</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关+10</td>
      <td style="text-align: center">P3.4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关+100</td>
      <td style="text-align: center">P3.3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">显示屏SCL</td>
      <td style="text-align: center">P0.7</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">显示屏SDA</td>
      <td style="text-align: center">P1.7</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h1 id="section-2">程序结构</h1>
<p>定时器10us一次中断，在定时器中断中完成 7路pwm通道脉宽控制 和 按键扫描 任务，其中按键扫描分成了三个函数分别进行。（广告：想了解这样做的原因，以及更多单片机编程结构相关的内容请访问<a href="http://nicekwell.net/pages/dan-pian-ji-bian-cheng.html">http://nicekwell.net/pages/dan-pian-ji-bian-cheng.html</a>）
主进程完成显示屏显示任务。</p>

<p>定时器进程检测到按键操作后，会发送标志给主进程刷新显示。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单片机提取WFR07接收机信号]]></title>
    <link href="http://nicekwell.net/blog/20161224/dan-pian-ji-ti-qu-wfr07jie-shou-ji-xin-hao.html"/>
    <updated>2016-12-24T00:39:52+08:00</updated>
    <id>http://nicekwell.net/blog/20161224/dan-pian-ji-ti-qu-wfr07jie-shou-ji-xin-hao</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">硬件</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">输出格式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">程序结构介绍</a></li>
</ul>

<p>为什么要提取接收机信号？因为有时候航模那端想要按照自己的想法编程，同时又希望能够使用航模遥控器这个方便的工具。<br />
总之如果能够把航模遥控器信号转换成数字信号，无论用它做什么也是极好的~</p>

<!-- more -->

<p>工程放在github上：<a href="https://github.com/nicekwell/WFR07_decode">https://github.com/nicekwell/WFR07_decode</a><br />
也可以直接<a href="https://github.com/nicekwell/WFR07_decode/archive/master.zip">下载</a>此工程。</p>

<p>完成后的效果视频：</p>

<p><br /></p>
<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMTg3OTU4ODYxNg?color=white&amp;theme=light"></iframe>

<p>  </p>

<p>  </p>

<p>以下是一些重要的说明，在工程的README中有更详细的介绍。</p>

<p>  </p>

<h1 id="section">硬件</h1>
<p>【单片机】STC12C5A60S2<br />
【晶振】24MHz<br />
注：此晶振可产生精确地定时器中断，方便监测各个通道，但串口波特率会有0.16%的误差，不会影响使用。<br />
【引脚连接】<br />
CH1：P1.6<br />
CH2：P1.5<br />
CH3：P1.4<br />
CH4：P1.3<br />
CH5：P1.2<br />
CH6：P1.1<br />
CH7：P1.0<br />
TXD：P3.1</p>

<h1 id="section-1">输出格式</h1>
<p>【波特率】115200<br />
实测发送一个字节大约需要13us，这样算的话一帧发送8字节大约需要104us。<br />
这里测量的13us是程序把一字节数据送入缓存，并等待发送完成标志所用的时间，不是实际串口的工作时间。<br />
【数据格式】<br />
每个周期内，当采集完7个通道的高电平后（最长约14ms）会立刻通过串口发送7个通道的数据信息。<br />
每个周期的数据为一帧，一帧数据有8个字节：<br />
第一字节固定为0x01，标志一帧数据开始。（后面7个字节不可能为这个值）<br />
后面7个字节依次表示CH1到CH7的脉宽，单位是10us。如输出150表示脉宽为1500us。<br />
注：<br />
1、接收机输出的脉宽范围大约在1000us~2000us之间，所以7个脉宽的数据范围大约在100~200之间。<br />
2、解码后输出的数据单位是10us，但实际接收机输出的精度是20us，单片机程序也是按照20us的精度采样的。</p>

<p>对于此接收机，不会出现信号丢失的情况，当遇到遥控器信号丢失时，接收机会输出预先设定好的信号，对于解码器来说不能区分当前遥控器信号是否丢失。</p>

<h1 id="section-2">程序结构介绍</h1>
<p>两个进程：定时器中断和主循环。</p>

<p>定时器20us一次中断，有两个状态：<br />
1、信号采集中：<br />
  1、采集各个通道高电平时间。<br />
  2、判断当前所有通道是否采集完成（所有通道信号结束后，所有通道都会输出低电平。<br />
    如果连续100us（5个周期）检测到所有通道都是低电平，则认为一帧信号结束，此时对采集到的信号进行判断：<br />
      如果所有通道脉宽大于500us，则认为数据有效，通知主进程发送数据，并进入状态2。<br />
2、本周期信号已结束，等待下一周期：<br />
  任意通道采集到高电平则进入状态1。</p>

<p>主循环进程只干一件事，等待定时器进程发送指令，接收到指令后发送数据。<br />
但主循环会忽略第一帧数据，因为第一帧数据可能采集不完整。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
</feed>
