<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[生命不息 折腾不止]]></title>
  <link href="http://nicekwell.net/atom.xml" rel="self"/>
  <link href="http://nicekwell.net/"/>
  <updated>2017-11-22T20:15:59+08:00</updated>
  <id>http://nicekwell.net/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-GPIO]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio.html"/>
    <updated>2017-11-22T20:07:42+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p>GPIO接口在官网有详细的说明：<a href="http://wiringpi.com/reference/core-functions/">http://wiringpi.com/reference/core-functions/</a></p>

<p>wiringPi的GPIO序号如下：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/1.jpg" alt="1.jpg" /></p>

<p> </p>

<p><strong>void pinMode (int pin, int mode) ;</strong><br />
设置GPIO模式。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
mode可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>INPUT</td>
    </tr>
    <tr>
      <td>OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>GPIO_CLOCK</td>
    </tr>
    <tr>
      <td>SOFT_PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>SOFT_TONE_OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_TONE_OUTPUT</td>
    </tr>
  </tbody>
</table>

<p>只有具有相应功能的引脚才能设置为该功能。</p>

<p> </p>

<p><strong>void pullUpDnControl (int pin, int pud) ;</strong><br />
设置上下拉。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
pud是上下拉配置，可设置为：</p>

<table>
  <tbody>
    <tr>
      <td>PUD_OFF</td>
      <td>无上下拉</td>
    </tr>
    <tr>
      <td>PUD_UP</td>
      <td>上拉，3.3v，50kΩ</td>
    </tr>
    <tr>
      <td>PUD_DOWN</td>
      <td>下拉，50kΩ</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p><strong>void digitalWrite (int pin, int value) ;</strong><br />
设置指定引脚的输出。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
value是输出值，可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>HIGH 或 非0</td>
      <td>高电平（3.3v）</td>
    </tr>
    <tr>
      <td>LOW 或 0</td>
      <td>低电平</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>void digitalWriteByte (int value) ;</p>

<p> </p>

<p><strong>int digitalRead (int pin) ;</strong><br />
读取指定引脚。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
返回的是该引脚的电平，返回HIGH或LOW。</p>

<p> </p>

<p><strong>void pwmWrite (int pin, int value) ;</strong><br />
设置pwn输出占空比。<br />
pin是引脚序号，以何种方式编号在前面决定。（最新的树莓派里面好像把pwm功能去掉了）<br />
value是占空比，范围是0~1023。<br />
？？？在哪设置pwm的周期呢？</p>

<p> </p>

<p><strong>analogRead (int pin) ;</strong><br />
读入模拟量（AD）。<br />
<strong>analogWrite (int pin, int value) ;</strong><br />
输出模拟量（DA）。<br />
<em>以上两个功能需要外加芯片</em>，这里略去。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPI-设置引脚编号模式]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi.html"/>
    <updated>2017-11-22T19:52:38+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi</id>
    <content type="html"><![CDATA[<p>  </p>

<p>前面说过树莓派在不同的库下对引脚的编号方式是不同的，wiringPi支持设置各种不同的引脚编号方式。</p>

<!-- more -->

<p>安装好wiringPi之后，不仅在系统中添加了头文件和库，同时也安装了命令行工具。<br />
在shell中可以用 <strong>gpio readall</strong> 命令获取到以下信息：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi/1.png" alt="1.png" /></p>

<p>wiringPi提供三种引脚排序方式：wPi、BCM、Phy。<br />
必须在程序开始时指明使用哪种排序方式。</p>

<ol>
  <li>wiringPi排序方式<br />
<strong>int wiringPiSetup (void) ;</strong><br />
调用此函数即可设置为wiringPi排序。</li>
  <li>BCM排序方式<br />
<strong>int wiringPiSetupGpio (void) ;</strong><br />
调用此函数即可。</li>
  <li>物理排序方式（和 raspberry-gpio-python 的排序相同）<br />
<strong>int wiringPiSetupPhys (void) ;</strong><br />
按照引脚顺序排序，没有GPIO的引脚是无法控制的。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-编译&amp;头文件&amp;lib]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-bian-yi-and-tou-wen-jian-and-lib.html"/>
    <updated>2017-11-22T19:40:06+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-bian-yi-and-tou-wen-jian-and-lib</id>
    <content type="html"><![CDATA[<p>  </p>

<p>安装好之后想要使用wiringPi的接口，就必须要包含wiringPi的头文件、链接wiringPi库，本文介绍如何正确编译。</p>

<!-- more -->

<p>安装好之后，会生成以下头文件：</p>

<table>
  <tbody>
    <tr>
      <td>/usr/local/include/wiringPi.h</td>
      <td>提供基础的服务，包括GPIO。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiI2C.h</td>
      <td>提供I2C相关支持。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiSPI.h</td>
      <td>提供SPI相关支持。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiShift.h</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>生成以下库：</p>

<table>
  <tbody>
    <tr>
      <td>/usr/local/lib/libwiringPiDev.so</td>
    </tr>
    <tr>
      <td>等</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>在编写C程序时：</p>

<ol>
  <li>要 include 头文件，直接用&lt;&gt;即可，不需要指明路径。<br />
如：#include <wiringPi.h>  
编译器会自动从/usr/local/include/目录下寻找头文件。</wiringPi.h></li>
  <li>编译时要连接wiringPi的库。<br />
如：gcc gpio.c -o gpio -<strong>lwiringPi</strong><br />
编译器会自动从/usr/local/lib/目录下寻找库。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-说明和安装]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang.html"/>
    <updated>2017-11-22T19:16:22+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">说明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">原理</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">安装</a></li>
</ul>
<p>  </p>

<p>wiringPi是树莓派上层提供gpio、串口、i2c等硬件操作的一套库，经过其封装后的接口函数使用起来非常方便。<br />
wiringpi已经不局限于C语言了，也提供了其他各种语言的接口，甚至提供了命令行工具，直接在命令行操作GPIO。<br />
我们这里介绍的是wiringPi的C接口。</p>

<!-- more -->

<h3 id="section">说明</h3>

<p>wiringPi是树莓派上层提供gpio、串口、i2c等硬件操作的一套库，经过其封装后的接口函数使用起来非常方便。<br />
wiringpi已经不局限于C语言了，也提供了其他各种语言的接口，甚至提供了命令行工具，直接在命令行操作GPIO。<br />
我们这里介绍的是wiringPi的C接口。</p>

<p>官方首页：<a href="http://wiringpi.com/">http://wiringpi.com/</a><br />
wiringPi-c的github主页：<a href="https://github.com/WiringPi/WiringPi">https://github.com/WiringPi/WiringPi</a><br />
官方说明文档：<a href="http://wiringpi.com/reference/">http://wiringpi.com/reference/</a></p>

<h3 id="section-1">原理</h3>

<p>通过wiringPi 的源码可以看出，<strong>wiringPi是一个在现有的上层接口基础上封装的一层库函数</strong>。上层不通过wiringPi也可以直接通过linux标准接口完成功能，wiringPi封装的好处是使用比较方便（但也裁剪了很多功能）。<br />
如：<br />
  GPIO库，实际上是通过操作GPIO节点实现：<br />
  <img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang/1.png" alt="1.png" /></p>

<p>  serial库，实际上也是通过标准的open、write等函数实现：<br />
  <img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang/2.png" alt="2.png" /></p>

<h3 id="section-2">安装</h3>

<p>1、用git把代码拖下来<br />
<strong>git clone git://git.drogon.net/wiringPi</strong><br />
也可以从github拖下来：<br />
<strong>git clone git@github.com:WiringPi/WiringPi.git</strong></p>

<p>对比发现作者在这两个地方都进行维护，代码内容完全一样。</p>

<p> </p>

<p>2、安装
进入目录，直接<br />
<strong>./build</strong><br />
不需要sudo权限。</p>

<p>安装过后，就可以使用命令行和C接口了。具体怎么使用见后面内容。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-UART串口]]></title>
    <link href="http://nicekwell.net/blog/20171120/shu-mei-pai-pypi-uartchuan-kou.html"/>
    <updated>2017-11-20T19:37:15+08:00</updated>
    <id>http://nicekwell.net/blog/20171120/shu-mei-pai-pypi-uartchuan-kou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#pythonpyserial" id="markdown-toc-pythonpyserial">python通用串口库——pyserial</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">一、安装</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">二、使用</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">1、打开串口并创建对象</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">2、缓冲区操作</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">3、波特率设置</a></li>
          <li><a href="#section-6" id="markdown-toc-section-6">4、从串口发送数据</a></li>
          <li><a href="#section-7" id="markdown-toc-section-7">5、从串口接收数据</a></li>
          <li><a href="#section-8" id="markdown-toc-section-8">6、关闭串口</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>树莓派在linux上层支持通用的串口接口，用linux上通用的串口编程即可操作。<br />
树莓派3B的板载串口被蓝牙占用，但可以方便地使用USB串口模块。</p>

<!-- more -->

<h2 id="section">概述</h2>

<p>树莓派的板载串口是给系统登录使用的，我们要先把这个功能关掉。<br />
<strong>sudo raspi-config</strong><br />
Advanced Options –&gt; Serial –&gt; 关闭串口 –&gt; 重启</p>

<p>树莓派上有两个串口，一个硬件串口，工作稳定，但是分配给了蓝牙；还有一个“mini-uart”，这个串口的时钟是由内核提供，所以不太稳定  。
在树莓派3B上，蓝牙和硬件串口是不能兼得的。<br />
这个链接(<a href="http://ukonline2000.com/?p=880">http://ukonline2000.com/?p=880</a>)有介绍如何把硬件串口分配到GPIO14、GPIO15上，这里不做介绍了。</p>

<p>总之，在树莓派3B上，想要使用板载硬件串口是比较麻烦的，我们这里使用的是USB转串口模块，也能很方便地使用串口。</p>

<p>pypi库没有提供串口操作函数，我们使用串口的思路是通过linux上层通用的串口接口。</p>

<h2 id="pythonpyserial">python通用串口库——pyserial</h2>

<p>这里介绍的是第三方库 pyserial 的安装和使用。<br />
ubuntu、mac和树莓派上，只要安装了python都可以用此方法操作串口。</p>

<p>官网：<a href="http://pyserial.sourceforge.net/">http://pyserial.sourceforge.net/</a><br />
github主页：<a href="https://github.com/pyserial/pyserial">https://github.com/pyserial/pyserial</a></p>

<h3 id="section-1">一、安装</h3>

<p>网上有很多pip安装的方法，但那些好像都是针对python2的，python3安装不了，正确方法如下：<br />
<strong>mac下也可以用这种方法安装，但mac需要先安装驱动，我用的是PL2303，从官网下载的驱动，安装完成后的节点是 /dev/tty.usbserial。</strong></p>

<p>1、从github clone代码<br />
<strong>git clone git@github.com:pyserial/pyserial.git</strong></p>

<p>2、进入安装目录安装<br />
<strong>sudo python3 setup.py install</strong><br />
（在mac下安装不用sudo权限也行）</p>

<p>3、python3中import模块<br />
<strong>import serial</strong><br />
如果没有安装成功的话 import 会报错。</p>

<h3 id="section-2">二、使用</h3>

<p>首先要 <strong>import serial</strong></p>

<h4 id="section-3">1、打开串口并创建对象</h4>

<p><strong>[串口对象] = serial.Serial(‘[串口设备文件]’,<br />
              baudrate=[波特率],<br />
              bytesize=[数据位],<br />
              parity=’[校验]’,<br />
              stopbits=[停止位],<br />
              timeout=[timeout])</strong></p>

<ul>
  <li>串口设备文件就是/dev/目录下的设备文件，传入的是一个字符串，比如 ‘/dev/ttyUSB0’。</li>
  <li>budrate是波特率，<strong>传入的是数值</strong>。可以选择：<br />
2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</li>
  <li>bytesize是数据位，<strong>传入的是数值</strong>。<br />
可以省略，默认是8。</li>
  <li>parity是校验，传入的是字符串。可以设置为：<br />
<strong>‘N’    不校验<br />
‘O’    奇校验（ODD）<br />
‘E’    偶校验（EVEN）</strong><br />
可以省略，默认是’N’。</li>
  <li>stopbits是停止位个数，<strong>传入的是数值</strong>，一般都是设成1。<br />
可以生录入，默认是1。</li>
  <li>timeout是超时等待，在接收数据时，如果接收到的字符不满足返回条件则会等待，超时后返回。</li>
</ul>

<p>  例1，指明所有参数：<br />
  <em>ser = serial.Serial(‘/dev/ttyUSB1’,<br />
           baudrate=9600,<br />
           bytesize=8,<br />
           parity=’N’,<br />
           stopbits=1,<br />
           timeout=3)</em><br />
  例2，只指定某些参数：<br />
  <em>ser = serial.Serial(‘/dev/ttyUSB1’, 9600, timeout=3)</em></p>

<h4 id="section-4">2、缓冲区操作</h4>

<p>  python对串口接收数据和单片机有所不同。<br />
  单片机接收到数据后会产生中断，然后在中断中处理数据。<br />
  <strong>python是不会产生串口中断的，接收到的数据会存放在缓冲区，然后python程序主动检查缓冲区读取数据。</strong>读取数据方法也有多种。<br />
  <strong>每次新打开一个串口，之前的缓冲区就会被清空。</strong><br />
  缓冲区有输入缓冲区和输出缓冲区。<br />
  缓冲区的大小是：</p>

<p>  <strong>[串口对象].flushInput()</strong><br />
  清除接收缓冲区，放弃接收到的所有内容。<br />
  <strong>[串口对象].flushOutput()</strong><br />
  清除发送缓冲区，放弃输出。</p>

<p>  <strong>[串口对象].inWaiting()</strong><br />
  【功能】获取缓冲区里的字节数。<br />
  【输出】返回一个数值，代表缓冲区里有多少数据。</p>

<h4 id="section-5">3、波特率设置</h4>

<p>  <strong>[串口对象].setBaudrate([波特率])</strong><br />
  设置已经打开的串口的波特率，传入的是数值，可以选择：<br />
  2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</p>

<h4 id="section-6">4、从串口发送数据</h4>

<p>  <strong>[串口对象].write([单字节数组])</strong><br />
  <strong>发送的数据必须是单字节数据</strong>，可以是单字节组成的list，也可以是单字节编码的字符串（如ASCII、UTF-8）。
  返回的是写入的字节数。<br />
  例1，发送16进制数据：<br />
  <em>list1 = [0x01,0x02,0x03,0x10]<br />
  ser.write(list1)</em><br />
  会把这几个16进制数依次通过串口发出，另一端会接收到一模一样的数据。<br />
  例2，发送单字节编码的字符串：<br />
  <em>ser.write(b’abcdefg’)</em><br />
  把字符串’abcdefg’的ascii码发出，另一端收到：0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67。</p>

<h4 id="section-7">5、从串口接收数据</h4>

<p>  <strong>[串口对象].read([长度])</strong><br />
  【功能】从缓冲区读取指定长度内容。<br />
  【输入】<br />
  [长度] 是一个数值，代表要从缓冲区读取的字节数。<br />
  这个参数可以省略，默认是1。<br />
  【输出】输出的是一连串单字节数据。<br />
  【说明】<strong>如果缓冲区内容小于读取的长度则会等待，直到timeout后读取仅有的全部内容返回。</strong></p>

<p>  <strong>[串口对象].readall()</strong><br />
  【功能】读取缓冲区的所有数据。<br />
  【输出】输出的是一连串单字节数据。<br />
  <strong>这个函数必然会等待一个timeout时间，把之前缓冲区里所有内容和等待阶段接收到的所有内容读出。</strong></p>

<p>  <strong>[串口对象].readline()</strong><br />
  【功能】从缓冲区里读取一行。<br />
  【输出】输出的是一连串单字节数据。<br />
  【说明】<br />
  读取时会找到第一个’\n’结束，如果缓冲区里的数据没有’\n’，则会等待，知道timeout后返回仅有的所有内容。</p>

<h4 id="section-8">6、关闭串口</h4>

<p>  <strong>[串口对象].close()</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-GPIO]]></title>
    <link href="http://nicekwell.net/blog/20171119/shu-mei-pai-pypi-gpio.html"/>
    <updated>2017-11-19T22:44:47+08:00</updated>
    <id>http://nicekwell.net/blog/20171119/shu-mei-pai-pypi-gpio</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1、导入模块</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2、设置引脚排列方式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3、设置某个引脚的输入输出</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4、输入</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">5、输出</a></li>
  <li><a href="#pythongpio" id="markdown-toc-pythongpio">python控制GPIO的速度</a></li>
</ul>
<p>  </p>

<!-- more -->

<h3 id="section">1、导入模块</h3>

<p><strong>import RPi.GPIO as GPIO</strong></p>

<h3 id="section-1">2、设置引脚排列方式</h3>

<p>1、主板编号方式<br />
<strong>GPIO.setmode(GPIO.BOARD)</strong><br />
就是按照主板的引脚顺序：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/1.png" alt="1.png" /><br />
注意有些引脚是没有GPIO功能的，这些引脚仍然为它们分配了序号，但控制时使用这些非GPIO的序号是会报错的。</p>

<p>2、BCM编号方式<br />
<strong>GPIO.setmode(GPIO.BCM)</strong><br />
按照BCM方式编号。<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/2.jpg" alt="2.jpg" /></p>

<h3 id="section-2">3、设置某个引脚的输入输出</h3>

<p><strong>GPIO.setup([gpio], GPIO.[dir])</strong><br />
[GPIO]是一个引脚的序号，按照上面的编号方式决定。<br />
GPIO.[dir]是方向，可以设置：</p>

<table>
  <tbody>
    <tr>
      <td><strong>GPIO.IN</strong></td>
      <td>输入</td>
    </tr>
    <tr>
      <td><strong>GPIO.OUT</strong></td>
      <td>输出</td>
    </tr>
  </tbody>
</table>

<p>同时设置多个通道：<br />
<strong>chan_list = [[gpio1], [gpio2], …]</strong><br />
<strong>GPIO.setup(chan_list, GPIO_[dir]]</strong></p>

<h3 id="section-3">4、输入</h3>

<p><strong>GPIO.input([gpio])</strong><br />
获取指定通道的电平，返回的是一个数值，0或1。</p>

<h3 id="section-4">5、输出</h3>

<p>单通道输出：<br />
<strong>GPIO.output([gpio], GPIO.[level])</strong><br />
[gpio]是一个引脚的序号，按照上面的编号方式决定。<br />
GPIO.[level]是引脚的电平：</p>

<table>
  <tbody>
    <tr>
      <td><strong>GPIO.LOW</strong></td>
      <td>低电平</td>
    </tr>
    <tr>
      <td><strong>GPIO.HIGH</strong></td>
      <td>高电平（3.3v）</td>
    </tr>
  </tbody>
</table>

<p>同时设置多通道输出：<br />
<strong>chan_list = [[gpio1], [gpio2], …]</strong><br />
<strong>GPIO.output(chan_list, (GPIO.HIGH, GPIO.LOW, …))</strong><br />
第一个参数是list，第二个参数是tuple。</p>

<h3 id="pythongpio">python控制GPIO的速度</h3>

<p>设置python控制一个GPIO循环输出高低电平（不加延时），波形如下：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/3.png" alt="3.png" /></p>

<p>高低电平切换响应速度大约2us。<br />
但是注意，<strong>由于python是在上层运行的，所以波形输出不太稳定</strong>，上面是最理想的状态，实际上程序会受到影响，波形输出不稳定。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-说明和安装]]></title>
    <link href="http://nicekwell.net/blog/20171116/shu-mei-pai-pypi-shuo-ming-he-an-zhuang.html"/>
    <updated>2017-11-16T15:44:09+08:00</updated>
    <id>http://nicekwell.net/blog/20171116/shu-mei-pai-pypi-shuo-ming-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">安装</a></li>
</ul>
<p>  </p>

<p>这个库完整的名字是raspberry-gpio-python，通过这个库可以方便地用python操作树莓派的GPIO，但没有提供SPI、i2c等操作接口。</p>

<!-- more -->

<h3 id="section">安装</h3>

<ul>
  <li>
    <p>1、安装python3<br />
<strong>sudo apt-get install python-dev python3-dev</strong></p>
  </li>
  <li>
    <p>2、下载pypi库:<br />
官方下载：<a href="https://pypi.python.org/pypi/RPi.GPIO">https://pypi.python.org/pypi/RPi.GPIO</a></p>
  </li>
  <li>
    <p>3、放到树莓派里，解压<br />
<strong>tar zxvf RPi.GPIO-0.6.2.tar.gz</strong></p>
  </li>
  <li>
    <p>4、进入解压后的目录，执行安装<br />
<strong>sudo python3 setup.py install</strong><br />
可参考解压后目录中的INSTALL.txt文档说明。</p>
  </li>
</ul>

<p>安装成功后就可以使用 RPi.GPIO模块了。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-硬件和功能-功耗]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-gong-hao.html"/>
    <updated>2017-11-15T20:37:34+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-gong-hao</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p>3代B型：</p>

<table>
  <tbody>
    <tr>
      <td>几乎0%使用</td>
      <td>270mA</td>
    </tr>
    <tr>
      <td>单核100%</td>
      <td>320mA，每隔几秒跳一次400mA</td>
    </tr>
    <tr>
      <td>双核100%</td>
      <td>360mA，每隔几秒跳一次510mA</td>
    </tr>
    <tr>
      <td>三个100%</td>
      <td>410mA，每隔几秒跳一次630mA</td>
    </tr>
    <tr>
      <td>四核100%</td>
      <td>460mA，每隔几秒跳一次760mA</td>
    </tr>
  </tbody>
</table>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-硬件和功能-硬件和功能]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng.html"/>
    <updated>2017-11-15T20:25:20+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p><strong>树莓派引脚电平是3.3V。</strong></p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/1.png" alt="1.png" /></p>

<p>关于引脚的编号，不同的库会有不同的编号：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/2.jpg" alt="2.jpg" /></p>

<p>老的树莓派1代引脚如下：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/3.png" alt="3.png" /></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-概述和使用-配置和使用]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong.html"/>
    <updated>2017-11-15T19:52:47+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#ssh" id="markdown-toc-ssh">打开ssh</a></li>
  <li><a href="#section" id="markdown-toc-section">树莓派配置命令</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">默认用户</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">修改主机名</a></li>
  <li><a href="#sd" id="markdown-toc-sd">扩展sd卡空间</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">更新源</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">设置时区</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">支持中文</a></li>
</ul>
<p>  </p>

<p>本文介绍树莓派的常用设置，经常是一些开机后必须设置的项目。</p>

<!-- more -->

<h3 id="ssh">打开ssh</h3>

<p>第一次开机网络都没配置，这一步肯定要连接显示器才能配置的。</p>

<p>从2016.11.25开始，树莓派默认关闭ssh，导致不能远程登陆，需要手动开启ssh功能，方法是在 /boot/ 分区下建立一个名为“ssh的空文件。<br />
方法1：在树莓派上直接打开ssh：<strong>sudo touch /boot/ssh</strong><br />
方法2：在电脑上打开ssh：插入sd卡后有个boot分区，在里面创建一个名为“ssh”的文件<br />
树莓派重启后会删掉此文件，但已经可以使用ssh登陆了。</p>

<h3 id="section">树莓派配置命令</h3>

<p>打开命令行，用 <strong>sudo raspi-config</strong> 命令可开启树莓派配置程序。</p>

<h3 id="section-1">默认用户</h3>

<p>pi@raspberrypi，密码 raspberry。</p>

<h3 id="section-2">修改主机名</h3>

<p>多个树莓派分不清，可以修改主机名称区分。<br />
sudo raspi-config –&gt; 9 Advanced Options –&gt; A2 Hostname<br />
2017年stretch新版设置路径是：<br />
sudo raspi-config –&gt;2 Hostname</p>

<h3 id="sd">扩展sd卡空间</h3>
<p>2017年stretch已经不需要此步骤了，老的版本需要执行以下操作后才能使用全部sd卡空间。</p>

<p>安装好系统后默认的系统空间很小，几乎仅能放下系统，而sd卡有很多空间没有用到：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/1.png" alt="1.png" /><br />
使用 raspi-config 的“Expand Filesystem”功能可以把sd卡的全部空间用起：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/2.png" alt="2.png" /><br />
此修改需要重启树莓派，重启之后：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/3.png" alt="3.png" /></p>

<h3 id="section-3">更新源</h3>

<p>使用不同的 raspbian 版本，对应的更新源是不一样的，可以从网上查找。<br />
stretch版本的源：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi  
</span><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span></code></pre></td></tr></table></div></figure>

<p>修改方法和ubuntu、debian相同：<br />
1、修改 /etc/source.list 文件<br />
2、sudo apt-get update</p>

<h3 id="section-4">设置时区</h3>

<p>网上找到的linux下通用设置方法 tzselect 设置无效，最后用 raspi-config 设置完成：<br />
sudo raspi-config –&gt; 5 Internationalisation … –&gt; I2 Change Timezone –&gt; Asia –&gt; ShangHai –&gt; OK<br />
2017年stretch版本设置路径：<br />
sudo raspi-config –&gt; 4 Localisation Options –&gt; I2 Change Timezone –&gt; Asia –&gt; ShangHai –&gt; OK</p>

<h3 id="section-5">支持中文</h3>

<p>2017年stretch版本已经不需要设置了。</p>

<p>默认的命令行不支持中文，git log查看提交记录都不能显示中文。修改方法：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">pi@raspberrypi:~$ sudo apt-get install ttf-wqy-zenhei  #安装字体
</span><span class="line">pi@raspberrypi:~$ sudo fc-cache       #刷新字库缓存
</span><span class="line">pi@raspberrypi:~$ sudo dpkg-reconfigure locales        #字体配置</span></code></pre></td></tr></table></div></figure>
<p>然后用上下方向键选中以下5项：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">en-GB.UTF-8 UTF-8
</span><span class="line">zh_CN.GB2312
</span><span class="line">zh.CN.GB18030 GB18030
</span><span class="line">zh_CN.GBK GBK
</span><span class="line">zh_CN.UTF-8 UTF-8</span></code></pre></td></tr></table></div></figure>
<p>选中后回车，会让你选择默认的字体，<br />
  如果想要系统语言是中文，则选择“zh_CN.UTF-8 UTF-8 ”回车<br />
  如果想要系统语言是英文，则选择“en_GB.UTF-8”回车。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-概述和使用-下载和安装]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang.html"/>
    <updated>2017-11-15T19:22:54+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">下载镜像</a></li>
  <li><a href="#mac" id="markdown-toc-mac">mac下安装</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">启动树莓派</a></li>
</ul>
<p>  </p>

<p>本文介绍如何下载树莓派镜像，并安装到sd卡，实现开机。</p>

<!-- more -->

<h3 id="section">下载镜像</h3>

<p>官网：<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a><br />
下载页面：<a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br />
推荐下载raspbian：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/1.png" alt="1.png" /></p>

<p>这是基于debian jessie的系统，有Full desktop版本和Minimal版本：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/2.png" alt="2.png" /><br />
full desktop版本有图形界面；Minimal版本没有图形界面，是精简版。<br />
由于后面要配置网络等配置项，用图形界面会方便很多，推荐使用不带LITE的desktop版。</p>

<h3 id="mac">mac下安装</h3>

<ul>
  <li>
    <p><strong>1、不插入sd卡查看当前磁盘情况</strong>
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/3.png" alt="3.png" /></p>
  </li>
  <li>
    <p><strong>2、插入sd卡查看当前磁盘情况</strong>
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/4.png" alt="4.png" /><br />
多出来的 /dev/disk2s1 就是sd卡的分区。</p>
  </li>
  <li>
    <p><strong>3、卸载这个分区</strong><br />
<strong>diskutil unmount /dev/[disk*s*]</strong><br />
卸载是为了待会写入这个分区时不会被其他程序的读写干扰。<br />
卸载之后可以通过  diskutil list 命令查看设备：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/5.png" alt="5.png" /><br />
可以看到我们的sd卡对应的设备是 /dev/disk2。</p>
  </li>
  <li>
    <p><strong>4、使用dd命令写入镜像</strong><br />
<strong>sudo dd bs=4m if=[镜像].img of=/dev/<code>[磁盘的字符设备]</code></strong><br />
注意，磁盘的字符设备是 r 开头的，网上有个说法：/dev/disk2s1是分区，/dev/disk2是块设备，/dev/rdisk2是原始字符设备。<br />
由于文件很大，写入过程会比较长。成功之后会显示如下界面：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/6.png" alt="6.png" /></p>
  </li>
  <li>
    <p><strong>5、卸载sd卡设备</strong><br />
<strong>diskutil unmountDisk /dev/[disk*]</strong><br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/7.png" alt="7.png" /></p>
  </li>
</ul>

<p>ubuntu下安装步骤和mac下类似，由于没有实际操作过，这里不介绍ubuntu下的安装。</p>

<h3 id="section-1">启动树莓派</h3>

<p>安装好之后把sd卡插在树莓派上，接通电源即可启动。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[把已有的repo工程提交到服务器]]></title>
    <link href="http://nicekwell.net/blog/20171112/ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi.html"/>
    <updated>2017-11-12T23:19:32+08:00</updated>
    <id>http://nicekwell.net/blog/20171112/ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、基础知识</a>    <ul>
      <li><a href="#git" id="markdown-toc-git">1、git</a></li>
      <li><a href="#repo" id="markdown-toc-repo">2、repo</a></li>
      <li><a href="#manifestxml" id="markdown-toc-manifestxml">3、manifest.xml文件</a></li>
    </ul>
  </li>
  <li><a href="#repo-1" id="markdown-toc-repo-1">二、把已有的repo工程提交到自己的服务器</a>    <ul>
      <li><a href="#python3" id="markdown-toc-python3">1、客户端和服务端都安装python3</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">2、客户端准备一个干净的工程</a></li>
      <li><a href="#manifestgit" id="markdown-toc-manifestgit">3、服务器端创建manifest.git工程</a></li>
      <li><a href="#manifestxml-1" id="markdown-toc-manifestxml-1">4、客户端修改并上传manifest.xml文件</a></li>
      <li><a href="#manifestxml-2" id="markdown-toc-manifestxml-2">5、服务端分析manifest.xml文件，批量创建工程</a></li>
      <li><a href="#manifestxml-3" id="markdown-toc-manifestxml-3">6、客户端分析manifest.xml文件，批量上传到服务器</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">7、测试</a></li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>  repo是google开发的工具，用来管理多个git工程，最常用在Android源码管理上。<br />
  本文介绍的是如何把一个已有的repo工程提交到自己的服务器，在自己的服务器上管理这些源代码，同时保留原来repo组织这些代码仓库的结构。</p>

<!-- more -->

<h1 id="section">一、基础知识</h1>

<h2 id="git">1、git</h2>

<p>  git的详细使用方法这里不介绍，这里只要知道git服务器端建立git仓库的命令：<br />
   <code>git init --bare [仓库名].git</code></p>

<p>  而客户端创建工程、关联远程仓库、第一次提交的方法是：<br />
  <strong>创建工程：</strong><br />
  git init<br />
  <strong>关联远程仓库：</strong><br />
  git remote add origin [远程仓库地址]<br />
  <strong>第一次提交：</strong><br />
  git push -u origin master</p>

<h2 id="repo">2、repo</h2>

<p>  repo的详细使用方法这里也不介绍，repo要用到的命令有：</p>

<p>  <strong>repo init -u [manifest仓库地址]</strong><br />
  初始化repo工程，会把manifest.git仓库拖下来。<br />
  我们搭建好自己的repo服务器后，也可以使用此命令拖下来自己的repo仓库。</p>

<p>  <strong>repo sync</strong><br />
  同步代码。<br />
  搭建好自己的服务器后，用此命令同步时将会从自己的repo仓库同步代码。</p>

<h2 id="manifestxml">3、manifest.xml文件</h2>

<p>  这个文件要好好介绍一下，我们将会对这个文件进行解析，解析出各个git仓库的服务器地址、本地路径，并根据解析的结果创建和同步这些git仓库代码。</p>

<p><strong>1、开头会定义remote</strong></p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/1.png" alt="1.png" /><br />
  可以设置多个remote地址，用后面的name区分。<br />
  后面可以选择使用哪一个remote地址。</p>

<p><strong>2、指定默认参数</strong></p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/2.png" alt="2.png" /><br />
   remote=””   来指定使用哪一个remote地址。<br />
   revision    指定分支，从remote地址拖工程时指定拖哪个分支。<br />
   sync -j      指定同步线程数</p>

<p><strong>3、后面一大堆内容都是指定远程工程路径，以及拖下来的位置</strong></p>

<p>  瑞芯微的文件：</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/3.png" alt="3.png" /></p>

<p>  android原生文件：</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/4.png" alt="4.png" /><br />
  path：本地相对路径，可以不指定，不指定的话表示和name相同。<br />
  name：远程相对与remote地址的路径。<br />
  version：<br />
  groups：<br />
  upstream：<br />
  这里的每个name就代表一个git子工程，整个android工程有很多个git子工程组成，这里指定了各个子工程相对于remote的路径、版本、拖下来后的本地路径。</p>

<h1 id="repo-1">二、把已有的repo工程提交到自己的服务器</h1>

<p>  从上面得知，各个子工程的远程和本地路径都保存在manifest.xml文件里，那么我们只要解析这个文件就能获取服务器端和本地的文件结构。<br />
  在服务器端解析manifes.xml文件，获取所有git工程的远程路径，在服务器端批量创建这些git工程；<br />
  本地解析manifest.xml文件，获取各个git工程的本地路径和远程路径，在本地初始化git工程，并关联、提交到远程。</p>

<h2 id="python3">1、客户端和服务端都安装python3</h2>

<p>  对于ubuntu：sudo apt-get install python3<br />
  后面的脚本基于python3。</p>

<h2 id="section-1">2、客户端准备一个干净的工程</h2>

<p>  客户端是一个已有的repo工程，先准备好干净的代码准备提交，执行以下步骤：</p>

<p>  1、<strong>.repo/repo/repo sync</strong><br />
  2、删掉所有的.git目录<br />
    <code>find . -name ".git" | xargx rm -rf</code><br />
    因为待会会重新初始化这些git工程，所以以前的git信息不需要了。<br />
  3、复制出.repo/manifest.xml文件，删除.repo目录<br />
    repo工程里都会有一个.repo目录，此目录不再需要，但manifest.xml文件记录的各个工程信息是我们需要的，后面会解析此文件，把这个文件复制出来找个地方放一下。</p>

<h2 id="manifestgit">3、服务器端创建manifest.git工程</h2>

<p>  每个repo工程都会有一个 manifest.git 工程，此工程内容就是 manifest.xml 文件，manifest.xml文件记录了各个git子工程的信息。<br />
  我们在服务器创建一个 manifest.git 工程就是用于存放我们自己的 repo 工程的manifest.xml文件。<br />
  一般放在大工程目录下。</p>

<p>  <code>git init --bare /home/git/[工程目录]/manifest.git</code></p>

<h2 id="manifestxml-1">4、客户端修改并上传manifest.xml文件</h2>

<p>  1、把刚刚创建的manifest.git工程拖下来<br />
    <strong>git clone git@[ip]:[proj]/manifest.git</strong></p>

<p>  2、把已有的repo工程里的manifest.xml文件复制过来，并重命名为default.xml<br />
    就是前面删除本地.repo目录时备份的manifest.xml文件。</p>

<p>  3、修改default.xml里面的remote地址，改成新的服务器地址，分支改成master</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/5.png" alt="5.png" /></p>

<p>    注意地址格式写法，只有最后一行的写法是正确的。<br />
    添加新地址后，后面的default配置也要改，remote改成新添加的地址，revision改成master（我们将要保存的分支是master）。</p>

<p>  4、用脚本去掉default.xml里面的version等信息<br />
    默认的xml文件的工程可能带有一些remote、version信息，以后我们放在服务器都是在服务器的master上，这些信息需要清除。</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/6.png" alt="6.png" /></p>

<p>    用这个脚本：<a href="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/del_remote_version.py">del_remote_version.py</a></p>

<p>    把这个脚本复制到manifest.git工程目录，然后执行这个脚本：<br />
    <strong>./del_remote_version.py default.xml</strong></p>

<p>    此脚本会查找default.xml文件中的 remote、revision、upstream信息，并删除。执行后文件如下：</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/7.png" alt="7.png" /></p>

<p>  5、提交manifest工程<br />
    只需要提交default.xml文件即可，脚本不需要提交。</p>

<h2 id="manifestxml-2">5、服务端分析manifest.xml文件，批量创建工程</h2>

<p>  获取到manifest.xml文件的所有name信息（代表所有git子工程），然后用脚本批量创建git工程。</p>

<p>  1、把上面的default.xml文件用scp上传到服务端，放到工程目录下。<br />
  2、进入大工程目录，用 getnames_and_create_project.py 脚本分析 default.xml文件，并创建工程：<br />
    用这个脚本：<a href="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/getnames_and_create_project.py">getnames_and_create_project.py</a></p>

<p>    <strong>./getnames_and_create_project.py default.xml</strong></p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/8.png" alt="8.png" /></p>

<p>    脚本执行完成后会新建很多目录出来：</p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/9.png" alt="9.png" /></p>

<h2 id="manifestxml-3">6、客户端分析manifest.xml文件，批量上传到服务器</h2>

<p>  刚刚在服务器上已经创建好了各个git子工程，这里把它们上传。<br />
  分析manifest.xml文件，获取到所有name信息（代表所有git子工程），然后用脚本批量上传git子工程。</p>

<p>  1、进入上面创建好的干净的工程目录，把上面建立好的default.xml文件复制到这里。<br />
  2、把客户端的id_rsa.pub加入到服务端的 authorized_keys里。<br />
  3、进入大工程目录，客制化以下脚本：<br />
    <a href="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/getnames_and_init_push_git_proj.py">getnames_and_init_push_git_proj.py</a></p>

<p><img src="http://nicekwell.net/images/network-programming-and-server/2017-11-12-ba-yi-you-de-repogong-cheng-ti-jiao-dao-fu-wu-qi/10.png" alt="10.png" /></p>

<p>    修改这里的远程地址，后面会把工程提交到这里。<br />
    这里的地址应当和上面服务器端建立工程的地址相同。</p>

<p>  4、运行脚本</p>

<p>    <strong>./getnames_and_init_push_git_proj.py default.xml</strong><br />
    此脚本会解析default.xml里的name和path，<br />
    会先分析本地path是否为空目录，如果是空目录的话则会创建一个“.gitignore”文件，防止空目录提交失。<br />
    然后初始化本地path路径的代码，作为git工程提交到服务器端的name指定路径下。</p>

<h2 id="section-2">7、测试</h2>

<p>  找一个干净的地方，用 <strong>repo init -u [服务端manifest.git地址]</strong>，<br />
  然后 <strong>repo sync</strong>，此时应该可以同步所有git子工程。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-内核开发-说明 下载代码 编译 替换内核]]></title>
    <link href="http://nicekwell.net/blog/20171108/shu-mei-pai-nei-he-kai-fa-shuo-ming-xia-zai-dai-ma-bian-yi-ti-huan-nei-he.html"/>
    <updated>2017-11-08T19:21:11+08:00</updated>
    <id>http://nicekwell.net/blog/20171108/shu-mei-pai-nei-he-kai-fa-shuo-ming-xia-zai-dai-ma-bian-yi-ti-huan-nei-he</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、概述</a></li>
  <li><a href="#ubuntu" id="markdown-toc-ubuntu">二、ubuntu里交叉编译</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1、获取交叉编译工具和源码</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">2、配置编译环境变量</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">2.1 手动配置环境变量</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">2.2 自动配置环境变量</a></li>
        </ul>
      </li>
      <li><a href="#config" id="markdown-toc-config">3、配置config</a>        <ul>
          <li><a href="#config-1" id="markdown-toc-config-1">3.1 使用源码里自带的config</a></li>
          <li><a href="#config-2" id="markdown-toc-config-2">3.2 获取当前树莓派的config</a></li>
        </ul>
      </li>
      <li><a href="#section-5" id="markdown-toc-section-5">4、编译</a></li>
      <li><a href="#sddirectly-sd" id="markdown-toc-sddirectly-sd">5、挂载树莓派sd卡，并安装编译出的DIRECTLY 到sd卡</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">三、树莓派本地编译</a>    <ul>
      <li><a href="#section-7" id="markdown-toc-section-7">1、获取源码</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">2、配置编译环境</a></li>
      <li><a href="#config-3" id="markdown-toc-config-3">3、配置config</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">4、编译</a></li>
      <li><a href="#section-10" id="markdown-toc-section-10">5、更新系统</a></li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>树莓派运行linux系统，内核代码开源，我们可以自己修改内核代码、编写驱动。</p>

<p>本文介绍如何获取linux内核代码，并完成编译、内核替换。</p>

<!-- more -->

<h1 id="section">一、概述</h1>

<p>树莓派的github主页：<a href="https://github.com/raspberrypi">https://github.com/raspberrypi</a>，里面包含了linux源码、交叉编译工具链等内容。</p>

<p>对于我们要用到的有两个仓库：</p>

<p><a href="https://github.com/raspberrypi/linux">https://github.com/raspberrypi/linux</a> 内核源码</p>

<p><a href="https://github.com/raspberrypi/tools">https://github.com/raspberrypi/tools</a> 交叉编译工具链（仅在交叉编译时用到）</p>

<p>注：<br />
1、树莓派里安装的系统镜像版本要和kernel代码对应。因为树莓派系统是在不断开发和升级的，如果你的树莓派使用的是某个时间的系统镜像，那么最好也使用当时的kernel代码。<br />
2、关于内核编译方法，官网有很详细的介绍：<a href="https://www.raspberrypi.org/documentation/linux/kernel/building.md">https://www.raspberrypi.org/documentation/linux/kernel/building.md</a>，这里算是翻译和补充。<br />
3、以下编译过程在树莓派1和树莓派3B上测试ok。</p>

<h1 id="ubuntu">二、ubuntu里交叉编译</h1>

<h2 id="section-1">1、获取交叉编译工具和源码</h2>

<p>源码：<strong>git clone git@github.com:raspberrypi/linux</strong></p>

<p>交叉编译工具：<strong>git clone git@github.com:raspberrypi/tools</strong></p>

<h2 id="section-2">2、配置编译环境变量</h2>

<h3 id="section-3">2.1 手动配置环境变量</h3>

<p>编译工具下载后，在64位ubuntu上编译我们需要的编译工具bin文件在：tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin 目录下，将此目录添加到环境变量PATH中，添加方法：</p>

<p><strong>PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</strong></p>

<p>如果是在32位系统中编译则要选择32位的交叉编译工具。</p>

<p>配置完成之后可以用编译工具命令查看到版本号：<br />
arm-linux-gnueabihf-gcc -v</p>

<p>之后，所有的make命令都要指明一些环境变量：<br />
<strong>ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7</strong></p>

<table>
  <tbody>
    <tr>
      <td>ARCH=arm</td>
      <td>指明当前要编译arm，虽然树莓派是64位的，这里仍然选择arm，而不是arm64。</td>
    </tr>
    <tr>
      <td>CROSS_COMPILE</td>
      <td>指明交叉工具链名称。</td>
    </tr>
    <tr>
      <td>KERNEL</td>
      <td>指明kernel类型，<strong>树莓派1设置为kernel，树莓派2、3设置为kernel7。</strong></td>
    </tr>
  </tbody>
</table>

<p>每次make都需要指明这些环境变量，如：<br />
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig<br />
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage</p>

<h3 id="section-4">2.2 自动配置环境变量</h3>

<p>上面这些环境变量每次命令都要写很麻烦，可以通过export一次设置：<br />
 export PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7<br />
之后在本终端里执行的所有命令都带有这些环境变量信息。</p>

<p>此 export 命令可以写成一个脚本，然后在编译前在终端里source一下这个脚本即可设置好所有的环境变量。就像android编译前也要先source一下envsetup.sh一样。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c">#!/bin/bash</span>
</span><span class="line"><span class="nv">DIR</span><span class="o">=</span><span class="s2">&quot;$( cd &quot;</span><span class="k">$(</span> dirname <span class="s2">&quot;${BASH_SOURCE[0]}&quot;</span> <span class="k">)</span><span class="s2">&quot; &amp;&amp; pwd )&quot;</span>
</span><span class="line"><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;$PATH:$DIR/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/&quot;</span>
</span><span class="line"><span class="nb">export </span><span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- <span class="nv">KERNEL</span><span class="o">=</span>kernel7
</span></code></pre></td></tr></table></div></figure>

<p>上述命令中的路径可能和你实际不同，注意修改。</p>

<p>export环境变量后，在本终端里的后续命令都可以不用再指明这些环境变量，如：<br />
配置之前的命令：ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig<br />
配置之后的命令：make menuconfig</p>

<h2 id="config">3、配置config</h2>

<p>linux源码中有很多工程：<br />
树莓派1的工程是<strong>bcmrpi_defconfig</strong>；<br />
树莓派2、3的工程是<strong>bcm2709_defconfig</strong>。</p>

<h3 id="config-1">3.1 使用源码里自带的config</h3>

<p>ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make bcm2709_defconfig</p>

<p>此命令功能是获取bcm2709_defconfig的配置到 .config里。<br />
我们可以直接用工程里的配置，但这样的话可能会丢失原来使用的树莓派的配置，这里提供一个方法可以获取当前正在使用的树莓派的config。</p>

<h3 id="config-2">3.2 获取当前树莓派的config</h3>

<p>已经开机的树莓派上会有这个节点：<strong>/proc/config.gz</strong>，从这个节点可以获取本树莓派的config。<br />
如果没有这个节点的话则需要先加载模块：<strong>sudo modprobe configs</strong></p>

<p>把 config.gz 内容复制到要编译的电脑上：<br />
scp pi@[ip]:/proc/config.gz .</p>

<p>解压，保存为.confg文件。<br />
zcat config.gz &gt; .config<br />
注：必须在linux环境下解压，在mac下会乱码。</p>

<p>把此config文件复制到linux源码的根目录。</p>

<h2 id="section-5">4、编译</h2>

<p>安装必要的库：<br />
sudo apt-get install bc<br />
sudo apt-get install libncurses5-dev libncursesw5-dev<br />
sudo apt-get install zlib1g:i386<br />
sudo apt-get install libc6-i386 lib32stdc++6 lib32gcc1 lib32ncurses5</p>

<p><strong>1、执行menuconfig</strong><br />
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 <strong>make menuconfig</strong><br />
如果没什么改的就不用执行这一步。</p>

<p><strong>2、编译</strong><br />
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 <strong>make -j4 zImage modules dtbs</strong> 2&gt;&amp;1 | tee build.log<br />
以n进程编译。不指明几进程的话则默认以单进程编译。</p>

<p><strong>3、打包zImage文件</strong><br />
直接用linux源码包里的工具：<br />
./scripts/mkknlimg arch/arm/boot/zImage ./kernel_new.img<br />
在本目录生成一个kernel_new.img文件，这个文件就是要放到sd卡中的文件。<br />
注：网上很多地方说的用 tools/mkimage/imagetool-uncompressd.py 的方法不行！！</p>

<h2 id="sddirectly-sd">5、挂载树莓派sd卡，并安装编译出的DIRECTLY 到sd卡</h2>

<p>把树莓派的sd卡插入ubuntu系统电脑，树莓派的sd卡有两个分区：<br />
一个fat分区，是boot相关的内容，kernel的img文件就放在这个分区里；<br />
一个是ext4分区，也就是系统的根目录分区。</p>

<p>我们生成的文件涉及到这两个分区的内容，一般插入ubuntu后会自动挂载，fat分区可以不用root权限操作，ext4分区需要root权限操作。<br />
两个分区具体挂载在什么地方可以自己决定，以下用[fat]表示boot挂载的路径，[ext4]表示ext4挂载的路径。</p>

<p><strong>1、安装modules</strong><br />
sudo ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make INSTALL_MOD_PATH=[ext4] modules_install<br />
操作ext4分区，需要root权限。</p>

<p><strong>2、更新 kernel.img 文件</strong><br />
前面已经用 mkknlimg 工具打包了kernel_new.img文件了，把它复制到boot分区并配置使用即可：<br />
cp kernel_new.img [fat]/<br />
编辑 [fat]/config.txt 文件，在最后加入一行：<br />
kernel=kernel_new.img</p>

<p><strong>3、复制其他相关文件</strong><br />
cp arch/arm/boot/dts/<em>.dtb [fat]/<br />
cp arch/arm/boot/dts/overlays/</em>.dtb* [fat]/overlays/<br />
cp arch/arm/boot/dts/overlays/README [fat]/overlays/</p>

<p>更新完成后插回树莓派即可开机，开机后可以用 uname -a 命令查看kernel信息已经改变。</p>

<h1 id="section-6">三、树莓派本地编译</h1>

<p>树莓派上本地编译和上面交叉编译原理基本相同，由于是本地编译，在编译工具和环境变量配置方面还简单一些。<br />
树莓派上编一次内核花了将近2小时。</p>

<h2 id="section-7">1、获取源码</h2>

<p>git clone git@github.com:raspberrypi/linux</p>

<h2 id="section-8">2、配置编译环境</h2>

<p>在ubuntu里交叉编译时需要配置的环境变量有：</p>

<ul>
  <li>PATH: 添加交叉工具链的目录</li>
  <li>ARCH: 配置成arm</li>
  <li>CROSS_COMPILE: 配置成ubuntu上使用的交叉工具链arm-linux-gnueabihf- KERNEL=kernel7</li>
  <li>KERNEL: 配置成kernel7</li>
</ul>

<p>而在树莓派本地编译：<br />
关于交叉工具链，本身的编译工具就可以编译给自己使用，所以不用配置；<br />
只需要配置 KERNEL=kernel7 即可。</p>

<p>和上面相同，可以用 export KERNEL=kernel7，一次设置之后此终端里所有命令都带有此环境变量。<br />
也可以更进一步写成脚本，不过这里这一行命令很简单，不写脚本也可以。</p>

<h2 id="config-3">3、配置config</h2>
<p>和上面一样，<br />
树莓派1使用的是 <strong>bcmrpi_defconfig</strong>，<br />
树莓派2、3使用的是 <strong>bcm2709_defconfig</strong>。<br />
例：KERNEL=kernel7 make bcm2709_defconfig</p>

<p>如果要使用树莓派自带的config的话：<br />
<strong>sudo modprobe configs</strong>    # 加载模块<br />
<strong>zcat config.gz &gt; .config</strong>      # 获取配置</p>

<h2 id="section-9">4、编译</h2>
<p>安装必要的库：<br />
sudo apt-get install bc<br />
sudo apt-get install libncurses5-dev libncursesw5-dev<br />
sudo apt-get install zlib1g<br />
sudo apt-get install libc6</p>

<p>1、执行menuconfig<br />
<strong>KERNEL=kernel7 make menuconfig</strong><br />
没什么要改的话就不用执行这一步。</p>

<p>2、编译<br />
<strong>KERNEL=kernel7 make -j4 zImage modules dtbs 2&gt;&amp;1 | tee build.log</strong><br />
以n进程编译。不指明几进程的话则默认以单进程编译。</p>

<p>3、打包zImage文件<br />
直接用linux源码包里的工具：<br />
<strong>./scripts/mkknlimg arch/arm/boot/zImage ./kernel_new.img</strong><br />
在本目录生成一个kernel_new.img文件，这个文件就是要放到sd卡中的文件。</p>

<h2 id="section-10">5、更新系统</h2>

<p>1、安装模块<br />
<strong>sudo make modules_install</strong></p>

<p>2、复制dtb文件<br />
<strong>sudo cp arch/arm/boot/dts/<em>.dtb /boot/
sudo cp arch/arm/boot/dts/overlays/</em>.dtb* /boot/overlays/
sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/</strong></p>

<p>3、更新kernel.img文件<br />
<strong>sudo cp arch/arm/boot/zImage /boot/$KERNEL.img</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈一谈单片机开发的几种调试方案]]></title>
    <link href="http://nicekwell.net/blog/20170411/tan-%5B%3F%5D-tan-dan-pian-ji-kai-fa-de-ji-chong-diao-shi-fang-an.html"/>
    <updated>2017-04-11T20:59:27+08:00</updated>
    <id>http://nicekwell.net/blog/20170411/tan-[?]-tan-dan-pian-ji-kai-fa-de-ji-chong-diao-shi-fang-an</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">我们做调试工具追求的是什么</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">几种调试方案</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">1、加入屏和按键</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">2、串口+上位机</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">3、用树莓派</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">4、串口+通用终端工具</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">如何构建终端工具里的控制台界面</a>    <ul>
      <li><a href="#section-7" id="markdown-toc-section-7">1、构建界面用到的特殊字符串</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">2、封装好的库函数</a></li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>单片机开发过程中，有一个好的调试系统可以极大地提高开发效率。<br />
举个例子，做平衡系统时调节PID参数，你会选择 修改参数–&gt;编译–&gt;烧录–&gt;运行–&gt;修改…，还是做一个功能可以一边运行一边修改参数呢？<br />
调试的方法有多种，在这就来分别谈一下我在开发过程中使用过的几种调试方案。<br />
这里的调试方案也是一种交互方案，但此方案不是为了交互而设计，重在快速地搭建、方便地使用、高效地调试，换句话说长得丑无所谓。</p>

<!-- more -->

<h1 id="section">我们做调试工具追求的是什么</h1>

<p>做调试系统无非是为了两点：</p>

<ol>
  <li>实时显示一些必要信息。</li>
  <li>实时修改，其实也就是可以实时接收指令。</li>
</ol>

<p>为了提高开发效率，我们进一步希望：</p>

<ol>
  <li>调试系统搭建起来方便快捷，最好可以统一标准，方便移植。<br />
我们不希望在调试系统上花费太多工作量，不要太复杂，尽量轻量级。</li>
  <li>直观显示，看得清楚。</li>
  <li>方便输入，操作快捷。</li>
</ol>

<h1 id="section-1">几种调试方案</h1>

<h2 id="section-2">1、加入屏和按键</h2>

<p><img src="http://nicekwell.net/images/misc/2017-04-12_1.jpg" alt="" /></p>

<p>最直接的方法就是在嵌入式系统中加入屏和按键，做出一个界面，显示信息和接收按键指令。<br />
【优点】跟随系统，不需要依赖其他设备，可以随时随地调试。</p>

<p>【缺点】</p>

<ol>
  <li>添加了硬件。硬件的设计和焊接还是需要花费一些精力的。</li>
  <li>构建界面同样也要花费不少精力。</li>
  <li>显示信息有限。<br />
加入的屏通常显示内容比较少，会受到一些限制。</li>
  <li>按键功能有限。<br />
加入的按键通常也不会太多，并且如果我们考虑到长按、组合键等操作的话构建程序也是比较复杂的。</li>
</ol>

<p>【总结】<br />
肯定不能算轻量级，功能有限，可移植性差，花费精力多，屏需要额外费用。<br />
唯一的优点就是跟随系统，没有其他依赖。</p>

<p>所以如果不是非要随时调试的话不建议用这种方法，单纯为了调试来说代价还是比较大的。</p>

<h2 id="section-3">2、串口+上位机</h2>

<p><img src="http://nicekwell.net/images/misc/2017-04-12_2.jpg" alt="" /></p>

<p>单片机自己不负责显示，它把数据发送出去，由上位机显示；也不负责按键检测，由上位机负责并接收上位机指令。<br />
单片机和上位机之间需规定好通信协议。</p>

<p>通信方式可以是串口也可以是其他，上位机可以是图形也可以是命令行。</p>

<p>【优点】</p>

<ol>
  <li>对单片机来说做到了一定的轻量级。只需要考虑发送数据和接收指令的协议。</li>
  <li>对于比较复杂的功能，好的上位机，尤其是图形化的上位机可以很方便地调试。</li>
</ol>

<p>【缺点】</p>

<ol>
  <li>需要设计通信协议，双方都要位通信协议写代码。这需要花费一定的精力。</li>
  <li>制作上位机需要花费较多的精力，并且上位机不通用。</li>
</ol>

<p>【总结】<br />
由于上位机在电脑上，有丰富的显示和控制资源，做出一个好的上位机可以极其方便地提高效率。<br />
但制作上位机要花费大量精力。</p>

<p>所以，如果上位机是作为产品发布，是值得花精力去做的；但如果仅仅是为了调试时用一下，不值得这样做。</p>

<p><strong>到这里有没有注意到，其实我们是想找到一个通用的”显示器”，能够方便地把信息显示出来。
显示器是已经做好的，不需要我们再做什么，通信协议尽可能简单，最好能直接输出。
后面我们会找到这么一个好东西。</strong></p>

<h2 id="section-4">3、用树莓派</h2>

<p><img src="http://nicekwell.net/images/misc/2017-04-12_3.jpg" alt="" /></p>

<p>用树莓派进行关键计算，我们关心的数据都在树莓派的程序里。<br />
由于树莓派里运行linux系统，在其连接网络后，我们可以用局域网里电脑的终端登陆树莓派，在树莓派的程序里直接打印接口显示出来。</p>

<p><em>注：<br />
在命令行下打印数据并不一定是一行一行地输出，也可以控制光标在指定位置输出，构建出一个简单的界面。这里不做介绍，具体可搜索”控制台编程”。<br />
命令行下接收键盘操作也不一定非要输入字符再回车，程序里可以直接监测键盘。<br />
总之在命令行中是可以构建出一个类似于 显示屏+按键 组合的”设备”的。</em></p>

<p>【优点】</p>

<ol>
  <li>终端就相当于是一个现成的、通用的显示屏，任意可登陆ssh的终端都可使用。</li>
  <li>程序里直接打印输出！这真是太方便的，c语言中一个printf即可，相当于是一个极其简单的通信协议。</li>
</ol>

<p>【缺点】</p>

<ol>
  <li>贵！一个小小的智能车都要塞个树莓派，树莓派价格都够好多个智能车了。</li>
  <li>树莓派本身是重量级。虽然程序本身是方便了，但使用之前需要配置树莓派，虽然一个树莓派只要配置一次。</li>
  <li>树莓派本身硬件功能有限，有些功能树莓派不能直接完成，还是需要借助单片机，并和单片机通信。<br />
比如记录车轮旋转的正交编码器，stm32有专门的硬件模块完成，树莓派没有，如果树莓派想要记录车轮旋转的话还是需要借助stm32，并且设计如何获取stm32记录的数据。</li>
</ol>

<p>【总结】</p>

<p>对于调试这一方面来说，树莓派是非常方便的，输出、输入都是直接完成。<br />
所以如果你的项目值得用树莓派，那调试是非常方便的；如果不需要用树莓派，光是为了调试方便而使用是不建议的，请考虑上面3个缺点。</p>

<p><strong>虽然树莓派本身不一定最合适，但我们找到了方向——终端。</strong></p>

<h2 id="section-5">4、串口+通用终端工具</h2>

<p>单片机能不能用终端呢？答案是肯定的。<br />
有多种终端工具可以通过串口使用，比如windows自带的超级终端，linux和osx下命令行里的minicom，以及夸三个平台的图形化终端secureCRT。<br />
这些终端工具的功能简单来说就是：1、当某个按键按下立刻发送该按键的键码出去，比如按下p键发送字符’p’。2、接收串口数据并显示出来。</p>

<p>说明：</p>

<ol>
  <li>这些终端工具的协议是相同的，可以认为是通用的显示器和键盘。</li>
  <li>单片机可以发送一些特殊字符串完成一些特殊操作，比如清屏、控制光标位置。利用这些功能可以构建出简单的界面。<br />
这些操作功能已经封装成了函数，会在本文后面给出。</li>
  <li>一般会先在单片机中实现printf功能，实现之后在程序中用printf即可直接在终端工具中显示信息。<br />
实现printf功能的方法在这里不介绍，具体可上网查找，工作量并不大。其实就是重定义一个函数，使printf函数通过指定串口输出字符串。</li>
  <li>串口通过蓝牙模块可快速实现无线传输。</li>
</ol>

<p>【优点】</p>

<ol>
  <li>单片机端轻量级，上位机端无工作量。<br />
具体来说单片机端要做的事情有：初始化串口，重定向printf，通过特殊字符串控制光标构建界面。</li>
  <li>上位机端通用，单片机端显示相关的代码方便移植。<br />
本文后文会给出显示相关的库函数。</li>
  <li>硬件扩展几乎没有。</li>
</ol>

<p>【缺点】</p>

<p>对比第1种方案，需要一台电脑。其他方面都具有很大优势。</p>

<p>【总结】</p>

<p>此方案是单片机开发调试的理想选择。</p>

<p>下面会介绍如何在终端工具里构建出界面。</p>

<h1 id="section-6">如何构建终端工具里的控制台界面</h1>

<h2 id="section-7">1、构建界面用到的特殊字符串</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">字符(串)</th>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">\r</td>
      <td style="text-align: center">光标移到行首</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">\b</td>
      <td style="text-align: center">退格</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[2J”</td>
      <td style="text-align: center">清屏</td>
      <td style="text-align: center"><strong>清屏后光标还在原来位置</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[2K]”</td>
      <td style="text-align: center">清除本行</td>
      <td style="text-align: center">清除后光标还在原来位置</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[H”</td>
      <td style="text-align: center">光标复位，回到左上角（1行1列）</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%d;%dH”, y, x</td>
      <td style="text-align: center">设置光标到y行x列</td>
      <td style="text-align: center">终端中的行和列都是从1开始数的</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dA”, y</td>
      <td style="text-align: center">光标上移y行</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dB”, y</td>
      <td style="text-align: center">光标下移y行</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dD”, x</td>
      <td style="text-align: center">光标左移x列</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[%dC”, x</td>
      <td style="text-align: center">光标右移x列</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[?25l”</td>
      <td style="text-align: center">隐藏光标</td>
      <td style="text-align: center">在secureCRT中测试无效</td>
    </tr>
    <tr>
      <td style="text-align: center">“\033[?25h”</td>
      <td style="text-align: center">显示光标</td>
      <td style="text-align: center">在secureCRT中测试无效</td>
    </tr>
  </tbody>
</table>

<p>注：</p>

<ol>
  <li>终端工具里的x、y坐标都是从1开始数的，同时等于0的话终端也会认为是1。</li>
  <li>\033代表的是八进制033，对应十进制是27，十六进制是0x1B。</li>
</ol>

<h2 id="section-8">2、封装好的库函数</h2>

<p>使用这个库函数的前提是：<br />
1、主函数完成了串口初始化，串口功能正常使用。<br />
2、重定向了printf函数，printf函数可通过串口输出字符串。</p>

<p>disp.h文件：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#ifndef __DISP_H__</span>
</span><span class="line"><span class="cp">#define __DISP_H__</span>
</span><span class="line"><span class="cm">/* 在主函数已经完成串口初始化，并且重定向printf函数之后，</span>
</span><span class="line"><span class="cm">   这里提供一些列函数用于操作终端工具显示，可在终端工具里构建界面。 */</span>
</span><span class="line"><span class="cp">#include &lt;stm32f10x_lib.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_clean</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_clean_line</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>     <span class="c1">//清除当前航，并复位光标到行首</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>        <span class="c1">//复位光标位置，回到左上角（1行1列）</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_gotoxy</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">//跳转到y行x列，x和y都是从1开始数。</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">);</span>      <span class="c1">//上移x行</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_down</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">);</span>    <span class="c1">//下移y行</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_left</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>    <span class="c1">//左移x列</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_right</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>   <span class="c1">//右移x列</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_hide</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>     <span class="c1">//隐藏光标，在secureCRT中测试无效。</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_show</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>     <span class="c1">//显示光标，在secureCRT中测试无效。</span>
</span><span class="line">
</span><span class="line"><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>
<p>disp.c文件：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;disp.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;uart.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_clean</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[2J&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_clean_line</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>      <span class="c1">//清除当前行，并复位光标到行首</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\33</span><span class="s">[2K</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>        <span class="c1">//复位光标位置，回到左上角</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[H&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_gotoxy</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="c1">//跳转到y行x列</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%d;%dH&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>      <span class="c1">//上移x行</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%dA&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_down</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>    <span class="c1">//下移y行</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%dB&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_left</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>    <span class="c1">//左移x列</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%dD&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_right</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>   <span class="c1">//右移x列</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[%dC&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_hide</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>     <span class="c1">//隐藏光标</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[?25l&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">disp_cursor_show</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>     <span class="c1">//显示光标</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\033</span><span class="s">[?25h&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通用舵机控制器（pwm信号发生器）]]></title>
    <link href="http://nicekwell.net/blog/20161228/tong-yong-duo-ji-kong-zhi-qi-(pwmxin-hao-fa-sheng-qi-).html"/>
    <updated>2016-12-28T14:49:53+08:00</updated>
    <id>http://nicekwell.net/blog/20161228/tong-yong-duo-ji-kong-zhi-qi-(pwmxin-hao-fa-sheng-qi-)</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">功能</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">硬件</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">程序结构</a></li>
</ul>
<p>  </p>

<p>拿到一个机械臂时你会怎么办？搭电路，写程序，控制这个机械臂，然后这套电路一直放在机械臂上。<br />
拿到一个电调呢？找航模遥控器来测试电调？也是一个不错的办法~然而有没有更方便的办法呢？</p>

<p>博主最近很空虚，冥冥之中感觉生命中缺少一个美妙的通用舵机控制器，能够让我把舵机和电调快速地撸起来~</p>

<!-- more -->

<p>工程放在github上：<a href="https://github.com/nicekwell/servo_controller">https://github.com/nicekwell/servo_controller</a><br />
可以直接下载此工程：<a href="https://github.com/nicekwell/servo_controller/archive/master.zip">https://github.com/nicekwell/servo_controller/archive/master.zip</a></p>

<p>有关PPM信号相关的知识可参考：<a href="http://nicekwell.net/blog/20161223/ppmxin-hao-jie-shao.html">PPM信号介绍</a></p>

<p>演示视频：</p>

<p><br /></p>
<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMTg4NzQ0MDA5Mg?color=white&amp;theme=light"></iframe>

<p><br /></p>
<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMTg4NzUyNDA0OA?color=white&amp;theme=light"></iframe>

<p>  </p>

<p>  </p>

<p>以下内容从工程README复制：</p>

<h1 id="section">功能</h1>
<p>可以产生7路PWM信号。<br />
周期固定为20ms，脉宽可调，精度为10us。<br />
上方7路输出通道，最上面为信号脚，中间是VCC，下面是GND。<br />
下方7个按钮选择当天调节哪路信号，按下按钮后，上方对应通道的led灯点亮，同时显示屏相应通道也会有闪烁。<br />
右边5个按钮调节当前通道的脉宽，从上到下功能依次为：加100，加10，复位（设置为1500us），减10，减100。<br />
<strong>脉宽调节没有范围限制！！</strong>所以调节时一定要注意。<br />
开机后默认所有路通道脉宽为1500us。</p>

<h1 id="section-1">硬件</h1>
<p>【单片机】12C5A32S2<br />
【晶振】24MHz<br />
【引脚连接】</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">引脚</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">舵机控制脚1</td>
      <td style="text-align: center">P1.6</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚2</td>
      <td style="text-align: center">P1.5</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚3</td>
      <td style="text-align: center">P1.4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚4</td>
      <td style="text-align: center">P1.3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚5</td>
      <td style="text-align: center">P1.2</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚6</td>
      <td style="text-align: center">P1.1</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">舵机控制脚7</td>
      <td style="text-align: center">P1.0</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led1</td>
      <td style="text-align: center">P0.6</td>
      <td style="text-align: center">推挽输出，高电平点亮，所有负极接在一起串联了电阻，一次只能点亮一个灯</td>
    </tr>
    <tr>
      <td style="text-align: center">led2</td>
      <td style="text-align: center">P0.5</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led3</td>
      <td style="text-align: center">P0.4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led4</td>
      <td style="text-align: center">P0.3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led5</td>
      <td style="text-align: center">P0.2</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led6</td>
      <td style="text-align: center">P0.1</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">led7</td>
      <td style="text-align: center">P0.0</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关1</td>
      <td style="text-align: center">P2.0</td>
      <td style="text-align: center">所有开关按下是低电平</td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关2</td>
      <td style="text-align: center">P2.1</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关3</td>
      <td style="text-align: center">P2.2</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关4</td>
      <td style="text-align: center">P2.3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关5</td>
      <td style="text-align: center">P2.4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关6</td>
      <td style="text-align: center">P2.5</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">通道开关7</td>
      <td style="text-align: center">P2.6</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关-100</td>
      <td style="text-align: center">P3.7</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关-10</td>
      <td style="text-align: center">P3.6</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关复位</td>
      <td style="text-align: center">P3.5</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关+10</td>
      <td style="text-align: center">P3.4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">开关+100</td>
      <td style="text-align: center">P3.3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">显示屏SCL</td>
      <td style="text-align: center">P0.7</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">显示屏SDA</td>
      <td style="text-align: center">P1.7</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h1 id="section-2">程序结构</h1>
<p>定时器10us一次中断，在定时器中断中完成 7路pwm通道脉宽控制 和 按键扫描 任务，其中按键扫描分成了三个函数分别进行。（广告：想了解这样做的原因，以及更多单片机编程结构相关的内容请访问<a href="http://nicekwell.net/pages/dan-pian-ji-bian-cheng.html">http://nicekwell.net/pages/dan-pian-ji-bian-cheng.html</a>）
主进程完成显示屏显示任务。</p>

<p>定时器进程检测到按键操作后，会发送标志给主进程刷新显示。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单片机提取WFR07接收机信号]]></title>
    <link href="http://nicekwell.net/blog/20161224/dan-pian-ji-ti-qu-wfr07jie-shou-ji-xin-hao.html"/>
    <updated>2016-12-24T00:39:52+08:00</updated>
    <id>http://nicekwell.net/blog/20161224/dan-pian-ji-ti-qu-wfr07jie-shou-ji-xin-hao</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">硬件</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">输出格式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">程序结构介绍</a></li>
</ul>

<p>为什么要提取接收机信号？因为有时候航模那端想要按照自己的想法编程，同时又希望能够使用航模遥控器这个方便的工具。<br />
总之如果能够把航模遥控器信号转换成数字信号，无论用它做什么也是极好的~</p>

<!-- more -->

<p>工程放在github上：<a href="https://github.com/nicekwell/WFR07_decode">https://github.com/nicekwell/WFR07_decode</a><br />
也可以直接<a href="https://github.com/nicekwell/WFR07_decode/archive/master.zip">下载</a>此工程。</p>

<p>完成后的效果视频：</p>

<p><br /></p>
<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMTg3OTU4ODYxNg?color=white&amp;theme=light"></iframe>

<p>  </p>

<p>  </p>

<p>以下是一些重要的说明，在工程的README中有更详细的介绍。</p>

<p>  </p>

<h1 id="section">硬件</h1>
<p>【单片机】STC12C5A60S2<br />
【晶振】24MHz<br />
注：此晶振可产生精确地定时器中断，方便监测各个通道，但串口波特率会有0.16%的误差，不会影响使用。<br />
【引脚连接】<br />
CH1：P1.6<br />
CH2：P1.5<br />
CH3：P1.4<br />
CH4：P1.3<br />
CH5：P1.2<br />
CH6：P1.1<br />
CH7：P1.0<br />
TXD：P3.1</p>

<h1 id="section-1">输出格式</h1>
<p>【波特率】115200<br />
实测发送一个字节大约需要13us，这样算的话一帧发送8字节大约需要104us。<br />
这里测量的13us是程序把一字节数据送入缓存，并等待发送完成标志所用的时间，不是实际串口的工作时间。<br />
【数据格式】<br />
每个周期内，当采集完7个通道的高电平后（最长约14ms）会立刻通过串口发送7个通道的数据信息。<br />
每个周期的数据为一帧，一帧数据有8个字节：<br />
第一字节固定为0x01，标志一帧数据开始。（后面7个字节不可能为这个值）<br />
后面7个字节依次表示CH1到CH7的脉宽，单位是10us。如输出150表示脉宽为1500us。<br />
注：<br />
1、接收机输出的脉宽范围大约在1000us~2000us之间，所以7个脉宽的数据范围大约在100~200之间。<br />
2、解码后输出的数据单位是10us，但实际接收机输出的精度是20us，单片机程序也是按照20us的精度采样的。</p>

<p>对于此接收机，不会出现信号丢失的情况，当遇到遥控器信号丢失时，接收机会输出预先设定好的信号，对于解码器来说不能区分当前遥控器信号是否丢失。</p>

<h1 id="section-2">程序结构介绍</h1>
<p>两个进程：定时器中断和主循环。</p>

<p>定时器20us一次中断，有两个状态：<br />
1、信号采集中：<br />
  1、采集各个通道高电平时间。<br />
  2、判断当前所有通道是否采集完成（所有通道信号结束后，所有通道都会输出低电平。<br />
    如果连续100us（5个周期）检测到所有通道都是低电平，则认为一帧信号结束，此时对采集到的信号进行判断：<br />
      如果所有通道脉宽大于500us，则认为数据有效，通知主进程发送数据，并进入状态2。<br />
2、本周期信号已结束，等待下一周期：<br />
  任意通道采集到高电平则进入状态1。</p>

<p>主循环进程只干一件事，等待定时器进程发送指令，接收到指令后发送数据。<br />
但主循环会忽略第一帧数据，因为第一帧数据可能采集不完整。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单片机提取GR3E接收机信号]]></title>
    <link href="http://nicekwell.net/blog/20161224/dan-pian-ji-ti-qu-gr3ejie-shou-ji-xin-hao.html"/>
    <updated>2016-12-24T00:08:33+08:00</updated>
    <id>http://nicekwell.net/blog/20161224/dan-pian-ji-ti-qu-gr3ejie-shou-ji-xin-hao</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">硬件</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">输出格式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">程序结构介绍</a></li>
</ul>

<p>为什么要提取接收机信号？因为有时候航模那端想要按照自己的想法编程，同时又希望能够使用航模遥控器这个方便的工具。<br />
总之如果能够把航模遥控器信号转换成数字信号，无论用它做什么也是极好的~</p>

<!-- more -->

<p>工程放在github上：<a href="https://github.com/nicekwell/GR3E_decode">https://github.com/nicekwell/GR3E_decode</a><br />
也可以直接<a href="https://github.com/nicekwell/GR3E_decode/archive/master.zip">下载</a>此工程。</p>

<p>完成后的效果视频：</p>

<p><br /></p>
<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMTg3ODIxODc2MA?color=white&amp;theme=light"></iframe>

<p>  </p>

<p>  </p>

<p>以下是一些重要的说明，在工程的README中有更详细的介绍。</p>

<p>  </p>

<h1 id="section">硬件</h1>
<p>【单片机】STC12C5A60S2<br />
【晶振】24MHz<br />
注：此晶振可产生精确地定时器中断，方便监测各个通道，但串口波特率会有0.16%的误差，不会影响使用。<br />
【引脚连接】<br />
CH1：P1.2<br />
CH2：P1.1<br />
CH3：P1.0<br />
TXD：P3.1</p>

<h1 id="section-1">输出格式</h1>
<p>【波特率】115200<br />
实测发送一个字节大约需要13us，这样算的话一帧发送4字节大约需要50us。<br />
这里测量的13us是程序把一字节数据送入缓存，并等待发送完成标志所用的时间，不是实际串口的工作时间。<br />
【数据格式】<br />
每个周期内，当采集完三个通道的高电平后（最长约6ms）会立刻通过串口发送3个通道的数据信息。<br />
每个周期的数据为一帧，一帧数据有4个字节：<br />
第一字节固定为0x01，标志一帧数据开始。（后面三个字节不可能为这个值）<br />
后面三个字节依次表示CH1、CH2、CH3的脉宽，单位是10us。如输出150表示脉宽为1500us。<br />
注：<br />
1、接收机输出的脉宽范围大约在1000us~2000us之间，所以三个脉宽的数据范围大约在100~200之间。<br />
2、解码后输出的数据单位是10us，但实际接收机输出的精度是20us，单片机程序也是按照20us的精度采样的。</p>

<p>以上是接收机正常工作的数据输出格式，当接收机接收不到信号时，模块持续输出0x02。</p>

<h1 id="section-2">程序结构介绍</h1>
<p>两个进程：定时器中断和主循环。</p>

<p>定时器20us一次中断，有两个状态：<br />
1、信号采集中：<br />
  1、采集各个通道高电平时间。<br />
  2、判断当前所有通道是否采集完成（所有通道信号结束后，所有通道都会输出低电平。<br />
    如果连续100us（5个周期）检测到所有通道都是低电平，则认为一帧信号结束，此时对采集到的信号进行判断：<br />
      如果所有通道脉宽大于500us，则认为数据有效，通知主进程发送数据，并进入状态2。<br />
      否则认为数据有问题，通知主循环发送“信号丢失”信号，并进入状2。<br />
2、本周期信号已结束，等待下一周期：<br />
  任意通道采集到高电平则进入状态1。</p>

<p>主循环进程只干一件事，等待定时器进程发送指令，接收到指令后发送数据。<br />
但主循环会忽略第一帧数据，因为第一帧数据可能采集不完整。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WFT07和WFR07的功能和使用]]></title>
    <link href="http://nicekwell.net/blog/20161223/wft07he-wfr07de-gong-neng-he-shi-yong.html"/>
    <updated>2016-12-23T23:47:02+08:00</updated>
    <id>http://nicekwell.net/blog/20161223/wft07he-wfr07de-gong-neng-he-shi-yong</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1、特性</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2、基本设置</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">设置供电模式</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">设置遥控模式</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">对码</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">失控设置</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">3、遥控器功能</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">4、接收机引脚</a></li>
  <li><a href="#pwm" id="markdown-toc-pwm">5、接收机输出PWM特性</a></li>
</ul>
<p>  </p>

<h1 id="section">1、特性</h1>
<p>我买的是美国手，油门在左边。<br />
7通道。<br />
自带4节5号电池盒，可以用5号电池供电，也可以换成锂电池供电。</p>

<p>可设置固定翼和直升机两种遥控模式。<em>直升机模式下各个通道之间的调节会相互影响，比如调节油门一个通道，会有多个通道一起改变；而在固定翼模式下，各个通道是独立调节。</em><br />
<strong>对我来说，我只想在接收端还原遥控器的操作，对操作进行何种响应由飞机上的程序决定，所以我用的是固定翼模式，下面的所有介绍都是在固定翼模式下。</strong></p>

<!-- more -->

<h1 id="section-1">2、基本设置</h1>

<h2 id="section-2">设置供电模式</h2>

<p>遥控器虽然不能直接给电池充电，但是可以设置电池的供电方式，根据不同的电池类型判断当前电量。<br />
设置方法：<br />
<strong>按住menu键开机–&gt;供电方式–&gt;选择对应的供电方式–&gt;关机重开机生效</strong><br />
我买了充电锂电池，所以选择锂电池供电。</p>

<h2 id="section-3">设置遥控模式</h2>
<p>如上面所说，这里所有的介绍都是在“固定翼”模式下，需要把模式设置成“固定：<br />
按menu键开机–&gt;机型设置–&gt;固定翼。</p>

<h2 id="section-4">对码</h2>
<p>1、接收机上电<br />
2、接收机长按SET键，接收机指示灯编程橙色，进入对码状态。<br />
3、遥控器开机–&gt;menu–&gt;高级设置–&gt;对码。对码成功后接收机指示灯会熄灭。</p>

<h2 id="section-5">失控设置</h2>
<p>枪型3通道遥控器，接收机在接收不到遥控器信号时所有通道的信号会立马停止。而7通道遥控器可以设置当接收机接收不到信号时应该保持什么样的信号输出。<br />
menu–&gt;高级设置–&gt;失控设置，在这个页面按一下ok键就会把当前遥控器的状态作为失控时的状态。</p>

<h1 id="section-6">3、遥控器功能</h1>

<p><img src="http://nicekwell.net/images/module-and-agreement/WFT07.jpg" alt="WFT07jpg" /></p>

<h1 id="section-7">4、接收机引脚</h1>

<p><img src="http://nicekwell.net/images/module-and-agreement/WFR07.jpg" alt="WFR07jpg" /></p>

<p>电源正负极在接收机上有标识。</p>

<h1 id="pwm">5、接收机输出PWM特性</h1>
<p>PPM信号和接收机输出的PWM的详细文档跳转到：<a href="http://nicekwell.net/blog/20161223/ppmxin-hao-jie-shao.html">PPM信号介绍</a><br />
周期：21.2ms，不是标准的20ms。<br />
脉宽：中间值±500us，和标准相同。<br />
精度：通道1、2、3、4、6是连续变化的，分辨率是20us。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">时间精度</th>
      <th style="text-align: center">调节范围1000us，分成份数</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">20us</td>
      <td style="text-align: center">50</td>
      <td style="text-align: center">普通舵机500us~2500us对应角度180°，对应舵机角度分辨率：1.8°。占空比从 -100%到+100%，对应占空比分辨率：4%。</td>
    </tr>
  </tbody>
</table>

<p>此接收机可设置遥控器信号丢失时的输出，所以遥控器信号丢失时的输出不确定，接近正常操作信号，单片机提取其信号时也无法判断当前是否信号丢失。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GT2B和GR3E的功能和使用]]></title>
    <link href="http://nicekwell.net/blog/20161223/gt2bhe-gr3ede-gong-neng-he-shi-yong.html"/>
    <updated>2016-12-23T23:26:04+08:00</updated>
    <id>http://nicekwell.net/blog/20161223/gt2bhe-gr3ede-gong-neng-he-shi-yong</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">特性</a></li>
  <li><a href="#gt2b" id="markdown-toc-gt2b">1、GT2B遥控器功能</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">3、对码</a></li>
  <li><a href="#pwm" id="markdown-toc-pwm">4、输出PWM信号特性</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">周期</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">通道分配</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">精度</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">关于遥控器的说明</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">信号丢失后的输出</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">5、其他说明</a></li>
</ul>
<p>  </p>

<h1 id="section">特性</h1>
<p>三通道：方向，电机，第三通道。<br />
接收机输出的是PWM信号，PPM信号和PWM信号的详细介绍可参考<a href="http://nicekwell.net/blog/20161223/ppmxin-hao-jie-shao.html">PPM信号介绍</a></p>

<!-- more -->

<h1 id="gt2b">1、GT2B遥控器功能</h1>

<p><img src="http://nicekwell.net/images/module-and-agreement/GT2B_1.jpg" alt="GT2B_1.jpg" /></p>

<p><img src="http://nicekwell.net/images/module-and-agreement/GT2B_2.jpg" alt="GT2B_2.jpg" /></p>

<p>控制面板相关设置的功能会在第4节“输出PWM信号特性”中结合输出信号说明。</p>

<p><img src="http://nicekwell.net/images/module-and-agreement/GR3E.jpg" alt="GR3E.jpg" /></p>

<p>在左边都写得很清楚，总共4排，每排3个脚，用表格列出来引脚就是：</p>

<table>
  <tbody>
    <tr>
      <td>悬空</td>
      <td>VCC</td>
      <td>GND</td>
    </tr>
    <tr>
      <td>BINO/CH3</td>
      <td>VCC</td>
      <td>GND</td>
    </tr>
    <tr>
      <td>CH2</td>
      <td>VCC</td>
      <td>GND</td>
    </tr>
    <tr>
      <td>CH1</td>
      <td>VCC</td>
      <td>GND</td>
    </tr>
  </tbody>
</table>

<p>所有通道的VCC相连，所有通道的GND相连。<br />
VCC电压标准是5V。</p>

<h1 id="section-1">3、对码</h1>
<p>1、遥控器和接收机都断电。<br />
2、接收机第三通（BINO）道插入对码线。所谓对码线的功能其实就是把PWM输出脚和地相连。<br />
3、接收机任意通道接通电源。此时接收机灯闪烁，表示等待对码。<br />
4、遥控器按住对码键（BINO）开机。对码成功的话接收机停止闪烁，遥控器的电量指示灯（G/F）闪烁。<br />
5、重启遥控器。<br />
此时接收机就可以用遥控器控制了，信号特性见下面。</p>

<h1 id="pwm">4、输出PWM信号特性</h1>
<p>PPM信号和接收机输出的PWM的详细文档跳转到：<a href="http://nicekwell.net/blog/20161223/ppmxin-hao-jie-shao.html">PPM信号介绍</a></p>

<h2 id="section-2">周期</h2>
<p>GR3E 三个通道的PWM信号周期都是16ms，频率大约是60Hz。</p>

<h2 id="section-3">通道分配</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">通道</th>
      <th style="text-align: center">功能</th>
      <th style="text-align: left">信号特性</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CH1</td>
      <td style="text-align: center">方向</td>
      <td style="text-align: left">1、脉宽<em>中间值</em>可以通过控制面板<strong>最上面的旋钮</strong>调节，默认中间值是<strong>1500us</strong>。2、脉宽<em>变化方向</em>可以通过控制面板<strong>左上角的开关</strong>设置。3、脉宽<em>变化范围</em>是1000us，也就是 <strong>中间值±500us</strong>的范围。</td>
    </tr>
    <tr>
      <td style="text-align: center">CH2</td>
      <td style="text-align: center">油门</td>
      <td style="text-align: left">1、脉宽<em>中间值</em>可以通过控制面板<strong>最上面的旋钮</strong>调节，默认中间值是<strong>1500us</strong>。2、脉宽<em>变化方向</em>可以通过控制面板<strong>左上角的开关</strong>设置。3、脉宽<em>变化范围</em>是1000us，也就是 <strong>中间值±500us</strong>的范围。</td>
    </tr>
    <tr>
      <td style="text-align: center">CH3</td>
      <td style="text-align: center">第三通道</td>
      <td style="text-align: left">这个通道的PWM脉宽不是连续可变的。遥控器启动时默认设置的脉宽是1000us，按第三通道键可在 1000us 和 2000us 间切换。</td>
    </tr>
  </tbody>
</table>

<h2 id="section-4">精度</h2>
<p>通道1和通道2是连续变化，分辨率是20us。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">通道</th>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">时间精度</th>
      <th style="text-align: center">调节范围1000us，分成份数</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CH1</td>
      <td style="text-align: center">方向</td>
      <td style="text-align: center">20us</td>
      <td style="text-align: center">50</td>
      <td style="text-align: center">普通舵机500us~2500us对应角度180°，对应舵机角度分辨率：1.8°</td>
    </tr>
    <tr>
      <td style="text-align: center">CH2</td>
      <td style="text-align: center">油门</td>
      <td style="text-align: center">20us</td>
      <td style="text-align: center">50</td>
      <td style="text-align: center">占空比从 -100%到+100%，对应占空比分辨率：4%</td>
    </tr>
  </tbody>
</table>

<h2 id="section-5">关于遥控器的说明</h2>
<p>1、接收机的信号是由遥控器实时刷新的，如果遥控器关闭的话，接收机信号立马停止。信号丢失后的信号特性是由接收机决定的，有些甚至可以自定义。<br />
2、正如上面所说接收机信号是由遥控器实时刷新，第三通道在1ms和2ms间的状态也是由遥控器决定，接收机不会记忆。而事实上遥控器也不会记忆，重启遥控器后第三通道默认是1000us。</p>

<h2 id="section-6">信号丢失后的输出</h2>
<p>当遥控器关闭后，GR3E的信号特性如下：</p>

<table>
  <tbody>
    <tr>
      <td>CH1</td>
      <td>一直低电平</td>
    </tr>
    <tr>
      <td>CH2</td>
      <td>脉宽1500us，周期16ms。相当于油门在中间位置。</td>
    </tr>
    <tr>
      <td>CH3</td>
      <td>一直低电平</td>
    </tr>
  </tbody>
</table>

<h1 id="section-7">5、其他说明</h1>
<p>关于刹车功能（把电机的两根电源线短接，超再生刹车），不是遥控器和接收机来识别刹车操作的，遥控器和接收机的组合只是单纯地把方向和油门调制成PWM信号反映出来。<br />
刹车功能是由电调完成的，电调识别PWM信号来分析是否需要刹车。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PPM信号介绍]]></title>
    <link href="http://nicekwell.net/blog/20161223/ppmxin-hao-jie-shao.html"/>
    <updated>2016-12-23T23:00:25+08:00</updated>
    <id>http://nicekwell.net/blog/20161223/ppmxin-hao-jie-shao</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">电平</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">工作方式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">刷新率</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">脉宽和数值</a></li>
  <li><a href="#pwm" id="markdown-toc-pwm">多路PWM信号</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">精度</a></li>
  <li><a href="#pwm-1" id="markdown-toc-pwm-1">PWM信号和舵机</a></li>
  <li><a href="#pwm-2" id="markdown-toc-pwm-2">PWM信号和电调</a></li>
  <li><a href="#pwm-3" id="markdown-toc-pwm-3">单片机提取接收机输出的PWM信号</a></li>
</ul>
<p>  </p>

<p>  我们知道PWM信号可以控制舵机，一般信号周期是20ms，脉宽在500us~2500us之间。<br />
  实际上这种pwm信号不仅可以控制舵机，航模中使用的电调（有刷和无刷）也是用这种信号控制，只不过它们的脉宽范围一般限制在1000us~2000us。<br />
  而航模接收机输出的正是上述 周期20ms，脉宽1000us~2000us之间的pwm信号。可以理解为，接收机通过pwm信号来反映遥控器的操作。<br />
  航模遥控器有多路通道，可以传输多个操作（油门、方向等），而无线信道只有一路，怎么把多路通道的pwm信息传输到接收机呢？这就是所谓的PPM调制。<br />
  PPM信号把多路PWM信号调制到一路通道上，发送到接收机后再由接收机还原成多路PWM从各个通道输出。</p>

<!-- more -->

<p>  注意上面说的PWM信号和控制电机的PWM信号不同。<br />
  控制电机的PWM信号对周期没有严格要求，占空比变化范围0~100%；<br />
  而航模遥控器接收机输出的PWM信号（也是控制舵机、电调的PWM信号），周期一般是20ms，也有16ms的，正脉宽范围一般是1000us~2000us。</p>

<p>  以上是PPM信号的介绍，我不关心PPM是如何调制的，更关心如何利用航模接收机输出的PWM信号，<strong>以下介绍的是航模接收机输出PWM信号</strong>。</p>

<h1 id="section">电平</h1>
<p>  标准电平是5V（航模遥控器的接收机工作电压是5v）。</p>

<h1 id="section-1">工作方式</h1>
<p>  信息以高电平脉冲宽度表示，以固定的频率不断地刷新信号；<br />
  在每个周期内，携带信息的是<strong>高电平</strong>脉冲，高电平信息结束后是持续的低电平。</p>

<h1 id="section-2">刷新率</h1>
<p>  标准刷新率是50Hz（周期20ms），但也遇到过60Hz（周期约16ms）的接收机，如GR3E 3通道接收机。7通道接收机WFR07的周期是21.2ms。</p>

<h1 id="section-3">脉宽和数值</h1>
<p>  脉宽变化范围是<strong>1000us~2000us</strong>。<br />
  一般航模遥控器中：<br />
  方向、油门之类的双向控制，中间值是1500us，两个方向的极值分别是1000us和2000us；<br />
  模式切换按钮，分别在1000us和2000us之间切换。<br />
  无刷电调没有方向，在1000us时油门为0，2000us时油门最大。<br />
  <em>注：<br />
  1、航模遥控器中，双向控制项目一般都会有个中间值调节旋钮，如果调节了中间值不是1500us，那么另外两个方向的极值也会随着变化。总之输出范围是围绕着中间值±500的范围。<br />
  2、接收机输出的PWM信号可直接接到舵机，而一般舵机的脉宽范围是500us~2500us，对应角度0°~180°。所以一般由接收机输出的PWM信号直接控制的舵机，旋转角度范围在45°~135°。</em></p>

<h1 id="pwm">多路PWM信号</h1>
<p>  航模遥控器中常说的“几路通道”代表接收机能输出几路PWM信号。<br />
  <strong>注意各个通道的PWM高电平不是同时输出的，一路通道在前一路通道高电平输出结束后才会开始</strong>，类似于这样：</p>

<p>  <img src="http://nicekwell.net/images/module-and-agreement/ppm.jpg" alt="ppm.jpg" /></p>

<p>  这是因为航模遥控器不能同时传输多路通道，只能单路传输，然后分给各个通道。遥控器的无线信号类似于上面信号的第一行，解调后变成了下面各路通道信号。<br />
  注意，各个通道的高电平信号是一个紧挨着一个的，而不是每个通道固定分配2ms的时间。<br />
  <strong>在对接收机解码时发现，实际各个通道的正脉冲并不是一个紧挨着一个出现。</strong>有的接收机各个通道输出的高电平连接比较近，而有的接收机在上一个通道正脉冲结束后要等较长的时间下一个通道的高电平才出现，在此期间所有的通道都是低电平。</p>

<p>  由于单路信号最长是2000us，周期20ms，所以理论上可以容纳10路。而由于需要进行同步，<strong>实际上遥控器最多只能容纳9路信号</strong>。<br />
  记住：<em>接收机输出的每帧信号（20ms）里，理论上最后必然有至少2ms的时间里，所有的通道都输出低电平</em>，单片机解码时就是利用这一点来判断一帧信号结束的。</p>

<h1 id="section-4">精度</h1>
<p>  PPM标准协议中不知道有没有精度规定 ，实际 GT2B/GR3E 枪型遥控器 和 WFT07/WFR07飞机遥控器 的精度都是20us，</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">时间精度</th>
      <th style="text-align: center">调节范围1000us，分成份数</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">20us</td>
      <td style="text-align: center">50</td>
      <td style="text-align: center">普通舵机500us~2500us对应角度180°，对应舵机角度分辨率：1.8°。占空比从 -100%到+100%，对应占空比分辨率：4%</td>
    </tr>
  </tbody>
</table>

<h1 id="pwm-1">PWM信号和舵机</h1>
<p>  接收机输出的PWM信号可直接接到舵机，而一般舵机的脉宽范围是500us~2500us，对应角度0°~180°。所以一般由PWM直接控制的舵机，旋转角度范围在45°~135°。</p>

<h1 id="pwm-2">PWM信号和电调</h1>
<p>  接收机输出的PWM信号可直接输出给舵机，而在航模中经常会用这种PWM信号控制电机（有刷和无刷），接收机输出的PWM信号是不能直接控制电机的，虽然最终控制电机的信号也叫PWM，但两种信号是不同的，本文开头有介绍。此时需要电调。<br />
  电调具有接收 <strong>接收机输出的PWM信号</strong> 和 <strong>驱动电机</strong> 的功能，不同的电机驱动方式不同（有刷和无刷，有感和无感）。简单地说，<strong>电调的作用是接收 接收机输出的PWM信号 信号，转换成我们希望的电机驱动信号，并通过内部的电机驱动电路实现对电机的控制</strong>。</p>

<h1 id="pwm-3">单片机提取接收机输出的PWM信号</h1>
<p>  根据此信号的特性：</p>

<p><img src="http://nicekwell.net/images/module-and-agreement/ppm.jpg" alt="ppm.jpg" /></p>

<p>  我们想要用单片机提取并解释PPM信号可以有两种方法：<br />
  1、获取上图最上面一行的PPM信号，并解释。<br />
  2、获取接收机输出的各路通道的PWM信号，并解释。<br />
  对于成品的接收机，获取各路的输出信号要容易得多，所以采用第二种方法，直接把各路通道的输出信号接到单片机。</p>

<p>  另外在前面的介绍里有说过：<em>接收机输出的每帧信号（20ms）里，理论上最后必然有至少2ms的时间里，所有的通道都输出低电平。</em>我们可以利用这一点来判断一帧信号的结束。</p>

<p>  具体的提取方法请看遥控器接收机信号提取的具体工程：<br />
  <a href="http://nicekwell.net/blog/20161224/dan-pian-ji-ti-qu-gr3ejie-shou-ji-xin-hao.html">单片机提取GR3E接收机信号</a><br />
  <a href="http://nicekwell.net/blog/20161224/dan-pian-ji-ti-qu-wfr07jie-shou-ji-xin-hao.html">单片机提取WFR07接收机信号</a></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
</feed>
