<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[生命不息 折腾不止]]></title>
  <link href="http://nicekwell.net/atom.xml" rel="self"/>
  <link href="http://nicekwell.net/"/>
  <updated>2018-01-25T10:57:18+08:00</updated>
  <id>http://nicekwell.net/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[平衡自行车-实践篇]]></title>
    <link href="http://nicekwell.net/blog/20180123/ping-heng-zi-xing-che-shi-jian-pian.html"/>
    <updated>2018-01-23T09:20:38+08:00</updated>
    <id>http://nicekwell.net/blog/20180123/ping-heng-zi-xing-che-shi-jian-pian</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、材料</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">二、动力部分</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">传动方式</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">电机选择</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">电机供电</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">三、转向部分</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">四、电路</a>    <ul>
      <li><a href="#section-7" id="markdown-toc-section-7">供电</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">下载</a></li>
      <li><a href="#gy521" id="markdown-toc-gy521">GY521</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">电机</a></li>
      <li><a href="#section-10" id="markdown-toc-section-10">舵机</a></li>
      <li><a href="#section-11" id="markdown-toc-section-11">蓝牙模块</a></li>
    </ul>
  </li>
  <li><a href="#section-12" id="markdown-toc-section-12">五、代码结构</a>    <ul>
      <li><a href="#section-13" id="markdown-toc-section-13">驱动</a></li>
      <li><a href="#section-14" id="markdown-toc-section-14">平衡控制</a></li>
      <li><a href="#section-15" id="markdown-toc-section-15">遥控和调试</a></li>
    </ul>
  </li>
  <li><a href="#section-16" id="markdown-toc-section-16">六、广告</a></li>
</ul>
<p>  </p>

<p>在本文将会介绍平衡自行车的具体制作过程，包括机械、电路和代码。<br />
平衡自行车完整的代码托管在 <a href="https://github.com/nicekwell/balance_bike">https://github.com/nicekwell/balance_bike</a>。</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-23-ping-heng-zi-xing-che-shi-jian-pian/balance_bike.jpg" alt="balance_bile.jpg" /></p>

<!-- more -->

<h1 id="section">一、材料</h1>

<p><strong>机械</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">名称</th>
      <th style="text-align: center">数量</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">铜柱、铁丝、胶枪等基础材料和工具</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">自行车架</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">自己做车架是很麻烦的，我是直接买的车架，淘宝上搜”自行车 拼装 DIY”能搜到很多</td>
    </tr>
    <tr>
      <td style="text-align: center">舵机</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">转向用的，对于我用的1:6车架，普通舵机有点大，我用的是9g舵机</td>
    </tr>
    <tr>
      <td style="text-align: center">N20电机</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">选扭力大一点，这样转速会比较稳定</td>
    </tr>
    <tr>
      <td style="text-align: center">皮带轮和皮带</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">如上面的图片，我是用皮带来传输动力的</td>
    </tr>
  </tbody>
</table>

<p><strong>电路</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">名称</th>
      <th style="text-align: center">数量</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">电池、电池盒</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">洞洞板</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">lm1117-3.3</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">降压芯片给控制系统供电</td>
    </tr>
    <tr>
      <td style="text-align: center">stm32f103c8t6核心板</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">gy521模块</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">加速度传感器 + 陀螺仪</td>
    </tr>
    <tr>
      <td style="text-align: center">升压模块</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">升到12v给电机供电，根据电机特性选择是否使用升压模块</td>
    </tr>
    <tr>
      <td style="text-align: center">8050三极管</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">驱动电机，由于自行车不需要反转，所以不需要使用电机驱动芯片，用三极管就能方便地实现。我用了两个三极管并联提高功率。</td>
    </tr>
    <tr>
      <td style="text-align: center">自锁开关</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">整个系统开关</td>
    </tr>
    <tr>
      <td style="text-align: center">led指示灯</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">配合1k限流电阻</td>
    </tr>
    <tr>
      <td style="text-align: center">蓝牙模块</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">可选，如果想要遥控的话就使用蓝牙</td>
    </tr>
  </tbody>
</table>

<h1 id="section-1">二、动力部分</h1>

<h3 id="section-2">传动方式</h3>
<p>如图，我用的是皮带传送的方式，因为比较好实现。</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-23-ping-heng-zi-xing-che-shi-jian-pian/1.jpg" alt="1.jpg" /></p>

<h3 id="section-3">电机选择</h3>
<p>这个DIY是不考虑变速情况的，平衡的参数都是按照一个固定速度调的。<br />
所以动力部分的作用就是提供一个恒定的速度，并且这个速度尽可能稳定，尽可能不受外部影响。<br />
电机应选择扭力大一些、转速稳定的减速电机。</p>

<h3 id="section-4">电机供电</h3>

<p>电机是直接供电还是使用升压模块供电要根据电机特性，有些电机用升压模块可以提高功率，有些大电流电机用升压模块反而可能限制了电流。</p>

<p>我这里用升压模块升到12v给N20电机供电的。</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-23-ping-heng-zi-xing-che-shi-jian-pian/2.jpg" alt="2.jpg" /></p>

<p>另外，电机通过三极管受stm32控制，通过控制占空比也可以限制电机输出的功率。</p>

<h1 id="section-5">三、转向部分</h1>

<p>转向部分用一个舵机带动把手转动即可。</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-23-ping-heng-zi-xing-che-shi-jian-pian/3.jpg" alt="3.jpg" /></p>

<h1 id="section-6">四、电路</h1>

<p>在github工程里有详细的引脚连接表 <a href="https://github.com/nicekwell/balance_bike">https://github.com/nicekwell/balance_bike</a>。</p>

<h3 id="section-7">供电</h3>

<p>用3.3v稳压芯片给整个控制系统供电，包括单片机、GY521模块、蓝牙模块。<br />
用5v稳压芯片给舵机供电。<br />
用12v升压模块给电机供电。</p>

<h3 id="section-8">下载</h3>

<p>我是用串口给stm32下载程序的。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">引脚</th>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">PA9</td>
      <td style="text-align: center">下载TXD</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">PA10</td>
      <td style="text-align: center">下载RXD</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h3 id="gy521">GY521</h3>

<p>这个模块通过i2c通信，只需要连接4根线。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">引脚</th>
      <th style="text-align: center">功能</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">3.3v</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">GND</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">PB0</td>
      <td style="text-align: center">GY521 I2C SCL</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">PB1</td>
      <td style="text-align: center">GY521 I2C SDA</td>
      <td style="text-align: center">用的是IO模拟i2c</td>
    </tr>
  </tbody>
</table>

<h3 id="section-9">电机</h3>

<p>点击用12v升压模块供电，由于不需要反转，用三极管即可直接驱动，电路图如下：</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-23-ping-heng-zi-xing-che-shi-jian-pian/4.jpg" alt="4.jpg" /></p>

<p>加三极管的目的是为了可以通过调节PWM占空比来限制输出功率，但我的实际情况是100%输出时动力才勉强足够。所以如果你不需要限制电机输出功率，或者通过其他方式限制输出功率，也可以不要三极管，不通过单片机控制。</p>

<h3 id="section-10">舵机</h3>

<p>舵机是用5v供电的，而单片机是3.3v电平，对于pwm控制脚可以通过2个三极管实现同相的电平转换：</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-23-ping-heng-zi-xing-che-shi-jian-pian/5.jpg" alt="5.jpg" /></p>

<h3 id="section-11">蓝牙模块</h3>

<p>下图是我使用的蓝牙串口模块，可以实现串口透传，只需要4根线连接：vcc、gnd、txd、rxd。</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-23-ping-heng-zi-xing-che-shi-jian-pian/6.jpg" alt="6.jpg" /></p>

<p>蓝牙模块是用来调试和遥控的，没有它也能跑。建议还是加上这个模块，在调试PID擦数时会非常方便。<br />
关于调试方面的内容可以参考我写的另一片文章：<a href="http://nicekwell.net/blog/20170411/tan-%5B%3F%5D-tan-dan-pian-ji-kai-fa-de-ji-chong-diao-shi-fang-an.html">谈一谈单片机开发的几种调试方案</a></p>

<h1 id="section-12">五、代码结构</h1>

<p>代码提交在github <a href="https://github.com/nicekwell/balance_bike">https://github.com/nicekwell/balance_bike</a>。</p>

<p>主要分为3个部分：1、基础的驱动程序，实现电机、舵机、gy521数据读取；2、平衡控制系统，核心是一个20ms定时器，每20ms进行一次数据采集、计算和响应；3、遥控和调试系统，实现log输出、接收遥控信息。</p>

<h3 id="section-13">驱动</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">名称</th>
      <th style="text-align: center">文件</th>
      <th style="text-align: center">功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">i2c</td>
      <td style="text-align: center">i2c/i2c.c, include/i2c.h</td>
      <td style="text-align: center">IO 模拟i2c驱动，提供i2c基础操作</td>
    </tr>
    <tr>
      <td style="text-align: center">gy521</td>
      <td style="text-align: center">gy521/gy521.c, include/gy521.h</td>
      <td style="text-align: center">gy521模块驱动，基于i2c驱动，提供加速度和角速度的读取接口</td>
    </tr>
    <tr>
      <td style="text-align: center">motor</td>
      <td style="text-align: center">motor/motor.c, include/motor.h</td>
      <td style="text-align: center">电机驱动，提供占空比控制接口</td>
    </tr>
    <tr>
      <td style="text-align: center">angle</td>
      <td style="text-align: center">angle/angle.c, include/angle.h</td>
      <td style="text-align: center">舵机驱动，提供角度控制接口</td>
    </tr>
  </tbody>
</table>

<h3 id="section-14">平衡控制</h3>

<p>main函数会初始化一个定时器20ms中断一次，调用 main/balance.c 里的 balance_tick 函数，平衡算法在 main/balance.c 实现。</p>

<p>每20ms到来会执行一次：</p>

<ol>
  <li>读取传感器加速度和角速度信息。</li>
  <li>互补平衡滤波计算当前姿态。</li>
  <li>用PID算法计算出前轮转角。</li>
</ol>

<h3 id="section-15">遥控和调试</h3>

<p>两部分：状态输出和指令接收。</p>

<p><strong>状态输出</strong><br />
在main函数的while循环里，利用串口中断构建一个简单的界面显示状态。</p>

<p><strong>指令接收</strong><br />
串口接收到的数据会传给main/control.c，该文件分析串口数据，解释成相应的操作。主要是PID参数调节。</p>

<h1 id="section-16">六、广告</h1>

<p>老婆做毕业设计，给我下了死命令，一定要找300个程序员研究一下，请各位同行做个调查问卷，可扫描下面二维码或者直接点击此链接：<a href="https://www.wjx.cn/jq/17710478.aspx">https://www.wjx.cn/jq/17710478.aspx</a>，多谢！</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-23-ping-heng-zi-xing-che-shi-jian-pian/ad.jpg" alt="ad.jpg" /></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[平衡自行车-理论篇]]></title>
    <link href="http://nicekwell.net/blog/20180121/ping-heng-zi-xing-che-li-lun-pian.html"/>
    <updated>2018-01-21T21:52:31+08:00</updated>
    <id>http://nicekwell.net/blog/20180121/ping-heng-zi-xing-che-li-lun-pian</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、模型分析</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1、倒立摆</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">2、自行车的平衡控制</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">2.1 怎样的状态才叫平衡</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">2.2 我们能控制的是什么</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">2.3 如何控制才能平衡</a></li>
        </ul>
      </li>
      <li><a href="#section-6" id="markdown-toc-section-6">3、自行车平衡需要解决的基本问题</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">二、姿态检测</a>    <ul>
      <li><a href="#section-8" id="markdown-toc-section-8">1、检测的是什么</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">2、怎么检测</a></li>
    </ul>
  </li>
  <li><a href="#pid" id="markdown-toc-pid">三、PID算法</a></li>
  <li><a href="#section-10" id="markdown-toc-section-10">四、广告</a></li>
</ul>
<p>  </p>

<p>这是平衡自行车三篇教程中的第二篇，这一篇对平衡自行车的算法进行理论分析，包括模型分析、姿态检测方法、PID算法，控制算法。</p>

<!-- more -->

<h1 id="section">一、模型分析</h1>

<h2 id="section-1">1、倒立摆</h2>

<p>很显然我们知道自行车在左右方向上不稳定，这是一个很常见的物理模型——倒立摆。</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/1.jpg" alt="1.jpg" /></p>

<p>顾名思义，倒立摆的意思就是倒着的摆，比如一个倒着的杆，</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/2.jpg" alt="2.jpg" /></p>

<p>倒立摆的特性：不稳定，只要偏离平衡位置，就会有一个力(重力的分力)使系统更加偏离平衡位置，这样偏差就会越来越大。</p>

<p>一般倒立的杆在前后左右方向都有可能倒下，在二维的平面上不稳定；而自行车仅在左右方向上可能倒下，是一维的倒立摆，这要简单一些。</p>

<p>以下是几个生活中常见的倒立摆例子：</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/3.jpg" alt="3.jpg" /></p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/4.jpg" alt="4.jpg" /></p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/5.jpg" alt="5.jpg" /></p>

<h2 id="section-2">2、自行车的平衡控制</h2>

<p>自行车属于倒立摆模型，倒立摆是不稳定的，那么倒立摆应该如何控制才能平衡呢？</p>

<p>我们把问题拆分一下：</p>

<ol>
  <li>怎样的状态才叫平衡？</li>
  <li>我们能控制的是什么？</li>
  <li>如何控制才能稳定平衡？</li>
</ol>

<h3 id="section-3">2.1 怎样的状态才叫平衡</h3>
<p>我们要对”平衡”进行数学描述，所谓的平衡其实就是倒立摆的倾角稳定在一个我们想要的值。</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/2.jpg" alt="2.jpg" /></p>

<p>通常我们想要平衡在θ = 0处。</p>

<h3 id="section-4">2.2 我们能控制的是什么</h3>
<p>对于倒立摆模型，通常我们能控制的是底端的 力 或 速度 或 位置，不同的控制量对应的控制方法不同。</p>

<p>对于自行车来说，它的控制方式不像通常的倒立摆那样直接控制底部，而是间接地通过转向来控制，当自行车以一个固定的速度前进时，自行车把手以一定角度进行转向(设为α)，自行车会做相应半径的圆周运动，产生相应大小的”离心力”。</p>

<p>在自行车这个费惯性系里看来，只要对把手进行一定角度的转向(α)，就会产生一个相应大小的横向力:</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/6.jpeg" alt="6.jpg" /></p>

<p>这就是我们进行平衡控制时的实际控制量——把手转角α，只要控制它就能控制回复力。</p>

<h3 id="section-5">2.3 如何控制才能平衡</h3>
<p>上面我们已经能够通过转向产生回复力，这个回复力可以把倒立摆”掰回”平衡位置，有往回掰的回复力就能稳定平衡了吗？<br />
并不是这样，我们再来回顾一下中学物理: <br />
过阻尼状态的摆会以较慢的速度回到平衡位置；<br />
欠阻尼状态的摆会很快回到平衡位置，但会在平衡位置来回摆动；<br />
临界阻尼状态的摆会以最快的速度稳定在平衡位置。</p>

<p>结合到实际的自行车平衡中就是：<br />
如果回复力不够大，就无法矫正，或者矫正速度很慢，这会导致系统不稳定；<br />
如果回复力过大，就会导致矫正过度，这也会导致系统不稳定；
我们最希望的状态就是回复力刚刚好，刚好使倒立摆快速回到平衡位置，又不至于矫正过度。</p>

<p>这是一个复杂的数学计算过程，回复力大小会在系统运行时不断地计算(本平衡自行车是20ms计算一次)，用到的是PID算法，会在后面详细介绍。</p>

<h2 id="section-6">3、自行车平衡需要解决的基本问题</h2>

<ol>
  <li>获取左右方向倾角θ</li>
  <li>以合适的算法控制转角α使系统稳定平衡</li>
</ol>

<p>这将会在下面详细讨论。</p>

<h1 id="section-7">二、姿态检测</h1>

<h2 id="section-8">1、检测的是什么</h2>
<p>检测的是自行车左右倾斜的角度。</p>

<h2 id="section-9">2、怎么检测</h2>
<p>用一个叫gy521的模块，里面用的是mpu6050芯片，带有陀螺仪和加速度传感器。
gy521的具体使用会在第三篇-实践篇介绍，这里我们知道通过这个模块我们可以得到自行车各个方向的加速度和角速度。
注意哦，我们不能直接得到倾斜角度，我们的到的是各个方向的加速度和角速度，需要进行一些复杂的计算才能得到正确的倾斜角度。</p>

<p>常用的算法有互补平衡滤波、卡尔曼滤波，由于篇幅和精力问题这部分暂不介绍，网上有大量资源，也可以查看本工程源码，以后有时间再写详细教程。</p>

<h1 id="pid">三、PID算法</h1>

<p>前面已经分析了，我们通过控制把手转角来控制回复力，我们需要实时计算一个合适的回复力使系统稳定平衡。</p>

<p>这部分内容也不做详细介绍了，网上有大量资源，也可以查看本工程源码。</p>

<p>在这里引用<a href="http://www.diy-robots.com/">动力老男孩</a>举的一个例子，帮大家简单理解一下需要解决的问题，以及PID算法是如何解决的。</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/7.jpg" alt="7.jpg" /></p>

<p>有一个小球在光滑球面上，小球的位置是x，光滑球面顶端在L处，我们可以控制小球水平方向力F，现在要求让小球稳定平衡在x0处。</p>

<p>先看简单情况 x0=L，此时偏差为 L-x，</p>

<p>我们给出一个比例项(P) F = kp*(L-x)，这样就会有一个回复力，当偏差存在时就会有一个力把小球拉回L处。<br />
这存在的问题是，小球接近L时是会有一定速度的，小球越来越接近L，此时的力仍然是在把小球往L处拉，这会导致小球到达L时(我们想要的位置)速度很大，小球无法立刻停下来，而是会冲过去。<br />
这样小球就会在L附近来回摆动，这是不稳定的状态，属于欠阻尼状态。</p>

<p>为了解决上述问题需要加一个微分项(D) F = kd*dx/dt = kd*v，所谓”微分”指的是位置x对时间的微分，说白了就是速度。<br />
意思就是当速度越大，就产生一个反向的力使速度减小，这样就可以防止出现上面小球冲过去的。<br />
可以认为这一项具有”预测”功能，预测小球下一时刻的状态从而提前做出反应(预测小球将要到达L处，提前减速)，<br />
也可以认为这一项具有阻尼作用，相当于系统中有一个和速度成比例的阻尼力。<br />
这个”阻尼力”调得过小会导致欠阻尼状态，调得过大会导致过阻尼状态。</p>

<p>积分项此时可以不用，积分项是当平衡位置x0不等于L时使用的，<br />
当平衡位置不是L处，那么当小球静止在平衡位置x0时，由于在坡道上会有一个恒定的横向偏移力，此时比例调节作用为0(Δx=0)，微分调节作用也是0(v=0)，所以小球在该处无法平衡，会在更远离平衡位置处达到平衡，那么就会有一个长时间存在的偏差。<br />
积分作用就是检测偏差进行累积，对于上面这个长时间存在的偏差进行积分(累积叠加)，使系统在长时间范围可以稳定在要求的平衡位置。</p>

<h1 id="section-10">四、广告</h1>

<p>老婆做毕业设计，给我下了死命令，一定要找300个程序员研究一下，请各位同行做个调查问卷，可扫描下面二维码或者直接点击此链接：<a href="https://www.wjx.cn/jq/17710478.aspx">https://www.wjx.cn/jq/17710478.aspx</a>，多谢！</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-21-ping-heng-zi-xing-che-li-lun-pian/ad.jpg" alt="ad.jpg" /></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自行车平衡原理]]></title>
    <link href="http://nicekwell.net/blog/20180118/zi-xing-che-ping-heng-yuan-li.html"/>
    <updated>2018-01-18T13:54:43+08:00</updated>
    <id>http://nicekwell.net/blog/20180118/zi-xing-che-ping-heng-yuan-li</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1、角动量守恒说</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2、转向时的”离心力”是自行车平衡的根本原因</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">机械自平衡</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">手动自平衡</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">另一种我们这里不讨论的平衡</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">广告</a></li>
</ul>
<p>  </p>

<p>博主曾做过一个自平衡的自行车，</p>

<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMjg1NzUwOTY4NA?color=white&amp;theme=light"></iframe>

<p>早就想写一个教程，一直拖了很长时间，这几天下定决心一定要战胜拖延症。</p>

<p>自行车平衡DIY分为3部分介绍：<br />
第一部分也就是本文，介绍自行车平衡基本物理原理；<br />
第二部分理论篇，对平衡自行车的算法进行理论分析，包括模型分析、姿态检测方法、PID算法，控制算法；<br />
第三部分实践篇，具体介绍平衡自行车用到的元器件，动力、转向、电路及代码分析。</p>

<!-- more -->

<p>自行车是怎么平衡的，老外做过一个非常好的视频：<a href="https://www.youtube.com/watch?v=oZAc5t2lkvo">https://www.youtube.com/watch?v=oZAc5t2lkvo</a>，国内在这看：<a href="https://www.bilibili.com/video/av2659132/">https://www.bilibili.com/video/av2659132/</a>。</p>

<p>这个视频很好地证明了常见的”角动量守恒”的说法是错误的，并且正确的说明了自行车平衡原理是和转向相关的，但没有具体指出平衡和转向的关系。</p>

<p>在这里我们就先来讨论一下”角动量守恒”这种最常见的猜测为什么是错误的，大致讨论一下转向是如何使自行车保持平衡的。</p>

<h2 id="section">1、角动量守恒说</h2>

<p>角动量守恒说的意思就是：轮子跑的时候在转动，此时轮子就类似于陀螺，角动量守恒使自行车保持不倒。</p>

<p>小时候也有过这样的疑问，如果把自行车车轮固定从下坡推下，自行车能不能一直往前走？</p>

<p>到底能不能呢？老外的视频做了这个试验：</p>

<iframe style="margin:0 auto; display: block" height="340" width="480" src="http://player.youku.com/embed/XMzMyOTQ1NjU1Mg?color=white&amp;theme=light"></iframe>

<p>固定之后就会倒下，可见轮子的陀螺仪效应并不是维持自行车不倒的原因。<br />
另外还有老外做了一个没有陀螺仪效应的自行车，该自行车也可以稳定平衡：</p>

<iframe style="margin:0 auto; display: block" height="340" width="480" src="http://player.youku.com/embed/XMzMyOTQ1ODgzNg?color=white&amp;theme=light"></iframe>

<p>以上足以说明陀螺仪效应不是维持自行车平衡的根本原因。</p>

<h2 id="section-1">2、转向时的”离心力”是自行车平衡的根本原因</h2>

<p>那么什么才是维持自行车平衡的原因呢？</p>

<p><strong>自行车可以看做是一个倒立摆（左右方向不稳定），这个倒立摆受重力作用是一个不稳定系统，需要额外的回复力维持平衡，而提供回复力的正是自行车转向时的”离心力”。<br />
离心力是速度和把手转向角的函数，在一个固定的速度下，可以认为控制把手转向角度就是控制回复力。</strong></p>

<p>我们先记住这一点：<strong>维持自行车平衡，需要通过一种合适的算法控制把手角度才能使自行车稳定平衡。</strong></p>

<h3 id="section-2">机械自平衡</h3>

<p>或许有人会奇怪，有些自行车只要推起来就可以自己平衡，如下面视频：</p>

<iframe style="margin:0 auto; display: block" height="340" width="480" src="http://player.youku.com/embed/XMzMyOTQ2MTAyOA?color=white&amp;theme=light"></iframe>

<p>我自己也买过一个如下面这样的遥控摩托车想要研究一下：</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-18-zi-xing-che-ping-heng-yuan-li/moto.jpg" alt="moto.jpg" /></p>

<p>拆开后发现里面并没有精确的转向控制结构，仿佛在行驶时根本没有转向控制，就类似于上面自行车一样自己就可以平衡了。</p>

<p>这到底是怎么回事呢？其实这就是结构设计者的牛逼之处，设计的机械结构自带回复功能，机械结构使得转向会根据车身倾斜而改变，这种改变的幅度正好可以使自行车稳定平衡。<br />
如果我们改变车身结构，可能就会破坏原有的参数，使得自行车无法稳定平衡。如在前轮绑一个重物：</p>

<iframe style="margin:0 auto; display: block" height="340" width="480" src="http://player.youku.com/embed/XMzMyOTQ1ODI4OA?color=white&amp;theme=light"></iframe>

<p>在老外的视频中，分析了车身倾斜对转向的三个影响因素：</p>

<ol>
  <li>前轮转轴后倾，导致倾斜时前轮转向。</li>
  <li>把手安装在前面，导致倾斜时前轮转向。</li>
  <li>前轮转动时的陀螺仪效应，车身倾斜，陀螺仪效应使得前轮转向。</li>
</ol>

<iframe style="margin:0 auto; display: block" height="340" width="480" src="http://player.youku.com/embed/XMzMzMDEyMjMxMg?color=white&amp;theme=light"></iframe>

<p>以上是所谓”机械自平衡”，平衡根本原因还是转向，只不过巧妙的机械设计使得前轮转向特性恰好很容易维持平衡。</p>

<h3 id="section-3">手动自平衡</h3>

<p>手动自平衡的意思就是我们自己手动控制让它平衡。</p>

<p>我们既然分析平衡原理，还要做一个平衡自行车出来，这一部分要好好研究一下，将会在后面理论篇重点讨论一下控制方法。</p>

<h3 id="section-4">另一种我们这里不讨论的平衡</h3>

<p>需要提一下，这里不考虑骑自行车的人在自行车上的旋转，这是另一种平衡方式，原理和下面视频类似，这里不讨论这种平衡。</p>

<iframe style="margin:0 auto; display: block" height="340" width="480" src="http://player.youku.com/embed/XMjcwNDE1NjA?color=white&amp;theme=light"></iframe>

<h2 id="section-5">广告</h2>

<p>老婆做毕业设计，给我下了死命令，一定要找300个程序员研究一下，请各位同行做个调查问卷，可扫描下面二维码或者直接点击此链接：<a href="https://www.wjx.cn/jq/17710478.aspx">https://www.wjx.cn/jq/17710478.aspx</a>，多谢！</p>

<p><img src="http://nicekwell.net/images/diy/2018-01-18-zi-xing-che-ping-heng-yuan-li/ad.jpg" alt="ad.jpg" /></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stm32串口isp]]></title>
    <link href="http://nicekwell.net/blog/20180118/stm32chuan-kou-isp.html"/>
    <updated>2018-01-18T10:59:36+08:00</updated>
    <id>http://nicekwell.net/blog/20180118/stm32chuan-kou-isp</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">广告</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">下载协议</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">1、硬件</a></li>
      <li><a href="#sync" id="markdown-toc-sync">2、sync</a></li>
      <li><a href="#get-command" id="markdown-toc-get-command">3、get command</a></li>
      <li><a href="#get-version--read-protection" id="markdown-toc-get-version--read-protection">4、get version &amp; read protection</a></li>
      <li><a href="#get-id-command" id="markdown-toc-get-id-command">5、get ID command</a></li>
      <li><a href="#erase-memory-command" id="markdown-toc-erase-memory-command">6、Erase Memory command</a></li>
      <li><a href="#write-memory-command" id="markdown-toc-write-memory-command">7、Write Memory command</a></li>
      <li><a href="#read-memory-command" id="markdown-toc-read-memory-command">8、Read Memory command</a></li>
      <li><a href="#go-command" id="markdown-toc-go-command">9、Go command</a></li>
    </ul>
  </li>
  <li><a href="#section-4" id="markdown-toc-section-4">代码说明</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">程序结构</a></li>
      <li><a href="#stm32isp" id="markdown-toc-stm32isp">stm32isp接口</a>        <ul>
          <li><a href="#stm32ispinit" id="markdown-toc-stm32ispinit">stm32isp_init</a></li>
          <li><a href="#stm32ispclose" id="markdown-toc-stm32ispclose">stm32isp_close</a></li>
          <li><a href="#stm32ispsync" id="markdown-toc-stm32ispsync">stm32isp_sync</a></li>
          <li><a href="#stm32ispgetcommand" id="markdown-toc-stm32ispgetcommand">stm32isp_get_command</a></li>
          <li><a href="#stm32ispgetidcommand" id="markdown-toc-stm32ispgetidcommand">stm32isp_get_ID_command</a></li>
          <li><a href="#stm32isperaseall" id="markdown-toc-stm32isperaseall">stm32isp_erase_all</a></li>
          <li><a href="#stm32ispwritebin" id="markdown-toc-stm32ispwritebin">stm32isp_write_bin</a></li>
          <li><a href="#stm32ispverify" id="markdown-toc-stm32ispverify">stm32isp_verify</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>这里介绍stm32串口isp实现方法，包含st官方协议整理和实现代码。</p>

<!-- more -->

<p>已提交到github <a href="https://github.com/nicekwell/stm32ISP">https://github.com/nicekwell/stm32ISP</a>，这里把工程README复制过来。</p>

<h1 id="section">概述</h1>

<p>stm32串口ISP程序，基于c语言。<br />
在ubuntu和mac下测试都ok，ubuntu下需要修改/dev/ttyUSB0权限，mac下不需要修改。<br />
本程序在stm32f103c8t6上ok，根据官方文档，其他型号单片机下载协议相同，但没有测试过。</p>

<p>使用方法：<br />
<strong>stm32isp /dev/ttyUSB0 stm32_test.bin</strong><br />
mac下的usb串口节点是 /dev/tty.usbserial</p>

<p>注：</p>

<ol>
  <li>波特率固定为57600不允许修改。实际上测试了各种波特率，只有57600和38400可以稳定下载（程序写的还不太稳定吧），所以波特率固定为了57600。</li>
  <li><strong>下载的是bin文件，不是hex文件</strong>。bin文件是纯粹的编码，hex文件包含了地址信息。keil默认不生成bin文件，生成bin文件的方法可网上查找。</li>
</ol>

<h1 id="section-1">广告</h1>

<p>老婆做毕业设计，给我下了死命令，一定要找300个程序员研究一下，请各位同行做个调查问卷，可扫描下面二维码或者直接点击此链接：<a href="https://www.wjx.cn/jq/17710478.aspx">https://www.wjx.cn/jq/17710478.aspx</a>，多谢！</p>

<p><img src="https://github.com/nicekwell/stm32ISP/raw/master/documents/ad.jpg" alt="ad.jpg" /></p>

<h1 id="section-2">下载协议</h1>

<p>stm32官方文档已提交到本工程 documents 目录下。<a href="https://github.com/nicekwell/stm32ISP/raw/master/documents/stm32isp%20application%20note.pdf">https://github.com/nicekwell/stm32ISP/raw/master/documents/stm32isp%20application%20note.pdf</a></p>

<h2 id="section-3">1、硬件</h2>
<p>首先要让stm32进入bootloader启动：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">引脚</th>
      <th style="text-align: center">电平</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">BOOT0</td>
      <td style="text-align: center">高电平</td>
    </tr>
    <tr>
      <td style="text-align: center">BOOT1</td>
      <td style="text-align: center">低电平</td>
    </tr>
  </tbody>
</table>

<p>这样启动后就会从system分区启动，开始接收串口数据。</p>

<p>连接串口1：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">引脚</th>
      <th style="text-align: center">功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">PA9</td>
      <td style="text-align: center">TXD，连接host RXD</td>
    </tr>
    <tr>
      <td style="text-align: center">PA10</td>
      <td style="text-align: center">RXD，连接host TXD</td>
    </tr>
  </tbody>
</table>

<h2 id="sync">2、sync</h2>
<p>以下数据指的是响应host或device端发送的数据。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">host</th>
      <th style="text-align: center">device</th>
      <th style="text-align: center">note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0x7f</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">发送0x7f，单片机收到后会自动匹配波特率。</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center">device返回ACK或NACK，表示对host的反应。</td>
    </tr>
  </tbody>
</table>

<p>适配波特率这一步是无条件执行的，执行完这一步之后就可以接收各种指令。<br />
下面就介绍各个指令的功能和数据协议。</p>

<h2 id="get-command">3、get command</h2>

<p>在上面已经适配波特率情况下可以执行此指令。<br />
【指令码】0x00<br />
【功能】获取stm32里bootloader版本号，以及所有支持的指令代码。<br />
【数据协议】</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">host</th>
      <th style="text-align: center">device</th>
      <th style="text-align: center">note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0x00 + 0xff</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">N</td>
      <td style="text-align: center">1字节，表示下面要接收到的字节数。bootloaderversion字节数 + 所有指令字节数 = N+1</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">bootloader version</td>
      <td style="text-align: center">1字节，如0x21代表2.1版本</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">所有支持的指令</td>
      <td style="text-align: center">多个字节，每个字节数据都表示一个支持的指令</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center">指令执行结束后会返回0x79</td>
    </tr>
  </tbody>
</table>

<h2 id="get-version--read-protection">4、get version &amp; read protection</h2>
<p>【指令码】0x01<br />
【功能】获取stm32里bootloader版本号，读取保护状态。<br />
【数据协议】</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">host</th>
      <th style="text-align: center">device</th>
      <th style="text-align: center">note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0x01+0xfe</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">bootloader version</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">2个字节</td>
      <td style="text-align: center">这两个字节和保护状态有关</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h2 id="get-id-command">5、get ID command</h2>
<p>【指令码】0x02<br />
【功能】获取stm32 PID（product ID，不是芯片唯一识别码）。<br />
【数据协议】</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">host</th>
      <th style="text-align: center">device</th>
      <th style="text-align: center">note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0x02+0xfd</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">N</td>
      <td style="text-align: center">1字节，表示下面 PID字节数 - 1</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">PID</td>
      <td style="text-align: center">多字节(上一个字节已指明字节数)，先传高位后传低位。我这次用的stm32f103c8t6是2字节。</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h2 id="erase-memory-command">6、Erase Memory command</h2>
<p>【指令码】0x43<br />
【功能】擦除flash，可以全擦或擦除一部分，这里只介绍全擦。<br />
【数据协议】</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">host</th>
      <th style="text-align: center">device</th>
      <th style="text-align: center">note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0x43+0xbc</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">0xff+0x00</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">这是全擦指令</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h2 id="write-memory-command">7、Write Memory command</h2>
<p>【指令码】0x31<br />
【功能】<br />
写存储器，可以写任意的RAM、flash，我们写程序就用这个。<br />
【数据协议】</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">host</th>
      <th style="text-align: center">device</th>
      <th style="text-align: center">note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0x31+0xCE</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">addr</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">4字节，下载地址。用户flash起始地址是0x08000000。<strong>先发高位，后发低位</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">addr checksum</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">1字节，地址的checksum，就是上面4字节数据的异或。</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">count</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">1字节，表示后面将要传输的字节数，范围(0, 255]。<strong>字节数 = 这个值+1</strong>，也就是说最大传输256字节。</td>
    </tr>
    <tr>
      <td style="text-align: center">data</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">多字节，字节数 = count + 1，最大256字节。<strong>这里下载进去的是bin文件，不是hex。。</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">checksum</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">1字节，上面的data数据，以及数据个数count的checksum。注意这里的checksum包含<strong>数据和个数</strong>。</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>注：</p>

<ol>
  <li>对于写flash，用户flash的起始地址是0x08000000。</li>
  <li>对于写flash，这里最多一次写256字节，写一个bin文件需要多次使用此协议写入。</li>
</ol>

<h2 id="read-memory-command">8、Read Memory command</h2>
<p>【指令码】0x11<br />
【功能】<br />
读取stm32内存，可以读取stm32任意地址的RAM、flash等数据。<br />
我们常在下载完成后把flash内容读取出来验证。<br />
【数据协议】</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">host</th>
      <th style="text-align: center">device</th>
      <th style="text-align: center">note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0x11+0xEE</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">addr</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">4字节，下载地址。用户flash起始地址是0x08000000。<strong>先发高位，后发低位</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">addr checksum</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">1字节，地址的checksum，就是上面4字节数据的异或。</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">count</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">1字节，将要读取的数据个数，0~255。count+1就是将要读取的字节数，最多读取256字节。</td>
    </tr>
    <tr>
      <td style="text-align: center">checksum</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">1字节，count的按位取反。</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">0x79(ACK)/0x1F(NACK)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">data</td>
      <td style="text-align: center">count+1个字节，这就是要读取的数据。</td>
    </tr>
  </tbody>
</table>

<p>注：</p>

<ol>
  <li>对于读取flash，用户flash的起始地址是0x08000000。</li>
  <li>一次最多读取256字节，要读取大段内容就重复执行这个读取操作。</li>
</ol>

<h2 id="go-command">9、Go command</h2>
<p>略。</p>

<h1 id="section-4">代码说明</h1>
<p>根据上面的下载协议，封装成了模块，这里介绍本程序结构和模块的使用，以便移植到其他地方。</p>

<h2 id="section-5">程序结构</h2>

<p><strong>wiringSerial.c wiringSerial.h</strong><br />
串口驱动，在树莓派<a href="https://github.com/WiringPi/WiringPi">wiringPi</a>基础上修改，增加了数据块读写代码，增加了更多设置项。<br />
这部分驱动在mac、桌面ubuntu、树莓派上都可以使用。</p>

<p><strong>stm32isp.c stm32isp.h</strong><br />
下载逻辑代码，基于串口驱动，串口的打开、关闭操作也归于这部分控制。<br />
以上两个部分，serial完全归于stm32isp，外部使用stm32isp时不需要再管串口了。</p>

<p><strong>main.c</strong><br />
程序交互的实现，调用上面stm32isp接口实现下载。</p>

<p>下面着重介绍的是stm32isp部分的接口函数。</p>

<h2 id="stm32isp">stm32isp接口</h2>
<p>stm32isp使用前提是串口工作正常。</p>

<h3 id="stm32ispinit">stm32isp_init</h3>
<p><code>int stm32isp_init(const char *device, const int baud, const int databits, const int stopbits, const char parity, const int timeout);</code><br />
使用前需要先调用此函数，主要是完成串口初始化（串口的打开和关闭也交给stm32isp模块管理）。<br />
例：<code>stm32isp_init("/dev/ttyUSB0", 57600, 8, 1, 'N', 30);</code><br />
注：此驱动测试只有57600和38400两个波特率可以正常下载。</p>

<h3 id="stm32ispclose">stm32isp_close</h3>
<p><code>void stm32isp_close();     //成功返回1，失败返回0</code><br />
下载结束后调用此函数，主要是完成串口关闭（串口的打开和关闭也交给stm32isp模块管理）。</p>

<h3 id="stm32ispsync">stm32isp_sync</h3>
<p><code>int stm32isp_sync();</code><br />
同步波特率，成功返回1，失败返回0。
打开串口后第一步就需要sync，和单片机同步波特率。</p>

<h3 id="stm32ispgetcommand">stm32isp_get_command</h3>
<p><code>int stm32isp_get_command()</code><br />
获取ID和command列表，信息保存在驱动内部结构体，不输出，但会进行打印信息。成功返回1，失败返回0。<br />
这一步不是下载必须执行的。</p>

<h3 id="stm32ispgetidcommand">stm32isp_get_ID_command</h3>
<p><code>int stm32isp_get_ID_command();</code><br />
获取PID，信息保存在驱动内部结构体，不输出，但会进行打印。成功返回1，失败返回0。<br />
这一步不是下载必须执行的。</p>

<h3 id="stm32isperaseall">stm32isp_erase_all</h3>
<p><code>int stm32isp_erase_all();</code>
全擦flash，成功返回1，失败返回0。<br />
下载之前先擦除flash。</p>

<h3 id="stm32ispwritebin">stm32isp_write_bin</h3>
<p><code>int stm32isp_write_bin(char *p);</code><br />
传入bin文件路径，写入bin文件到flash，成功返回1，失败返回0。<br />
注意写入的是bin文件，不是hex文件。<br />
bin文件路径可能由main函数的argv参数传入。</p>

<h3 id="stm32ispverify">stm32isp_verify</h3>
<p><code>int stm32isp_verify(char *p);</code><br />
传入bin文件路径，根据bin文件大小读取flash相应大小内容，并把两个比较，验证成功返回1，失败返回0。<br />
这一步可选，为了保险可下载后验证一下。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-wiringPi-C的i2c库使用]]></title>
    <link href="http://nicekwell.net/blog/20171124/shu-mei-pai-wiringpi-wiringpi-cde-i2cku-shi-yong.html"/>
    <updated>2017-11-24T13:36:14+08:00</updated>
    <id>http://nicekwell.net/blog/20171124/shu-mei-pai-wiringpi-wiringpi-cde-i2cku-shi-yong</id>
    <content type="html"><![CDATA[<p>  </p>

<p>在linux上层有一个操作i2c的通用接口——smbus，在这里我们不介绍smbus的使用，但要知道wiringPi的i2c接口就是在linux上层基于smbus封装的。<br />
wiringPi封装的函数中，有byte和word的读写，但是没有封装block的读写。也就是说，没有提供一次写大块数据的方法。</p>

<!-- more -->

<p> </p>

<p><strong>&lt;file&gt; = wiringPiI2CSetup(int &lt;从机地址&gt;);</strong><br />
打开i2c设备。<br />
输入的是7位的从机地址，不需要输入i2c设备节点路径。<br />
返回的是linux标准的设备文件描述符。</p>

<p>实际的处理过程是这样的：<br />
wiringPi自动检测i2c设备文件路径（/dev/i2c-0或/dev/i2c-1）；<br />
然后打开文件，获取到了标准文件描述符；<br />
然后通过ioctl设置从机地址。</p>

<p> </p>

<p><strong>int wiringPiI2CWrite(int fd,int data);</strong><br />
往从机写一个字节。<br />
也就是从机地址后的一个字节，通常是command。<br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;data&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CWriteReg8(int fd, int reg, int data);</strong><br />
往从机指定的reg写入1个字节。<br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;reg&gt; + &lt;data&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CWriteReg16(int fd, int reg, int data);</strong><br />
往从机指定的reg写2个字节，<strong>先传输低8位，后传输高8位。</strong><br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;reg&gt; + &lt;data低8位&gt; + &lt;data高8位&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CRead(int fd);</strong><br />
从从机直接读取一个字节，不写入任何cmd。<br />
<em>&lt;起始&gt; + &lt;从机地址R&gt; + &lt;读1个字节&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CReadReg8(int fd, int reg);</strong><br />
读取从机指定reg的一个字节。<br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;reg&gt; + &lt;起始&gt; + &lt;从机地址R&gt; + &lt;读1个字节&gt; + &lt;结束&gt;</em></p>

<p> </p>

<p><strong>int wiringPiI2CReadReg16(int fd, int reg);</strong><br />
读取从机指定reg的两个字节，<strong>先传输低8位，后传输高8位。</strong><br />
<em>&lt;起始&gt; + &lt;从机地址W&gt; + &lt;reg&gt; + &lt;起始&gt; + &lt;从机地址R&gt; + &lt;读低8位&gt; + &lt;读高8位&gt; + &lt;结束&gt;</em></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-树莓派的i2c配置]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shu-mei-pai-de-i2cpei-zhi.html"/>
    <updated>2017-11-23T20:35:11+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shu-mei-pai-de-i2cpei-zhi</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#i2c" id="markdown-toc-i2c">1、开启树莓派i2c设备</a></li>
  <li><a href="#i2c-1" id="markdown-toc-i2c-1">2、确认i2c模块加载成功</a></li>
  <li><a href="#i2c-detecti2c" id="markdown-toc-i2c-detecti2c">3、i2c detect检测i2c设备</a></li>
  <li><a href="#i2c-2" id="markdown-toc-i2c-2">4、i2c的波特率</a></li>
</ul>
<p>  </p>

<p>介绍如何在树莓派上配置i2c，包括开关、波特率，以及i2cdetect的简单使用。</p>

<!-- more -->

<h3 id="i2c">1、开启树莓派i2c设备</h3>
<p>树莓派的i2c默认是关闭的。网上找了很多打开i2c的方法，基本上都是：<br />
1、修改 /etc/modules，添加i2c模块开机自动启动。<br />
2、修改 /etc/modprobe.d/raspi-blacklist.conf 黑名单中去掉i2c模块。<br />
但是怎么改都不行，可能是树莓派系统升级了，和以前的设置方法不一样了。<br />
正确的方法是：<br />
1、sudo raspi-config<br />
2、Advanced Options –&gt; I2C –&gt; 开启i2c设备 –&gt; 重启。<br />
加载成功的话会生成 <strong>/dev/i2c-x</strong> 文件，x是总线序号。</p>

<h3 id="i2c-1">2、确认i2c模块加载成功</h3>
<p><strong>lsmod</strong><br />
会看到 i2c_dev 和 i2c_bcm2708 两项。</p>

<h3 id="i2c-detecti2c">3、i2c detect检测i2c设备</h3>
<p>linux下有个i2c工具程序可以方便地检测i2c设备。<br />
1、 安装 i2c-tools<br />
<strong>sudo apt-get install i2c-tools</strong><br />
2、列出所有i2c总线<br />
<strong>i2cdetect -l</strong><br />
如果i2c设备成功打开，将会看到<br />
i2c-1   i2c   3f804000.i2c    I2C adapter<br />
3、列出i2c总线上的所有i2c设备<br />
<strong>i2cdetect -y &lt;总线&gt;</strong><br />
列出总线上所有地址上的设备，形如：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">.    0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
</span><span class="line">00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- -- 
</span><span class="line">40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
</span><span class="line">60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span></code></pre></td></tr></table></div></figure>

<p><strong>这个功能会启动i2c检测电路，电路上实际连接了哪些设备这里就会显示哪些设备。电路上不连接设备的话在这里是不会显示的。</strong><br />
<strong>检测到的是7位的i2c地址。</strong></p>

<p>i2ctools的其他使用在linux里的工具使用中有专门介绍。</p>

<h3 id="i2c-2">4、i2c的波特率</h3>
<p>获取当前波特率：<br />
<strong>sudo cat /sys/module/i2c_bcm2708/parameters/baudrate</strong><br />
设置波特率：<br />
<strong>sudo emacs /etc/modprobe.d/custom.conf</strong><br />
添加一行设置：<br />
<strong>options i2c_bcm2708 baudrate=100000</strong><br />
设置后需要重启才能生效。</p>

<p> </p>

<p>实际测量clk引脚的结果：</p>

<table>
  <tbody>
    <tr>
      <td>设置的频率</td>
      <td>示波器测量的脉宽</td>
      <td>周期</td>
      <td>示波器测量的频率</td>
      <td>传输addr+cmd+20字节所需要的时间</td>
      <td> </td>
    </tr>
    <tr>
      <td>32000(32k)</td>
      <td>25us</td>
      <td>50us</td>
      <td>20kHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>100000(100k)</td>
      <td>8us</td>
      <td>16us</td>
      <td>41.67kHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>1000000(1M)</td>
      <td>800ns</td>
      <td>1600ns</td>
      <td>417KHz</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>2000000(2M)</td>
      <td>400ns</td>
      <td>800ns</td>
      <td>833.4kHz</td>
      <td> </td>
      <td>波形略有失真，可能和外部电路设计也有关系。</td>
    </tr>
    <tr>
      <td>3000000(3M)</td>
      <td>250ns</td>
      <td>500ns</td>
      <td>1.894MHz</td>
      <td> </td>
      <td>波形已经失真严重，设备接收异常。</td>
    </tr>
  </tbody>
</table>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-UART串口]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-uartchuan-kou.html"/>
    <updated>2017-11-23T20:05:37+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-uartchuan-kou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">0、包含头文件</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">1、打开串口</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">2、写入（发送）</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">3、读取（接收）</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">4、缓冲区操作</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">5、关闭串口</a></li>
</ul>
<p>  </p>

<p>前面介绍了python操作串口的方法，是通过通用的串口库实现的。<br />
用c语言当然也可以通过通用串口接口实现，而wiringPi也提供了自己的一套串口操作函数，可以很方便地操作串口。<br />
事实上，wiringPi就是在上层利用通用串口操作接口，封装了一套自己的库函数。</p>

<!-- more -->

<h3 id="section">概述</h3>

<p>在前面python串口编程处就介绍了，树莓派3B的板载串口被蓝牙占用，但可以方便地使用USB串口模块。</p>

<p>树莓派的板载串口是给系统登录使用的，我们要先把这个功能关掉。<br />
<strong>sudo raspi-config</strong><br />
Advanced Options –&gt; Serial –&gt; 关闭串口 –&gt; 重启</p>

<p>树莓派上有两个串口，一个硬件串口，工作稳定，但是分配给了蓝牙；还有一个“mini-uart”，这个串口的时钟是由内核提供，所以不太稳定 。 在树莓派3B上，蓝牙和硬件串口是不能兼得。<br />
这个链接(http://ukonline2000.com/?p=880)有介绍如何把硬件串口分配到GPIO14、GPIO15上，这里不做介绍了。</p>

<p>总之，在树莓派3B上，想要使用板载硬件串口是比较麻烦的，我们这里使用的是USB转串口模块，也能很方便地使用串口。</p>

<h3 id="section-1">0、包含头文件</h3>

<p><strong>#include &lt;wiringSerial.h&gt;</strong></p>

<h3 id="section-2">1、打开串口</h3>

<p><strong>&lt;fd&gt; = serialOpen(char* device, int buad);</strong><br />
【功能】<br />
打开串口文件，并设置波特率，返回文件编号。<br />
【输入】</p>

<table>
  <tbody>
    <tr>
      <td>*device</td>
      <td>设备路径的字符串。比如 “/dev/ttyUSB0”</td>
    </tr>
    <tr>
      <td>buad</td>
      <td>波特率，是一个数值。可以设置为：2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</td>
    </tr>
  </tbody>
</table>

<p>【输出】一个文件编号，代表这个串口设备文件，后面对这个串口的操作都会用到。<br />
【说明】<br />
1、wiringPi提供的设置（以及后面的读写功能）是简化的文件操作，可以满足大部分需求。<br />
2、这里的<file编号>是标准的linux文件描述符，可以使用linux标准的文件操作函数write()、read()等来操作。</file编号></p>

<p>后面也会有说明，wiringPi提供的读写功能是简化的，不提供二进制数值读写，但是可以使用linux标准的读写函数来操作。</p>

<h3 id="section-3">2、写入（发送）</h3>

<p><strong>void serialPutchar(int fd, unsigned char c) ;</strong><br />
【功能】发送一个字节数据。<br />
【输入】<br />
fd是打开串口时的文件描述符。<br />
输入的就是一个字节数据，可以用字符表示，也可以用十六进制数表示。</p>

<p><strong>void serialPuts(int fd, char *s) ;</strong><br />
【功能】发送字符串。<br />
【输入】<br />
fd是打开串口时的文件描述符。<br />
*s 是一个字符串，会发送该字符串，直到’\0’结束。<strong>‘\0’不会发送出去。</strong></p>

<p><strong>void serialPrintf(int fd, char *message, …) ;</strong><br />
【功能】功能类似于printf，可以同时发送多个字符串。</p>

<p> </p>

<p>注意：<strong>以上两个发送函数只是把数据推送到发送缓冲区里，不会等待串口发送完成。</strong>后续程序如果要用到用到串口返回数据应当要考虑到串口传输时间。<br />
<strong>并且最好等之前的数据全部发送完成后再发送新数据，否则可能会出问题，这也要考虑到串口发送数据的时间，可能需要等待。</strong><br />
关键是上层还没有找到判断串口发送完成的方法。</p>

<h3 id="section-4">3、读取（接收）</h3>

<p><strong>int serialDataAvail(int fd) ;</strong><br />
【功能】获取接收缓冲区里的字节数。<br />
【输入】创建串口设备文件时的文件描述符。<br />
【输出】接收缓冲区里所存放的数据字节数。</p>

<p><strong>int serialGetchar(int fd) ;</strong><br />
【功能】从接收缓冲区里读取一个字节数据。<br />
【输入】创建串口设备文件时的文件描述符。<br />
【输出】读取到的一个字节内容。虽然是一个字节内容，但仍然定义为了int型。<br />
【说明】<br />
<strong>如果缓冲区里没有数据，则会等待10s，相当于python里把timeout设置为10s。<br />
10s过后如果还没有数据的话，则会返回 -1，十六进制显示为 0xffffffff。</strong>
这里的10s是wiringPi默认的，查看源代码可以看到：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-23-shu-mei-pai-wiringpi-uartchuan-kou/1.png" alt="1.png" /></p>

<h3 id="section-5">4、缓冲区操作</h3>
<p><strong>void serialFlush(int fd) ;</strong><br />
清空缓冲区，放弃所有数据。</p>

<h3 id="section-6">5、关闭串口</h3>
<p><strong>void serialClose(int fd) ;</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-优先级&amp;中断&amp;线程]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng.html"/>
    <updated>2017-11-23T19:48:00+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-you-xian-ji-and-zhong-duan-and-xian-cheng</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi库真是包含了各个方面，甚至提供了进程操作接口。<br />
使用wiringPi的接口可以很方便地创建新进程。</p>

<!-- more -->

<p> </p>

<p><strong>int piHiPri (int priority) ;</strong><br />
设置进程优先级。范围是0~99，数字越大优先级越高，默认是0。<br />
返回0代表成功，返回-1代表失败。<br />
注：必须已root身份运行，否则无效。</p>

<p> </p>

<p><strong>int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;</strong><br />
设置某个pin作为中断脚，当触发中断时调用指定函数。<br />
估计实现原理是后台用了一个定时器不断扫描这个引脚。<br />
pin是引脚序号，编号方式在Setup时决定。<br />
edgeType是中断触发方式：</p>

<table>
  <tbody>
    <tr>
      <td>INT_EDGE_FALLING</td>
      <td>下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_RISING</td>
      <td>上升沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_BOTH</td>
      <td>上升沿和下降沿</td>
    </tr>
    <tr>
      <td>INT_EDGE_SETUP</td>
      <td>未设置</td>
    </tr>
  </tbody>
</table>

<p>中断处理函数传入函数指针即可。</p>

<p> </p>

<p><strong>int piThreadCreate (PI_THREAD func) ;</strong><br />
创建一个线程执行func函数。要求func函数用PI_THREAD声明。<br />
返回0代表创建成功，非0代表失败。<br />
例：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">PI_THREAD</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span>    <span class="c1">//注意这种声明方式，函数名用括号括起来，不带参数</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line">	<span class="n">piThreadCreate</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
</span><span class="line">	<span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p> </p>

<p><strong>piLock (int keyNum) ;</strong><br />
<strong>piUnlock (int keyNum) ;</strong><br />
获取锁和释放锁。wiringPi-C提供了4个锁，keyNum范围是0~3。<br />
默认所有所都是释放状态，当调用piLock()想要获取锁时，如果这个锁没有被释放则会一直等待，直到这个锁被释放才会拿到这个锁并继续运行下去。<br />
这里的锁可以理解为某个资源，使用该资源时调用piLock()标志该资源正在被使用，使用结束后调用piUnlock()表示释放该资源。其他地方想要使用该资源也必须先获取这个锁，如果没有获取到则等待使用者释放资源后再使用。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-时间函数]]></title>
    <link href="http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu.html"/>
    <updated>2017-11-23T19:27:41+08:00</updated>
    <id>http://nicekwell.net/blog/20171123/shu-mei-pai-wiringpi-shi-jian-han-shu</id>
    <content type="html"><![CDATA[<p>  </p>

<p>wiringPi不仅提供硬件操作的接口，同时也提供了一些时间管理函数。</p>

<!-- more -->

<p> </p>

<p><strong>void delay (unsigned int howLong)</strong><br />
延时ms，最大传入32位无符号型整数，大约49天。<br />
实际上是睡眠，不占用cpu。<br />
由于linux是多任务的，所以实际延时时间可能会更长。</p>

<p> </p>

<p><strong>void delayMicroseconds (unsigned int howLong)</strong><br />
延时微秒，最大传入32位无符号型整数，大约71分钟。</p>

<p>wiringPi的库文件中有这样一个函数：</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">delayMicrosecondsHard</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">howLong</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tNow</span><span class="p">,</span> <span class="n">tLong</span><span class="p">,</span> <span class="n">tEnd</span> <span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="n">gettimeofday</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tNow</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">;</span>
</span><span class="line">  <span class="n">tLong</span><span class="p">.</span><span class="n">tv_sec</span>  <span class="o">=</span> <span class="n">howLong</span> <span class="o">/</span> <span class="mi">1000000</span> <span class="p">;</span>
</span><span class="line">  <span class="n">tLong</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">howLong</span> <span class="o">%</span> <span class="mi">1000000</span> <span class="p">;</span>
</span><span class="line">  <span class="n">timeradd</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tNow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tLong</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tEnd</span><span class="p">)</span> <span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="k">while</span> <span class="p">(</span><span class="n">timercmp</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tNow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tEnd</span><span class="p">,</span> <span class="o">&lt;</span><span class="p">))</span>
</span><span class="line">    <span class="n">gettimeofday</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tNow</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>其实 delayMicroseconds 函数会判断传入时间如果小于100us就使用 delayMicrosecondsHard 占用式延时，否则会调用 nanosleep 函数。<br />
如果我们想要精确延时，是可以使用 delayMicrosecondsHard 函数的，这个函数在.h文件里没有声明，但已经编译完成，只要用 void delayMicrosecondsHard (unsigned int howLong); 把此函数声明一下就可以使用了。</p>

<p> </p>

<p><strong>unsigned int millis (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是ms。</p>

<p> </p>

<p><strong>unsigned int micros (void)</strong><br />
返回从设置Setup以来所经过的时间，单位是us。<br />
<strong>测试发现这个函数获取时间速度是很快地，此函数执行时间大约1us，也就是说连续执行两次此函数时间相差大约1us。</strong>在用树莓派处理对时间比较敏感的任务时可能会在意这些时间。</p>

<p>树莓派中经常需要精确地周期性执行某个动作，可以用如下方式精确定时，类似于单片机里的定时器：</p>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define INTERVAL 20000 </span><span class="c1">//间隔时间，单位是us</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="n">tim</span><span class="p">;</span>
</span><span class="line">    <span class="cm">/* do something */</span>
</span><span class="line">    <span class="n">tim</span> <span class="o">=</span> <span class="n">micros</span><span class="p">();</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="k">if</span><span class="p">(</span><span class="n">micros</span><span class="p">()</span> <span class="o">-</span> <span class="n">tim</span> <span class="o">&gt;=</span> <span class="n">INTERVAL</span><span class="p">)</span>
</span><span class="line">      <span class="p">{</span>
</span><span class="line">            <span class="n">tim</span> <span class="o">+=</span> <span class="n">INTERVAL</span><span class="p">;</span>
</span><span class="line">            <span class="cm">/* do something */</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-GPIO]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio.html"/>
    <updated>2017-11-22T20:07:42+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-gpio</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p>GPIO接口在官网有详细的说明：<a href="http://wiringpi.com/reference/core-functions/">http://wiringpi.com/reference/core-functions/</a></p>

<p>wiringPi的GPIO序号如下：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/1.jpg" alt="1.jpg" /></p>

<p> </p>

<p><strong>void pinMode (int pin, int mode) ;</strong><br />
设置GPIO模式。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
mode可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>INPUT</td>
    </tr>
    <tr>
      <td>OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>GPIO_CLOCK</td>
    </tr>
    <tr>
      <td>SOFT_PWM_OUTPUT</td>
    </tr>
    <tr>
      <td>SOFT_TONE_OUTPUT</td>
    </tr>
    <tr>
      <td>PWM_TONE_OUTPUT</td>
    </tr>
  </tbody>
</table>

<p>只有具有相应功能的引脚才能设置为该功能。</p>

<p> </p>

<p><strong>void pullUpDnControl (int pin, int pud) ;</strong><br />
设置上下拉。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
pud是上下拉配置，可设置为：</p>

<table>
  <tbody>
    <tr>
      <td>PUD_OFF</td>
      <td>无上下拉</td>
    </tr>
    <tr>
      <td>PUD_UP</td>
      <td>上拉，3.3v，50kΩ</td>
    </tr>
    <tr>
      <td>PUD_DOWN</td>
      <td>下拉，50kΩ</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p><strong>void digitalWrite (int pin, int value) ;</strong><br />
设置指定引脚的输出。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
value是输出值，可以设置为：</p>

<table>
  <tbody>
    <tr>
      <td>HIGH 或 非0</td>
      <td>高电平（3.3v）</td>
    </tr>
    <tr>
      <td>LOW 或 0</td>
      <td>低电平</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>void digitalWriteByte (int value) ;</p>

<p> </p>

<p><strong>int digitalRead (int pin) ;</strong><br />
读取指定引脚。<br />
pin是引脚序号，以何种方式编号在前面决定。<br />
返回的是该引脚的电平，返回HIGH或LOW。</p>

<p> </p>

<p><strong>void pwmWrite (int pin, int value) ;</strong><br />
设置pwn输出占空比。<br />
pin是引脚序号，以何种方式编号在前面决定。（最新的树莓派里面好像把pwm功能去掉了）<br />
value是占空比，范围是0~1023。<br />
？？？在哪设置pwm的周期呢？</p>

<p> </p>

<p><strong>analogRead (int pin) ;</strong><br />
读入模拟量（AD）。<br />
<strong>analogWrite (int pin, int value) ;</strong><br />
输出模拟量（DA）。<br />
<em>以上两个功能需要外加芯片</em>，这里略去。</p>

<p> </p>

<p><strong>wiringPi-C控制GPIO的速度</strong><br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-gpio/2.png" alt="2.png" /><br />
高低电平变化响应速度大约是80ns。（raspberry-gpio-python的速度大约是2us，大约是它的25倍）<br />
注意，wiringPi-C也是在上层的程序，输出的波形同样是不稳定的。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPI-设置引脚编号模式]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi.html"/>
    <updated>2017-11-22T19:52:38+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi</id>
    <content type="html"><![CDATA[<p>  </p>

<p>前面说过树莓派在不同的库下对引脚的编号方式是不同的，wiringPi支持设置各种不同的引脚编号方式。</p>

<!-- more -->

<p>安装好wiringPi之后，不仅在系统中添加了头文件和库，同时也安装了命令行工具。<br />
在shell中可以用 <strong>gpio readall</strong> 命令获取到以下信息：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-she-zhi-yin-jiao-bian-hao-mo-shi/1.png" alt="1.png" /></p>

<p>wiringPi提供三种引脚排序方式：wPi、BCM、Phy。<br />
必须在程序开始时指明使用哪种排序方式。</p>

<ol>
  <li>wiringPi排序方式<br />
<strong>int wiringPiSetup (void) ;</strong><br />
调用此函数即可设置为wiringPi排序。</li>
  <li>BCM排序方式<br />
<strong>int wiringPiSetupGpio (void) ;</strong><br />
调用此函数即可。</li>
  <li>物理排序方式（和 raspberry-gpio-python 的排序相同）<br />
<strong>int wiringPiSetupPhys (void) ;</strong><br />
按照引脚顺序排序，没有GPIO的引脚是无法控制的。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-编译&amp;头文件&amp;lib]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-bian-yi-and-tou-wen-jian-and-lib.html"/>
    <updated>2017-11-22T19:40:06+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-bian-yi-and-tou-wen-jian-and-lib</id>
    <content type="html"><![CDATA[<p>  </p>

<p>安装好之后想要使用wiringPi的接口，就必须要包含wiringPi的头文件、链接wiringPi库，本文介绍如何正确编译。</p>

<!-- more -->

<p>安装好之后，会生成以下头文件：</p>

<table>
  <tbody>
    <tr>
      <td>/usr/local/include/wiringPi.h</td>
      <td>提供基础的服务，包括GPIO。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiI2C.h</td>
      <td>提供I2C相关支持。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiSPI.h</td>
      <td>提供SPI相关支持。</td>
    </tr>
    <tr>
      <td>/usr/local/include/wiringPiShift.h</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>生成以下库：</p>

<table>
  <tbody>
    <tr>
      <td>/usr/local/lib/libwiringPiDev.so</td>
    </tr>
    <tr>
      <td>等</td>
    </tr>
  </tbody>
</table>

<p> </p>

<p>在编写C程序时：</p>

<ol>
  <li>要 include 头文件，直接用&lt;&gt;即可，不需要指明路径。<br />
如：#include <wiringPi.h>  
编译器会自动从/usr/local/include/目录下寻找头文件。</wiringPi.h></li>
  <li>编译时要连接wiringPi的库。<br />
如：gcc gpio.c -o gpio -<strong>lwiringPi</strong><br />
编译器会自动从/usr/local/lib/目录下寻找库。</li>
</ol>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-wiringPi-说明和安装]]></title>
    <link href="http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang.html"/>
    <updated>2017-11-22T19:16:22+08:00</updated>
    <id>http://nicekwell.net/blog/20171122/shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">说明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">原理</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">安装</a></li>
</ul>
<p>  </p>

<p>wiringPi是树莓派上层提供gpio、串口、i2c等硬件操作的一套库，经过其封装后的接口函数使用起来非常方便。<br />
wiringpi已经不局限于C语言了，也提供了其他各种语言的接口，甚至提供了命令行工具，直接在命令行操作GPIO。<br />
我们这里介绍的是wiringPi的C接口。</p>

<!-- more -->

<h3 id="section">说明</h3>

<p>wiringPi是树莓派上层提供gpio、串口、i2c等硬件操作的一套库，经过其封装后的接口函数使用起来非常方便。<br />
wiringpi已经不局限于C语言了，也提供了其他各种语言的接口，甚至提供了命令行工具，直接在命令行操作GPIO。<br />
我们这里介绍的是wiringPi的C接口。</p>

<p>官方首页：<a href="http://wiringpi.com/">http://wiringpi.com/</a><br />
wiringPi-c的github主页：<a href="https://github.com/WiringPi/WiringPi">https://github.com/WiringPi/WiringPi</a><br />
官方说明文档：<a href="http://wiringpi.com/reference/">http://wiringpi.com/reference/</a></p>

<h3 id="section-1">原理</h3>

<p>通过wiringPi 的源码可以看出，<strong>wiringPi是一个在现有的上层接口基础上封装的一层库函数</strong>。上层不通过wiringPi也可以直接通过linux标准接口完成功能，wiringPi封装的好处是使用比较方便（但也裁剪了很多功能）。<br />
如：<br />
  GPIO库，实际上是通过操作GPIO节点实现：<br />
  <img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang/1.png" alt="1.png" /></p>

<p>  serial库，实际上也是通过标准的open、write等函数实现：<br />
  <img src="http://nicekwell.net/images/raspberrypi/2017-11-22-shu-mei-pai-wiringpi-shuo-ming-he-an-zhuang/2.png" alt="2.png" /></p>

<h3 id="section-2">安装</h3>

<p>1、用git把代码拖下来<br />
<strong>git clone git://git.drogon.net/wiringPi</strong><br />
也可以从github拖下来：<br />
<strong>git clone git@github.com:WiringPi/WiringPi.git</strong></p>

<p>对比发现作者在这两个地方都进行维护，代码内容完全一样。</p>

<p> </p>

<p>2、安装
进入目录，直接<br />
<strong>./build</strong><br />
不需要sudo权限。</p>

<p>安装过后，就可以使用命令行和C接口了。具体怎么使用见后面内容。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-UART串口]]></title>
    <link href="http://nicekwell.net/blog/20171120/shu-mei-pai-pypi-uartchuan-kou.html"/>
    <updated>2017-11-20T19:37:15+08:00</updated>
    <id>http://nicekwell.net/blog/20171120/shu-mei-pai-pypi-uartchuan-kou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#pythonpyserial" id="markdown-toc-pythonpyserial">python通用串口库——pyserial</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">一、安装</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">二、使用</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">1、打开串口并创建对象</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">2、缓冲区操作</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">3、波特率设置</a></li>
          <li><a href="#section-6" id="markdown-toc-section-6">4、从串口发送数据</a></li>
          <li><a href="#section-7" id="markdown-toc-section-7">5、从串口接收数据</a></li>
          <li><a href="#section-8" id="markdown-toc-section-8">6、关闭串口</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>  </p>

<p>树莓派在linux上层支持通用的串口接口，用linux上通用的串口编程即可操作。<br />
树莓派3B的板载串口被蓝牙占用，但可以方便地使用USB串口模块。</p>

<!-- more -->

<h2 id="section">概述</h2>

<p>树莓派的板载串口是给系统登录使用的，我们要先把这个功能关掉。<br />
<strong>sudo raspi-config</strong><br />
Advanced Options –&gt; Serial –&gt; 关闭串口 –&gt; 重启</p>

<p>树莓派上有两个串口，一个硬件串口，工作稳定，但是分配给了蓝牙；还有一个“mini-uart”，这个串口的时钟是由内核提供，所以不太稳定  。
在树莓派3B上，蓝牙和硬件串口是不能兼得的。<br />
这个链接(<a href="http://ukonline2000.com/?p=880">http://ukonline2000.com/?p=880</a>)有介绍如何把硬件串口分配到GPIO14、GPIO15上，这里不做介绍了。</p>

<p>总之，在树莓派3B上，想要使用板载硬件串口是比较麻烦的，我们这里使用的是USB转串口模块，也能很方便地使用串口。</p>

<p>pypi库没有提供串口操作函数，我们使用串口的思路是通过linux上层通用的串口接口。</p>

<h2 id="pythonpyserial">python通用串口库——pyserial</h2>

<p>这里介绍的是第三方库 pyserial 的安装和使用。<br />
ubuntu、mac和树莓派上，只要安装了python都可以用此方法操作串口。</p>

<p>官网：<a href="http://pyserial.sourceforge.net/">http://pyserial.sourceforge.net/</a><br />
github主页：<a href="https://github.com/pyserial/pyserial">https://github.com/pyserial/pyserial</a></p>

<h3 id="section-1">一、安装</h3>

<p>网上有很多pip安装的方法，但那些好像都是针对python2的，python3安装不了，正确方法如下：<br />
<strong>mac下也可以用这种方法安装，但mac需要先安装驱动，我用的是PL2303，从官网下载的驱动，安装完成后的节点是 /dev/tty.usbserial。</strong></p>

<p>1、从github clone代码<br />
<strong>git clone git@github.com:pyserial/pyserial.git</strong></p>

<p>2、进入安装目录安装<br />
<strong>sudo python3 setup.py install</strong><br />
（在mac下安装不用sudo权限也行）</p>

<p>3、python3中import模块<br />
<strong>import serial</strong><br />
如果没有安装成功的话 import 会报错。</p>

<h3 id="section-2">二、使用</h3>

<p>首先要 <strong>import serial</strong></p>

<h4 id="section-3">1、打开串口并创建对象</h4>

<p><strong>[串口对象] = serial.Serial(‘[串口设备文件]’,<br />
              baudrate=[波特率],<br />
              bytesize=[数据位],<br />
              parity=’[校验]’,<br />
              stopbits=[停止位],<br />
              timeout=[timeout])</strong></p>

<ul>
  <li>串口设备文件就是/dev/目录下的设备文件，传入的是一个字符串，比如 ‘/dev/ttyUSB0’。</li>
  <li>budrate是波特率，<strong>传入的是数值</strong>。可以选择：<br />
2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</li>
  <li>bytesize是数据位，<strong>传入的是数值</strong>。<br />
可以省略，默认是8。</li>
  <li>parity是校验，传入的是字符串。可以设置为：<br />
<strong>‘N’    不校验<br />
‘O’    奇校验（ODD）<br />
‘E’    偶校验（EVEN）</strong><br />
可以省略，默认是’N’。</li>
  <li>stopbits是停止位个数，<strong>传入的是数值</strong>，一般都是设成1。<br />
可以生录入，默认是1。</li>
  <li>timeout是超时等待，在接收数据时，如果接收到的字符不满足返回条件则会等待，超时后返回。</li>
</ul>

<p>  例1，指明所有参数：<br />
  <em>ser = serial.Serial(‘/dev/ttyUSB1’,<br />
           baudrate=9600,<br />
           bytesize=8,<br />
           parity=’N’,<br />
           stopbits=1,<br />
           timeout=3)</em><br />
  例2，只指定某些参数：<br />
  <em>ser = serial.Serial(‘/dev/ttyUSB1’, 9600, timeout=3)</em></p>

<h4 id="section-4">2、缓冲区操作</h4>

<p>  python对串口接收数据和单片机有所不同。<br />
  单片机接收到数据后会产生中断，然后在中断中处理数据。<br />
  <strong>python是不会产生串口中断的，接收到的数据会存放在缓冲区，然后python程序主动检查缓冲区读取数据。</strong>读取数据方法也有多种。<br />
  <strong>每次新打开一个串口，之前的缓冲区就会被清空。</strong><br />
  缓冲区有输入缓冲区和输出缓冲区。<br />
  缓冲区的大小是：</p>

<p>  <strong>[串口对象].flushInput()</strong><br />
  清除接收缓冲区，放弃接收到的所有内容。<br />
  <strong>[串口对象].flushOutput()</strong><br />
  清除发送缓冲区，放弃输出。</p>

<p>  <strong>[串口对象].inWaiting()</strong><br />
  【功能】获取缓冲区里的字节数。<br />
  【输出】返回一个数值，代表缓冲区里有多少数据。</p>

<h4 id="section-5">3、波特率设置</h4>

<p>  <strong>[串口对象].setBaudrate([波特率])</strong><br />
  设置已经打开的串口的波特率，传入的是数值，可以选择：<br />
  2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200</p>

<h4 id="section-6">4、从串口发送数据</h4>

<p>  <strong>[串口对象].write([单字节数组])</strong><br />
  <strong>发送的数据必须是单字节数据</strong>，可以是单字节组成的list，也可以是单字节编码的字符串（如ASCII、UTF-8）。
  返回的是写入的字节数。<br />
  例1，发送16进制数据：<br />
  <em>list1 = [0x01,0x02,0x03,0x10]<br />
  ser.write(list1)</em><br />
  会把这几个16进制数依次通过串口发出，另一端会接收到一模一样的数据。<br />
  例2，发送单字节编码的字符串：<br />
  <em>ser.write(b’abcdefg’)</em><br />
  把字符串’abcdefg’的ascii码发出，另一端收到：0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67。</p>

<h4 id="section-7">5、从串口接收数据</h4>

<p>  <strong>[串口对象].read([长度])</strong><br />
  【功能】从缓冲区读取指定长度内容。<br />
  【输入】<br />
  [长度] 是一个数值，代表要从缓冲区读取的字节数。<br />
  这个参数可以省略，默认是1。<br />
  【输出】输出的是一连串单字节数据。<br />
  【说明】<strong>如果缓冲区内容小于读取的长度则会等待，直到timeout后读取仅有的全部内容返回。</strong></p>

<p>  <strong>[串口对象].readall()</strong><br />
  【功能】读取缓冲区的所有数据。<br />
  【输出】输出的是一连串单字节数据。<br />
  <strong>这个函数必然会等待一个timeout时间，把之前缓冲区里所有内容和等待阶段接收到的所有内容读出。</strong></p>

<p>  <strong>[串口对象].readline()</strong><br />
  【功能】从缓冲区里读取一行。<br />
  【输出】输出的是一连串单字节数据。<br />
  【说明】<br />
  读取时会找到第一个’\n’结束，如果缓冲区里的数据没有’\n’，则会等待，知道timeout后返回仅有的所有内容。</p>

<h4 id="section-8">6、关闭串口</h4>

<p>  <strong>[串口对象].close()</strong></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-GPIO]]></title>
    <link href="http://nicekwell.net/blog/20171119/shu-mei-pai-pypi-gpio.html"/>
    <updated>2017-11-19T22:44:47+08:00</updated>
    <id>http://nicekwell.net/blog/20171119/shu-mei-pai-pypi-gpio</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1、导入模块</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2、设置引脚排列方式</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3、设置某个引脚的输入输出</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4、输入</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">5、输出</a></li>
  <li><a href="#pythongpio" id="markdown-toc-pythongpio">python控制GPIO的速度</a></li>
</ul>
<p>  </p>

<!-- more -->

<h3 id="section">1、导入模块</h3>

<p><strong>import RPi.GPIO as GPIO</strong></p>

<h3 id="section-1">2、设置引脚排列方式</h3>

<p>1、主板编号方式<br />
<strong>GPIO.setmode(GPIO.BOARD)</strong><br />
就是按照主板的引脚顺序：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/1.png" alt="1.png" /><br />
注意有些引脚是没有GPIO功能的，这些引脚仍然为它们分配了序号，但控制时使用这些非GPIO的序号是会报错的。</p>

<p>2、BCM编号方式<br />
<strong>GPIO.setmode(GPIO.BCM)</strong><br />
按照BCM方式编号。<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/2.jpg" alt="2.jpg" /></p>

<h3 id="section-2">3、设置某个引脚的输入输出</h3>

<p><strong>GPIO.setup([gpio], GPIO.[dir])</strong><br />
[GPIO]是一个引脚的序号，按照上面的编号方式决定。<br />
GPIO.[dir]是方向，可以设置：</p>

<table>
  <tbody>
    <tr>
      <td><strong>GPIO.IN</strong></td>
      <td>输入</td>
    </tr>
    <tr>
      <td><strong>GPIO.OUT</strong></td>
      <td>输出</td>
    </tr>
  </tbody>
</table>

<p>同时设置多个通道：<br />
<strong>chan_list = [[gpio1], [gpio2], …]</strong><br />
<strong>GPIO.setup(chan_list, GPIO_[dir]]</strong></p>

<h3 id="section-3">4、输入</h3>

<p><strong>GPIO.input([gpio])</strong><br />
获取指定通道的电平，返回的是一个数值，0或1。</p>

<h3 id="section-4">5、输出</h3>

<p>单通道输出：<br />
<strong>GPIO.output([gpio], GPIO.[level])</strong><br />
[gpio]是一个引脚的序号，按照上面的编号方式决定。<br />
GPIO.[level]是引脚的电平：</p>

<table>
  <tbody>
    <tr>
      <td><strong>GPIO.LOW</strong></td>
      <td>低电平</td>
    </tr>
    <tr>
      <td><strong>GPIO.HIGH</strong></td>
      <td>高电平（3.3v）</td>
    </tr>
  </tbody>
</table>

<p>同时设置多通道输出：<br />
<strong>chan_list = [[gpio1], [gpio2], …]</strong><br />
<strong>GPIO.output(chan_list, (GPIO.HIGH, GPIO.LOW, …))</strong><br />
第一个参数是list，第二个参数是tuple。</p>

<h3 id="pythongpio">python控制GPIO的速度</h3>

<p>设置python控制一个GPIO循环输出高低电平（不加延时），波形如下：<br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-19-shu-mei-pai-pypi-gpio/3.png" alt="3.png" /></p>

<p>高低电平切换响应速度大约2us。<br />
但是注意，<strong>由于python是在上层运行的，所以波形输出不太稳定</strong>，上面是最理想的状态，实际上程序会受到影响，波形输出不稳定。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-pypi-说明和安装]]></title>
    <link href="http://nicekwell.net/blog/20171116/shu-mei-pai-pypi-shuo-ming-he-an-zhuang.html"/>
    <updated>2017-11-16T15:44:09+08:00</updated>
    <id>http://nicekwell.net/blog/20171116/shu-mei-pai-pypi-shuo-ming-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">安装</a></li>
</ul>
<p>  </p>

<p>这个库完整的名字是raspberry-gpio-python，通过这个库可以方便地用python操作树莓派的GPIO，但没有提供SPI、i2c等操作接口。</p>

<!-- more -->

<h3 id="section">安装</h3>

<ul>
  <li>
    <p>1、安装python3<br />
<strong>sudo apt-get install python-dev python3-dev</strong></p>
  </li>
  <li>
    <p>2、下载pypi库:<br />
官方下载：<a href="https://pypi.python.org/pypi/RPi.GPIO">https://pypi.python.org/pypi/RPi.GPIO</a></p>
  </li>
  <li>
    <p>3、放到树莓派里，解压<br />
<strong>tar zxvf RPi.GPIO-0.6.2.tar.gz</strong></p>
  </li>
  <li>
    <p>4、进入解压后的目录，执行安装<br />
<strong>sudo python3 setup.py install</strong><br />
可参考解压后目录中的INSTALL.txt文档说明。</p>
  </li>
</ul>

<p>安装成功后就可以使用 RPi.GPIO模块了。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-硬件和功能-功耗]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-gong-hao.html"/>
    <updated>2017-11-15T20:37:34+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-gong-hao</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p>3代B型：</p>

<table>
  <tbody>
    <tr>
      <td>几乎0%使用</td>
      <td>270mA</td>
    </tr>
    <tr>
      <td>单核100%</td>
      <td>320mA，每隔几秒跳一次400mA</td>
    </tr>
    <tr>
      <td>双核100%</td>
      <td>360mA，每隔几秒跳一次510mA</td>
    </tr>
    <tr>
      <td>三个100%</td>
      <td>410mA，每隔几秒跳一次630mA</td>
    </tr>
    <tr>
      <td>四核100%</td>
      <td>460mA，每隔几秒跳一次760mA</td>
    </tr>
  </tbody>
</table>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-硬件和功能-硬件和功能]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng.html"/>
    <updated>2017-11-15T20:25:20+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng</id>
    <content type="html"><![CDATA[<p>  </p>

<!-- more -->

<p><strong>树莓派引脚电平是3.3V。</strong></p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/1.png" alt="1.png" /></p>

<p>关于引脚的编号，不同的库会有不同的编号：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/2.jpg" alt="2.jpg" /></p>

<p>老的树莓派1代引脚如下：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-ying-jian-he-gong-neng-ying-jian-he-gong-neng/3.png" alt="3.png" /></p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-概述和使用-配置和使用]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong.html"/>
    <updated>2017-11-15T19:52:47+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#ssh" id="markdown-toc-ssh">打开ssh</a></li>
  <li><a href="#section" id="markdown-toc-section">树莓派配置命令</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">默认用户</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">修改主机名</a></li>
  <li><a href="#sd" id="markdown-toc-sd">扩展sd卡空间</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">更新源</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">设置时区</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">支持中文</a></li>
</ul>
<p>  </p>

<p>本文介绍树莓派的常用设置，经常是一些开机后必须设置的项目。</p>

<!-- more -->

<h3 id="ssh">打开ssh</h3>

<p>第一次开机网络都没配置，这一步肯定要连接显示器才能配置的。</p>

<p>从2016.11.25开始，树莓派默认关闭ssh，导致不能远程登陆，需要手动开启ssh功能，方法是在 /boot/ 分区下建立一个名为“ssh的空文件。<br />
方法1：在树莓派上直接打开ssh：<strong>sudo touch /boot/ssh</strong><br />
方法2：在电脑上打开ssh：插入sd卡后有个boot分区，在里面创建一个名为“ssh”的文件<br />
树莓派重启后会删掉此文件，但已经可以使用ssh登陆了。</p>

<h3 id="section">树莓派配置命令</h3>

<p>打开命令行，用 <strong>sudo raspi-config</strong> 命令可开启树莓派配置程序。</p>

<h3 id="section-1">默认用户</h3>

<p>pi@raspberrypi，密码 raspberry。</p>

<h3 id="section-2">修改主机名</h3>

<p>多个树莓派分不清，可以修改主机名称区分。<br />
sudo raspi-config –&gt; 9 Advanced Options –&gt; A2 Hostname<br />
2017年stretch新版设置路径是：<br />
sudo raspi-config –&gt;2 Hostname</p>

<h3 id="sd">扩展sd卡空间</h3>
<p>2017年stretch已经不需要此步骤了，老的版本需要执行以下操作后才能使用全部sd卡空间。</p>

<p>安装好系统后默认的系统空间很小，几乎仅能放下系统，而sd卡有很多空间没有用到：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/1.png" alt="1.png" /><br />
使用 raspi-config 的“Expand Filesystem”功能可以把sd卡的全部空间用起：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/2.png" alt="2.png" /><br />
此修改需要重启树莓派，重启之后：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-pei-zhi-he-shi-yong/3.png" alt="3.png" /></p>

<h3 id="section-3">更新源</h3>

<p>使用不同的 raspbian 版本，对应的更新源是不一样的，可以从网上查找。<br />
stretch版本的源：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi  
</span><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span></code></pre></td></tr></table></div></figure>

<p>修改方法和ubuntu、debian相同：<br />
1、修改 /etc/source.list 文件<br />
2、sudo apt-get update</p>

<h3 id="section-4">设置时区</h3>

<p>网上找到的linux下通用设置方法 tzselect 设置无效，最后用 raspi-config 设置完成：<br />
sudo raspi-config –&gt; 5 Internationalisation … –&gt; I2 Change Timezone –&gt; Asia –&gt; ShangHai –&gt; OK<br />
2017年stretch版本设置路径：<br />
sudo raspi-config –&gt; 4 Localisation Options –&gt; I2 Change Timezone –&gt; Asia –&gt; ShangHai –&gt; OK</p>

<h3 id="section-5">支持中文</h3>

<p>2017年stretch版本已经不需要设置了。</p>

<p>默认的命令行不支持中文，git log查看提交记录都不能显示中文。修改方法：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">pi@raspberrypi:~$ sudo apt-get install ttf-wqy-zenhei  #安装字体
</span><span class="line">pi@raspberrypi:~$ sudo fc-cache       #刷新字库缓存
</span><span class="line">pi@raspberrypi:~$ sudo dpkg-reconfigure locales        #字体配置</span></code></pre></td></tr></table></div></figure>
<p>然后用上下方向键选中以下5项：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">en-GB.UTF-8 UTF-8
</span><span class="line">zh_CN.GB2312
</span><span class="line">zh.CN.GB18030 GB18030
</span><span class="line">zh_CN.GBK GBK
</span><span class="line">zh_CN.UTF-8 UTF-8</span></code></pre></td></tr></table></div></figure>
<p>选中后回车，会让你选择默认的字体，<br />
  如果想要系统语言是中文，则选择“zh_CN.UTF-8 UTF-8 ”回车<br />
  如果想要系统语言是英文，则选择“en_GB.UTF-8”回车。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树莓派-概述和使用-下载和安装]]></title>
    <link href="http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang.html"/>
    <updated>2017-11-15T19:22:54+08:00</updated>
    <id>http://nicekwell.net/blog/20171115/shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">下载镜像</a></li>
  <li><a href="#mac" id="markdown-toc-mac">mac下安装</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">启动树莓派</a></li>
</ul>
<p>  </p>

<p>本文介绍如何下载树莓派镜像，并安装到sd卡，实现开机。</p>

<!-- more -->

<h3 id="section">下载镜像</h3>

<p>官网：<a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a><br />
下载页面：<a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br />
推荐下载raspbian：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/1.png" alt="1.png" /></p>

<p>这是基于debian jessie的系统，有Full desktop版本和Minimal版本：</p>

<p><img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/2.png" alt="2.png" /><br />
full desktop版本有图形界面；Minimal版本没有图形界面，是精简版。<br />
由于后面要配置网络等配置项，用图形界面会方便很多，推荐使用不带LITE的desktop版。</p>

<h3 id="mac">mac下安装</h3>

<ul>
  <li>
    <p><strong>1、不插入sd卡查看当前磁盘情况</strong>
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/3.png" alt="3.png" /></p>
  </li>
  <li>
    <p><strong>2、插入sd卡查看当前磁盘情况</strong>
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/4.png" alt="4.png" /><br />
多出来的 /dev/disk2s1 就是sd卡的分区。</p>
  </li>
  <li>
    <p><strong>3、卸载这个分区</strong><br />
<strong>diskutil unmount /dev/[disk*s*]</strong><br />
卸载是为了待会写入这个分区时不会被其他程序的读写干扰。<br />
卸载之后可以通过  diskutil list 命令查看设备：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/5.png" alt="5.png" /><br />
可以看到我们的sd卡对应的设备是 /dev/disk2。</p>
  </li>
  <li>
    <p><strong>4、使用dd命令写入镜像</strong><br />
<strong>sudo dd bs=4m if=[镜像].img of=/dev/<code>[磁盘的字符设备]</code></strong><br />
注意，磁盘的字符设备是 r 开头的，网上有个说法：/dev/disk2s1是分区，/dev/disk2是块设备，/dev/rdisk2是原始字符设备。<br />
由于文件很大，写入过程会比较长。成功之后会显示如下界面：
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/6.png" alt="6.png" /></p>
  </li>
  <li>
    <p><strong>5、卸载sd卡设备</strong><br />
<strong>diskutil unmountDisk /dev/[disk*]</strong><br />
<img src="http://nicekwell.net/images/raspberrypi/2017-11-15-shu-mei-pai-gai-shu-he-shi-yong-xia-zai-he-an-zhuang/7.png" alt="7.png" /></p>
  </li>
</ul>

<p>ubuntu下安装步骤和mac下类似，由于没有实际操作过，这里不介绍ubuntu下的安装。</p>

<h3 id="section-1">启动树莓派</h3>

<p>安装好之后把sd卡插在树莓派上，接通电源即可启动。</p>

<hr />

<p>本站所有文章欢迎转载，但请保留作者信息和原文地址。</p>

]]></content>
  </entry>
  
</feed>
