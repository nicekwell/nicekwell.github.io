<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[生命不息 折腾不止]]></title>
  <link href="http://nicekwell.net/atom.xml" rel="self"/>
  <link href="http://nicekwell.net/"/>
  <updated>2016-12-13T23:02:33+08:00</updated>
  <id>http://nicekwell.net/</id>
  <author>
    <name><![CDATA[nicekwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PCA9685 16路12位pwm信号发生器]]></title>
    <link href="http://nicekwell.net/blog/20161213/pca9685-16lu-12wei-pwmxin-hao-fa-sheng-qi.html"/>
    <updated>2016-12-13T20:24:30+08:00</updated>
    <id>http://nicekwell.net/blog/20161213/pca9685-16lu-12wei-pwmxin-hao-fa-sheng-qi</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、概述和硬件</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1、概述</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">2、硬件</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">1、电压</a></li>
          <li><a href="#i2c" id="markdown-toc-i2c">2、i2c地址</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">3、使能脚</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">二、寄存器功能</a>    <ul>
      <li><a href="#mode1" id="markdown-toc-mode1">MODE1寄存器</a></li>
      <li><a href="#onoff" id="markdown-toc-onoff">各个通道的ON和OFF寄存器</a></li>
      <li><a href="#prescale" id="markdown-toc-prescale">PRE_SCALE寄存器</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">三、驱动</a>    <ul>
      <li><a href="#wiringpi" id="markdown-toc-wiringpi">树莓派wiringPi平台</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">四、使用流程</a></li>
</ul>
<p>  </p>

<p>16路12位PWM信号发生器，可用于控制舵机、led、电机等设备，i2c通信，节省主机资源。</p>

<p><img src="http://nicekwell.net/images/module-and-agreement/pca9685.png" alt="pca9685" /></p>

<!-- more -->

<h1 id="section">一、概述和硬件</h1>

<h2 id="section-1">1、概述</h2>
<p>很常见的模块板子是这个样子，这个板子也比较便宜，十几块钱一个。<br />
i2c通信，只需要几根i2c线就可以控制16路pwm，周期和占空比都可控。<br />
可以多个模块级联。<br />
可控制16路通道的四种工作模式：关、开、pwm、可变pwm。<br />
精度是12位：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">工作频率</th>
      <th style="text-align: center">时间分辨率</th>
      <th style="text-align: center">通常舵机500~2500us可分成份数</th>
      <th style="text-align: center">通常舵机500~2500us，旋转角180°的角度分辨率</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">50Hz</td>
      <td style="text-align: center">4.88us</td>
      <td style="text-align: center">410份</td>
      <td style="text-align: center">0.439°</td>
    </tr>
    <tr>
      <td style="text-align: center">60Hz</td>
      <td style="text-align: center">4us</td>
      <td style="text-align: center">492份</td>
      <td style="text-align: center">0.366°</td>
    </tr>
  </tbody>
</table>

<p>驱动方式可以选择开漏输出或推挽输出。</p>

<h2 id="section-2">2、硬件</h2>

<h3 id="section-3">1、电压</h3>
<p>数字电路电压范围可接受3.3和5v电平。<br />
此外还有一个v+引脚，这个引脚是给舵机供电用的，可以接稍微高一点的电压。</p>

<h3 id="i2c">2、i2c地址</h3>
<p>有6个地址控制脚，通过这些引脚可以控制设备的i2c地址。<br />
<strong>7位的I2C地址为：0x40 + A5:A0</strong>，A5到A0如果不做任何处理的话是0，想要把哪一位置1就把那个引脚焊到一起。<br />
另外用i2cdetect检测出还有一个<strong>0x70</strong>地址一直存在，这是一个通用地址，可以给所有从机下达指令。</p>

<h3 id="section-4">3、使能脚</h3>
<p>模块有一个OE反使能脚，这个引脚低电平使能，不接的话模块内部默认已经接地使能了，所以正常使用可以不接。</p>

<h1 id="section-5">二、寄存器功能</h1>
<p>:-:|:-:|:-:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">内部地址(hex)</th>
      <th style="text-align: center">名称</th>
      <th style="text-align: center">功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">00</td>
      <td style="text-align: center">MODE1</td>
      <td style="text-align: center">设置寄存器1</td>
    </tr>
    <tr>
      <td style="text-align: center">01</td>
      <td style="text-align: center">MODE2</td>
      <td style="text-align: center">设置寄存器2</td>
    </tr>
    <tr>
      <td style="text-align: center">02</td>
      <td style="text-align: center">SUBADR1</td>
      <td style="text-align: center">i2c-bus subaddress1</td>
    </tr>
    <tr>
      <td style="text-align: center">03</td>
      <td style="text-align: center">SUBADR2</td>
      <td style="text-align: center">i2c-bus subaddress2</td>
    </tr>
    <tr>
      <td style="text-align: center">04</td>
      <td style="text-align: center">SUBADR3</td>
      <td style="text-align: center">i2c-bus subaddress3</td>
    </tr>
    <tr>
      <td style="text-align: center">05</td>
      <td style="text-align: center">ALLCALLADR</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">06</td>
      <td style="text-align: center">LED0_ON_L</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">07</td>
      <td style="text-align: center">LED0_ON_H</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">08</td>
      <td style="text-align: center">LED0_OFF_L</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">09</td>
      <td style="text-align: center">LED0_OFF_H</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
    </tr>
    <tr>
      <td style="text-align: center">0x06 + 4*X</td>
      <td style="text-align: center">LEDX_ON_L</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">0x06 + 4*X + 1</td>
      <td style="text-align: center">LEDX_ON_H</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">0x06 + 4*X + 2</td>
      <td style="text-align: center">LEDX_OFF_L</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">0x06 + 4*X + 3</td>
      <td style="text-align: center">LEDX_OFF_H</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…	上面共16路通道</td>
    </tr>
    <tr>
      <td style="text-align: center">FA</td>
      <td style="text-align: center">ALL_LED_ON_L</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">FB</td>
      <td style="text-align: center">ALL_LED_ON_H</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">FC</td>
      <td style="text-align: center">ALL_LED_OFF_L</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">FD</td>
      <td style="text-align: center">ALL_LED_OFF_H</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">FE</td>
      <td style="text-align: center">PRE_SCALE</td>
      <td style="text-align: center">控制周期的寄存器</td>
    </tr>
    <tr>
      <td style="text-align: center">FF</td>
      <td style="text-align: center">TestMode</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h2 id="mode1">MODE1寄存器</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">位</th>
      <th style="text-align: center">名称</th>
      <th style="text-align: center">功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">D7</td>
      <td style="text-align: center">RESTART</td>
      <td style="text-align: center">写1复位，写完后此位自动清除。<strong>一定要在SLEEP位写0后至少500us后才能对此位写1进行复位。</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">D6</td>
      <td style="text-align: center">EXTCLOCK</td>
      <td style="text-align: center">0-使用内部时钟（25MHz）。1-使用外部时钟引脚的时钟。<strong>修改此位前，一定要先SLEEP，再修改此位（此时SLEEP位仍然写1），再退出SLEEP。</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">D5</td>
      <td style="text-align: center">AI</td>
      <td style="text-align: center">0-内部地址读写后不自动增加。1-内部地址读写后自动增加。一般i2c设备在对从机读写后内部地址都会自动增加，这个芯片可以手动设置是否自动增加，我们一般都会设成自动增加。</td>
    </tr>
    <tr>
      <td style="text-align: center">D4</td>
      <td style="text-align: center">SLEEP</td>
      <td style="text-align: center">0-退出SLEEP模式。1-进入SLEEP模式。注：1、写0退出sleep模式后，最多等500us后即可产生稳定的时钟信号。2、写1进入sleep模式后，时钟会关闭。此时可以修改时钟源寄存器EXTCLOCK和周期寄存器PRE_SCALE，修改这两个寄存器之前必须先进入sleep模式。</td>
    </tr>
    <tr>
      <td style="text-align: center">D3</td>
      <td style="text-align: center">SUB1</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">D2</td>
      <td style="text-align: center">SUB2</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">SUB3</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">ALLCALL</td>
      <td style="text-align: center">0-不响应0x70通用i2c地址。1-响应0x70通用i2c地址。这个芯片除了可以通过A5:A0自定义i2c地址外，还有一个通用i2c地址0x70，此寄存器可以控制是否响应这个通用地址。注意啊：这个寄存器的设置好像掉电会保存的！</td>
    </tr>
  </tbody>
</table>

<h2 id="onoff">各个通道的ON和OFF寄存器</h2>
<p>总共16个通道，每个通道都有 LEDX_ON_L、LEDX_ON_H、LEDX_OFF_L、LEDX_OFF_H 四个寄存器。<br />
系统中有一个12位的计数ACK，ACK根据PRE_SCALE寄存器设置的周期进行增加，没增加一次就会和上述四个寄存器对比：<br />
<strong>当发现 ACK == LEDX_ON_H[3:0]:LEDX_ON_L 时，X通道输出高电平；<br />
当发现 ACK == LEDX_OFF_H[3:0]:LEDX_OFF_L 时，X通道输出低电平。</strong></p>

<h2 id="prescale">PRE_SCALE寄存器</h2>
<p>这个寄存器是用来设置周期的，具体原理可以不用管，只要记住这个公式：
<img src="http://nicekwell.net/images/module-and-agreement/prescale.png" alt="prescale" />
其中osc_clock是时钟，根据上面的寄存器设置选择是内部25MHz时钟还是外部时钟；
update_rate是频率，比如周期是20ms，那么频率就是50。
注意：<strong>实际应用中发现有误差，需要加入校准，要把udpate_rate乘以0.915。</strong>
包括从网上下载的arduino驱动中也加入了此校准。</p>

<h1 id="section-6">三、驱动</h1>

<h2 id="wiringpi">树莓派wiringPi平台</h2>
<p>这里是基于树莓派wiringPi提供的i2c通信接口基础上实现的驱动，在其他平台上的驱动方法类似，只要把这里的i2c接口换成其他平台的通信接口即可。<br />
本驱动周期固定为20ms不可变，如需修改也非常容易。</p>

<p>pca9685_wiringpi.h文件：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/*
</span><span class="line">  这个驱动是在树莓派的wiringPi基础上的，基于wiringPi对i2c的接口函数。
</span><span class="line">  此驱动的使用方法是：
</span><span class="line">  1、先用 pca9685_init(从机地址) 初始化，得到一个设备描述符（int型），这个设备描述符代表这个pca9685芯片，因为可能多个pca9685级联，通过这个设备描述符来区分它们。
</span><span class="line">    它的
</span><span class="line">  2、调用 pca9685_setmk
</span><span class="line"> */
</span><span class="line">
</span><span class="line">#ifndef PCA9685_WIRINGPI_H
</span><span class="line">#define PCA9685_WIRINGPI_H
</span><span class="line">#include &lt;wiringPi.h&gt;
</span><span class="line">
</span><span class="line">int pca9685_init(unsigned char addr);	// addr是7位的i2c从机地址，返回的是linux标准的设备描述符，调用它的地方视作pca9685的设备描述符
</span><span class="line">					//因为可以多个pca9685级联，通过设备描述符区别它们
</span><span class="line">					//此驱动仅作为驱动舵机使用，周期固定死位20ms，不允许外部设置
</span><span class="line">void pca9685_setmk(int fd, int num, int mk);	//设置指定通道的脉宽。fd是在pca9685_init时获得的设备描述符，num是通道号（从0开始），mk是脉宽单位是us。周期已经固定为20ms了
</span><span class="line">
</span><span class="line">#endif</span></code></pre></td></tr></table></div></figure>
<p>pca9685_wiringpi.c文件：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include "pca9685_wiringpi.h"
</span><span class="line">
</span><span class="line">#define PCA9685_SUBADR1 0x2
</span><span class="line">#define PCA9685_SUBADR2 0x3
</span><span class="line">#define PCA9685_SUBADR3 0x4
</span><span class="line">
</span><span class="line">#define PCA9685_MODE1 0x0
</span><span class="line">#define PCA9685_PRESCALE 0xFE
</span><span class="line">
</span><span class="line">#define LED0_ON_L 0x6
</span><span class="line">#define LED0_ON_H 0x7
</span><span class="line">#define LED0_OFF_L 0x8
</span><span class="line">#define LED0_OFF_H 0x9
</span><span class="line">
</span><span class="line">#define ALLLED_ON_L 0xFA
</span><span class="line">#define ALLLED_ON_H 0xFB
</span><span class="line">#define ALLLED_OFF_L 0xFC
</span><span class="line">#define ALLLED_OFF_H 0xFD
</span><span class="line">
</span><span class="line">int pca9685_init(unsigned char addr)	// addr是7位的i2c从机地址，返回的是linux标准的设备描述符，调用它的地方视作pca9685的设备描述符
</span><span class="line">					//因为可以多个pca9685级联，通过设备描述符区别它们
</span><span class="line">					//此驱动仅作为驱动舵机使用，周期固定死位20ms，不允许外部设置
</span><span class="line">{
</span><span class="line">    int pca9685;
</span><span class="line">    pca9685 = wiringPiI2CSetup(addr);
</span><span class="line">
</span><span class="line">    {	//初始化pca9685芯片
</span><span class="line">	double T = 20000;	//周期，单位是us
</span><span class="line">	unsigned char prescale;
</span><span class="line">	double osc_clock = 25000000;
</span><span class="line">	unsigned char oldmode, newmode;
</span><span class="line">	T /= 0.915;	//不知道为什么，会有所偏差，这里校准一下就ok了，从网上找的arduino代码也进行了校准。
</span><span class="line">	T /= 1000000;	//把T转换成秒
</span><span class="line">	prescale = (unsigned char)(osc_clock/4096*T - 1);
</span><span class="line">//	printf("prescale = 0x%x", prescale);
</span><span class="line">	oldmode = wiringPiI2CReadReg8(pca9685, PCA9685_MODE1);
</span><span class="line">	newmode = (oldmode&amp;0x7f) | 0x10;	//准备进入sleep，设置时钟前必须先进入sleep模式
</span><span class="line">	wiringPiI2CWriteReg8(pca9685, PCA9685_MODE1, newmode);
</span><span class="line">	wiringPiI2CWriteReg8(pca9685, PCA9685_PRESCALE, prescale);
</span><span class="line">	oldmode &amp;= 0xef;	//清除sleep位
</span><span class="line">	wiringPiI2CWriteReg8(pca9685, PCA9685_MODE1, oldmode);
</span><span class="line">	delay(0.005);
</span><span class="line">	wiringPiI2CWriteReg8(pca9685, PCA9685_MODE1, oldmode | 0xa1);
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    return pca9685;
</span><span class="line">}
</span><span class="line">
</span><span class="line">void pca9685_setmk(int fd, int num, int mk)	//设置指定通道的脉宽。fd是在pca9685_init时获得的设备描述符，num是通道号（从0开始），mk是脉宽单位是us。周期已经固定为20ms了
</span><span class="line">{
</span><span class="line">    unsigned int ON, OFF;
</span><span class="line">    ON = 0;	//每次周期一开始就输出高电平
</span><span class="line">    OFF = (unsigned int)((((double)mk)/20000 * 4096)*1.0067114);	//最后的1.0067114是校准用的
</span><span class="line">//    printf("off = 0x%x", OFF);
</span><span class="line">
</span><span class="line">    wiringPiI2CWriteReg16(fd, LED0_ON_L+4*num, ON);
</span><span class="line">    wiringPiI2CWriteReg16(fd, LED0_OFF_L+4*num, OFF);
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>关于驱动在树莓派上的速度：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">树莓派设置的i2c波特率</th>
      <th style="text-align: center">设置16路通道所用时间</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">100000</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">1000000(1M)</td>
      <td style="text-align: center">2067us</td>
    </tr>
    <tr>
      <td style="text-align: center">2000000(2M)</td>
      <td style="text-align: center">1300us</td>
    </tr>
  </tbody>
</table>

<h1 id="section-7">四、使用流程</h1>
<p>1、确定i2c地址<br />
通过焊接A5~A0确定模块的i2c地址，如果不做任何焊接，默认地址是0x40。<br />
2、连接数字电路电源。<br />
3、连接两根i2c线。<br />
4、连接v+引脚，给舵机供电电源。<br />
5、把驱动合入到工程，即可使用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[别踩白块儿bot]]></title>
    <link href="http://nicekwell.net/blog/20161008/bie-cai-bai-kuai-er-bot.html"/>
    <updated>2016-10-08T14:12:06+08:00</updated>
    <id>http://nicekwell.net/blog/20161008/bie-cai-bai-kuai-er-bot</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">二、黑块的识别</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">2.1 光敏电阻</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">2.2 电压比较器</a></li>
    </ul>
  </li>
  <li><a href="#section-4" id="markdown-toc-section-4">三、触摸屏的触发</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">3.1 触摸点的引出</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">3.2 触摸的控制</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">四、整体组装</a>    <ul>
      <li><a href="#section-8" id="markdown-toc-section-8">4.1 黑块检测和触摸的结合</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">4.2 安装与调试</a></li>
    </ul>
  </li>
</ul>

<p><br /></p>
<iframe style="margin:0 auto; display: block" height="480" width="640" src="http://player.youku.com/embed/XMTc1MjMwNDg0OA?color=white&amp;theme=light"></iframe>
<p>  视频youtube地址：<a href="https://www.youtube.com/watch?v=eQXLUBU6FKc">https://www.youtube.com/watch?v=eQXLUBU6FKc</a></p>

<!-- more -->

<h1 id="section">一、概述</h1>
<p>  整个系统分为两个部分：<br />
  1、黑块的识别<br />
  2、触摸屏的触发</p>

<p>  对于黑块的识别，屏幕上白色和黑色的光线差别比较大，所以用光敏电阻可以很方便地完成。</p>

<p>  而触摸屏的触发方法，网上很多人用机械臂（硬盘磁头、舵机等）点击，我担心这种触发方式响应速度比较慢，所以采用导线直接触发触摸屏。<br />
  对于导线的通断控制，有人用过继电器，用继电器的话毕竟是机械触发，响应速度也可能会比较慢。<br />
  总之我直接选用光耦来控制，完全的电子触发，响应速度比上述两种方法肯定要快得多。</p>

<p>  所以，我们需要的材料有：</p>

<p><strong>基础材料：</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">物品</th>
      <th style="text-align: center">数量</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">洞洞板</td>
      <td style="text-align: center">够大就行</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">导线</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">铜柱</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">把洞洞板架空，防止桌面静电干扰，尤其是屏幕触摸部分很怕干扰</td>
    </tr>
  </tbody>
</table>

<p><br />
<strong>黑块识别：</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">物品</th>
      <th style="text-align: center">数量</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">光敏电阻</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">51k电阻</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">用作光敏电阻上拉，不固定，根据光明电阻特性，只要能有明显的电压变化即可</td>
    </tr>
    <tr>
      <td style="text-align: center">led指示灯</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">用作黑块指示灯</td>
    </tr>
    <tr>
      <td style="text-align: center">1k电阻</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">用作led上拉</td>
    </tr>
    <tr>
      <td style="text-align: center">lm393</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">双路电压比较器</td>
    </tr>
    <tr>
      <td style="text-align: center">103电位器</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">就是可调电阻，用于给电压比较器一个参考电压</td>
    </tr>
  </tbody>
</table>

<p><br />
<strong>触摸屏触发：</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">物品</th>
      <th style="text-align: center">数量</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">817光耦</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">每两个一对，用于导通一路通道</td>
    </tr>
    <tr>
      <td style="text-align: center">1k电阻</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">用于817光耦的上拉</td>
    </tr>
    <tr>
      <td style="text-align: center">湿润的纸巾</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">屏幕上用湿润的纸巾作为触发点效果很好</td>
    </tr>
  </tbody>
</table>

<h1 id="section-1">二、黑块的识别</h1>

<h2 id="section-2">2.1 光敏电阻</h2>
<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/0.jpg" alt="0.jpg" /></p>

<p>  光敏电阻的特性是光线越强电阻越小，光线越弱电阻越大。电路如下：</p>

<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/1.png" alt="1.png" /></p>

<p>  只要上面的电阻选得合适，光敏电阻在黑块和白块之间就会有明显的电压变化。<br />
  我选用的上拉电阻是51k，放在白块的电压大约是0.5v，放在黑块的电压大约是1.5v。从电压看来上拉电阻还可以再小一些，但只要能产生稳定、明显的电压变化即可。</p>

<p>  注：DIY时关掉手机或者平板的自动背光调节，避免干扰。</p>

<h2 id="section-3">2.2 电压比较器</h2>
<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/3.jpg" alt="3.jpg" /></p>

<p>  电压比较器采用的是lm393，这是双路电压比较器芯片。通过电压比较器可以区分上述光敏电阻在黑块和白块之间的电压变化，电路如下：</p>

<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/2.JPG" alt="2.jpg" /></p>

<p>  R1和RL就是上面提到的光敏电阻分压电路，接到lm393的反相输入端。<br />
  R3是电位器，接到lm393的同相输入端。<br />
  R2是led限流电阻，用的是1K欧。</p>

<p>  电位器的电压应当调为光敏电阻在黑、白块时分压电路输出电压的中间，这样：<br />
  当光敏电阻分压的电压比电位器电压高时（在黑块上），1out引脚输出低电平，此时led点亮；<br />
  当光敏电阻分压的电压比电位器电压低时（在白块上），1out引脚输出高电平，此时led熄灭。</p>

<p>  以上就是一路的黑块识别电路。</p>

<h1 id="section-4">三、触摸屏的触发</h1>

<h2 id="section-5">3.1 触摸点的引出</h2>
<p>  屏上触摸点可以通过导线引出再接地，原理和触摸笔类似。4点说明：<br />
  1、对于android设备可以打开开发者选项里的显示触摸位置，方便调试；对于ios设备还没找到好的显示触摸位置的方法。<br />
  2、导线应当越粗越好，但我实际用较细的导线效果也可以接受。<br />
  3、关于屏幕上的触摸点，很多人用硬币之类的东西，我发现用浸湿的纸巾会有很好的效果，还可以节省触摸面积。<br />
  4、使用导线引出触摸点的方法，人体对屏幕的影响相比较直接触摸要弱得多，经常会出现触摸不灵敏的情况，而且手机触摸屏也会有防水的算法。<br />
  包括在后面加入光耦控制后，遇到这种触摸不灵敏的情况，一个建议是先不要接地（手不要触摸导线），再把屏幕灭屏唤醒一次，此时由于触摸屏的防水算法不会认为有触摸，然后再用手触摸导线，此时会有较好的效果。</p>

<p>  完成之后大概就是这个样子：</p>

<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/4.png" alt="4.png" /></p>

<h2 id="section-6">3.2 触摸的控制</h2>
<p>  我们需要一个开关来控制导线和人体的通断。<br />
  继电器是一个选择，但继电器是机械触发，速度可能比较慢，所以最终没有采用，而是用了光耦。</p>

<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/5.jpg" alt="5.jpg" /></p>

<p>  817光耦的引脚图如下：</p>

<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/6.png" alt="6" /></p>

<p>  当1–&gt;2导通时，4–&gt;3方向导通，这样就形成了一个开关。</p>

<p>  但是！这样可能并不能满足需求，单个光耦的导通方向是单向的，而触摸屏和人体之间的电流可能是双向的，所以我们需要两个光耦进行双向导通。（注：我没有验证过单个光耦能否工作，因为之前有其它地方遇到过必须双向导通，所以这里为了保险直接用了双向导通的方案）<br />
  双向导通的光耦连接方法：</p>

<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/7.JPG" alt="7" /></p>

<p>  这样连接后A和B就双向导通了，一端连接手机触摸屏，一端连接人体即可。<br />
  这里R1和R2我用的都是1k欧的电阻。</p>

<h1 id="section-7">四、整体组装</h1>

<h2 id="section-8">4.1 黑块检测和触摸的结合</h2>
<p>  2.2节介绍了如何通过lm393识别黑块，并且在检测到黑块时会点亮led。<br />
  3.2节的电路实现了触摸屏的电子触发。</p>

<p>  只要把这两个电路结合起来就能实现检测到黑块时触摸屏幕：</p>

<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/8.JPG" alt="8" /></p>

<p>  上图中A和触摸屏相连，B和人体相连，光敏电阻RL贴在显示屏上。<br />
  以上是一路的检测和触摸电路，别踩白块儿需要4路，做4路同样的电路即可。</p>

<h2 id="section-9">4.2 安装与调试</h2>
<p>  <strong>1、触摸屏触发技巧</strong><br />
  屏幕触点用湿润的纸巾效果是不错的，工作过程中需要保持纸巾的湿润。<br />
  另外在3.1节也有提到过，经过光耦和导线后，人体对触摸屏的影响是很弱的，当遇到触摸不灵敏时有一个技巧是人体先不要接触导线–&gt;灭屏唤醒一次–&gt;人体接触导线–&gt;反复开关光耦，直到屏幕被触发。<br />
  可能每个人遇到的情况会不一样，只有你亲自动手才能找到技巧。</p>

<p>  <strong>2、触点和光敏电阻的位置</strong><br />
  一开始是把触点放在了光敏电阻的上面，这样放置当黑块下降速度稍微快点时就会漏点。<br />
  后来把光敏电阻和触点平行放置，光敏电阻甚至稍微有点偏上，这样效果要好得多。</p>

<p>  完成之后的样子大概是这样：</p>

<p>  <img src="http://nicekwell.net/images/diy/2016-10-08-bie-cai-bai-kuai-er-bot/9.png" alt="9" /></p>

<p><br />
<br />
  到这就全部制作完成了，快去破纪录吧！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第6章 面向对象思想+事件驱动结构]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou.html"/>
    <updated>2016-09-19T23:52:32+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-6zhang-mian-xiang-dui-xiang-si-xiang-plus-shi-jian-qu-dong-jie-gou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 对象和事件</a></li>
  <li><a href="#c" id="markdown-toc-c">2. C语言对一个对象的封装</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">3. 事件分配机制</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">4. 系统层构建</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">5. 库函数</a></li>
</ul>

<p>  先来看一下这个东西吧：<a href="http://v.youku.com/v_show/id_XNTk2NzExMjg4.html">http://v.youku.com/v_show/id_XNTk2NzExMjg4.html</a>。</p>

<p>  看完之后应该会觉得这个东西的结构非常复杂，这是笔者做过的最复杂的项目之一。由于是给公司开发的，所以和上一章一样不能公开源代码，但是会举一些简单的例子说明。<br />
  刚接到这个项目了解了大体功能后，第一反应是用“界面函数”的结构。确实，这个东西是非常适合用界面函数完成的，但是由于当时笔者正在自学C++，于是用C++的思路分析了一下这个项目：<br />
  1、总共有4个界面，而且有两个和列表框好像啊。<br />
  2、几乎所有的动作都是由旋转编码器触发的。<br />
  经过一番思考之后，笔者决定做一次尝试，用面向对象的思想加上事件驱动的机制完成它。</p>

<p>  下面就介绍一下这种结构，也希望能借此说明“对象”和“事件”的概念。</p>

<!-- more -->

<h1 id="section">1. 对象和事件</h1>

<p>  基本上每个面向对象语言的书都会把对象的概念说一下。在这个项目里有4个界面，把这四个界面看作四个对象，这四个对象的所有动作都由事件驱动。<br />
  什么又是“事件”呢？简单来说“一个对象发生了某个事情”就是这个对象的某种事件。事件一定是基于某个特定的对象而言的，不能简单地说“发生了某个事情”，应该说“某个对象发生了某个事情”。而我们要做的就是确定“每个对象有哪些事情会发生”，并完成“某个对象在发生某个事情时要做的事”。</p>

<p>  所以对于一个对象而言，它应该有：</p>

<ul>
  <li>1、与它对应的事件函数，用于执行“某个事件发生时要做的事”，一个对象所拥有的这些函数的个数和它可能发生的事件数是相等的。</li>
  <li>2、完成上述函数所需要的辅助函数。<br />
这些函数有些可能是公共的，是由系统提供的API或者其他工具函数；<br />
也可能是这个对象特有的，是对这个对象做的某种更改。</li>
  <li>3、每个对象都有自己的属性，这些属性在程序中的体现就是变量。</li>
</ul>

<p>  这里面，1和2的函数本质上都是一样的，都是这个对象所包含的函数。不同的是：<br />
  与事件相对应的函数称它为这个对象的“事件”，这些函数数量与这个对象的事件数是相等的；<br />
  完成某种特定操作的函数称它为这个对象的“方法”，也就是“这个对象可以做的事”。并且这些方法中，有些是允许被外界调用的，有些只允许在本对象内使用，所以又分为“公共方法”和“私有方法”。</p>

<p>  下面就以一张表来说明一个对象内部的组成，以及各个成员的含义：</p>

<p><img src="http://nicekwell.net/images/dan-pian-ji-bian-cheng/duixiang.png" alt="对象的组成" /></p>

<p>  有了这些了解之后我们就可以开始构建整个系统了。</p>

<h1 id="c">2. C语言对一个对象的封装</h1>

<p>  在C++ 中有专门的对象结构，它可以把对象里的函数和变量分为公共、私有等类型。</p>

<p>  而在C语言中没有这样的结构，我们通过使用上的约定也可以达到同样的效果。比如一个内部的函数，我们约定有些函数外部可以调用，它就是公共函数；约定有些函数外部不要调用，它就是私有函数。</p>

<p>  下面是对象的各个部分在C语言中的形式及意义：</p>

<p><img src="http://nicekwell.net/images/dan-pian-ji-bian-cheng/duixiang1.png" alt="对象的各个部分在C语言中的形式及意义" /></p>

<p>  公共方法和事件本质上都是对外公开的函数。公共方法完成对本对象的某一主动的操作，而事件是完成对外部被动的响应。<br />
  甚至可以把事件从对象的组成中取出来，把事件归到系统范畴。</p>

<hr />

<p>  下面就以一个简单的列表框的例子说明如何封装一个对象，假设这个列表框（对象）的名字叫做List1，一共只有3个列表项，每个列表项都有一个自己的名称和内容（0~255），有一个光标指示当前选中列表项，分配的事件有“列表项+1”“列表项-1”“列表项内容+1”“列表项内容-1”，并且这些改变是可以循环的（255+1=0，0-1=255）。</p>

<p>  假设屏幕显示的网格是4行16列，外部提供的绘图函数有：<br />
  Disp(r,c,unsigned char *)       //往r行c列写入一个字符串<br />
  Clear()        //清屏</p>

<p>  有了这些条件后，对这个对象的封装如下：</p>

<ul>
  <li>List1.c</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* List1 */
</span><span class="line">void Clear();	//清屏函数
</span><span class="line">void Disp(unsigned char r,unsigned char c,unsigned char *p);	//在r行c列显示字符串
</span><span class="line">/**************公共变量*****************/
</span><span class="line">#define List1_ListCount 3	//列表长度为固定
</span><span class="line">unsigned char List1_ListIndex=0;	//当前选中的列表项，从0开始数
</span><span class="line">#define List1_StartIndex 0	/*当前屏幕显示的第一个列表项序号，从开始数，
</span><span class="line">				由于屏幕能一次性把所有的3个列表项都显示出来，所以这里是固定的值。*/
</span><span class="line">unsigned char List1_ListData[3];	//三个列表项的数据
</span><span class="line">/**************私有变量***************/
</span><span class="line">unsigned char code List1_Name0[]="Power";	//第0号列表项的名称
</span><span class="line">unsigned char code List1_Name1[]="Mode ";	//第1号列表项的名称
</span><span class="line">unsigned char code List1_Name2[]="K    ";	//第2号列表项的名称
</span><span class="line">/**************私有方法***************/
</span><span class="line">void List1_DispName()	//在固定位置显示个列表项的名称
</span><span class="line">{
</span><span class="line">	Disp(0,1,ListName0);	//显示号列表项名称
</span><span class="line">	Disp(1,1,ListName1);	//显示号列表项名称
</span><span class="line">	Disp(2,1,ListName2);	//显示号列表项名称
</span><span class="line">}
</span><span class="line">void List1_DispCursor()	//在当前选中列表项前显示“&gt;”，没选中的显示空格
</span><span class="line">{
</span><span class="line">	unsigned char i;
</span><span class="line">	for(i=0;i&lt;List1_ListCount;i++)
</span><span class="line">	{
</span><span class="line">		if(i==List1_ListIndex)
</span><span class="line">			Disp(i,0,"&gt;");
</span><span class="line">		else
</span><span class="line">			Disp(i,0," ");
</span><span class="line">	}
</span><span class="line">}
</span><span class="line">void List1_DispData(unsigned char n)	//显示n号列表项的数据
</span><span class="line">{
</span><span class="line">	unsigned char vm[4];	//现存，以十进制显示，总共三位数
</span><span class="line">	//先计算现存
</span><span class="line">	vm[0]=List1_ListData[n]/100+0x30;	//计算百位的现存
</span><span class="line">	vm[1]=(List1_ListData[n]%100)/10+0x30;	//计算十位的现存
</span><span class="line">	vm[2]=List1_ListData[n]%10+0x30;	//计算个位的现存
</span><span class="line">	vm[3]='\0';	//字符串结尾
</span><span class="line">	//下面开始显示
</span><span class="line">	Disp(n,10,vm);	//从n行列开始写入数据
</span><span class="line">}
</span><span class="line">/***************公共方法************************/
</span><span class="line">void List1_Show()
</span><span class="line">{
</span><span class="line">	//先清屏
</span><span class="line">	Clear();
</span><span class="line">	//再显示所有列表项的名称
</span><span class="line">	List1_DispName();
</span><span class="line">	//再显示所有列表项的数据
</span><span class="line">	{
</span><span class="line">		unsigned char i;
</span><span class="line">		for(i=0;i&lt;List1_ListCount;i++)
</span><span class="line">			List1_DispData(i);
</span><span class="line">	}
</span><span class="line">	//再显示光标
</span><span class="line">	List1_DiapCursor();
</span><span class="line">}
</span><span class="line">void List1_Hide()
</span><span class="line">{
</span><span class="line">	Clear();
</span><span class="line">}
</span><span class="line">void List1_SelectedListP1()	//当前选中项内容+1
</span><span class="line">{
</span><span class="line">	List1_ListData[List1_ListIndex]++;
</span><span class="line">	List1_DispData(List1_ListIndex);
</span><span class="line">}
</span><span class="line">void List1_SelectedListM1()	//当前选中项内容-1
</span><span class="line">{
</span><span class="line">	List1_ListData[List1_ListIndex]--;
</span><span class="line">	List1_DispData(List1_ListIndex);
</span><span class="line">}
</span><span class="line">void List1_ListP1()	//选中项序号+1
</span><span class="line">{
</span><span class="line">	List1_ListIndex++;
</span><span class="line">	if(List1_ListIndex==3)	//实现循环
</span><span class="line">		List1_ListIndex=0;
</span><span class="line">	List1_DispCursor();	//刷新光标
</span><span class="line">}
</span><span class="line">void List1_ListM1()	//选中项序号-1
</span><span class="line">{
</span><span class="line">	List_ListIndex--;
</span><span class="line">	if(List_ListIndex==0xff)	//实现循环
</span><span class="line">		List1_ListIndex=2;
</span><span class="line">	List1_DispCursor();	//刷新光标
</span><span class="line">}
</span><span class="line">/**************事件******************/
</span><span class="line">void List1_Key0Down()	//0号键按下，让选中项序号-1
</span><span class="line">{
</span><span class="line">	List1_ListM1();
</span><span class="line">}
</span><span class="line">void List1_Key1Down()	//1号键按下，让选中项序号+1
</span><span class="line">{
</span><span class="line">	List1_ListP1();
</span><span class="line">}
</span><span class="line">void List1_Key2Down()	//2号键按下，让选中项内容-1
</span><span class="line">{
</span><span class="line">	List1_SelectedListM1();
</span><span class="line">}
</span><span class="line">void List1_Key3Down()	//3号键按下，让选中项内容+1
</span><span class="line">{
</span><span class="line">	List1_SelectedListP1();
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  在其他地方只要包含这个List1.c文件就可以调用该对象里的各种方法和事件函数了，里面的私有方法和私有变量虽然约定外部是不要使用的，但是外部确实是可以调用的。所以也可以为这个对象写一个List1.h文件，只把公开的部分进行声明：</p>

<ul>
  <li>List1.h</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* List1 */
</span><span class="line">#ifndef LIST1_H
</span><span class="line">#define LIST1_H
</span><span class="line">
</span><span class="line">#define List1_ListCount 3	//列表长度为固定
</span><span class="line">unsigned char List1_ListIndex=0;	//当前选中的列表项，从开始数
</span><span class="line">#define List1_StartIndex 0	/*当前屏幕显示的第一个列表项序号，从开始数，
</span><span class="line">					由于屏幕能一次性把个列表项都显示出来，所以这里是固定。*/
</span><span class="line">unsigned char List1_ListData[3];	//三个列表项的数据
</span><span class="line">/***************公共方法************************/
</span><span class="line">void List1_Show();
</span><span class="line">void List1_Hide();
</span><span class="line">void List1_SelectedListP1();	//当前选中项内容+1
</span><span class="line">void List1_SelectedListM1();	//当前选中项内容-1
</span><span class="line">void List1_ListP1();//选中项序号+1
</span><span class="line">void List1_ListM1();//选中项序号-1
</span><span class="line">/**************事件******************/
</span><span class="line">void List1_Key0Down();	//0号键按下，让选中项序号-1
</span><span class="line">void List1_Key1Down();	//1号键按下，让选中项序号+1
</span><span class="line">void List1_Key2Down();	//2号键按下，让选中项内容-1
</span><span class="line">void List1_Key3Down();	//3号键按下，让选中项内容+1
</span><span class="line">
</span><span class="line">#endif</span></code></pre></td></tr></table></div></figure>

<p>  如果采用了List1.h的话，要把List1.c文件里重复定义的部分给去掉。<br />
  每个对象有每个对象的特点，它们差别很大，构建方法也是大不相同的。但是每个对象构建好之后就是一个模板，它是非常独立的，在其他地方只要把代码直接复制过去做少量更改就可以使用了。</p>

<h1 id="section-1">3. 事件分配机制</h1>

<p>  一个工程中会有多个对象，每个对象都有一些可能会发生的事件，这些事件函数是由系统调用的，由系统来判断什么对象发生了什么事件。<br />
  比如在这个项目中，基本的事件有：左编码器按下、右编码器按下、左编码器左旋、左编码器右旋、右编码器左旋、右编码器右旋、左编码器按下左编码器左旋、左编码器按下左编码器右旋、右编码器按下右编码器左旋、右编码器按下右编码器右旋、串口接收数据事件、IIC接收数据事件。<br />
  由于旋转编码器的驱动本身用的就是外部中断，外部中断对单片机来说就是一种意外事件。所以只要在中断里判断当前进行的是什么操作，并记录当前哪个界面正在被使用，就可以调用相应对象的相应事件了。<br />
  然而，并不是所有的对象都一定具有所有的这些事件，根据该对象功能的需要，选用一部分有用的事件进行响应。比如在IIC界面里不考虑串口，这个界面就只响应IIC接收数据事件，而忽略串口接收数据事件。<br />
  事件并不一定非要由外部中断产生，也可能是系统虚拟的。<strong>总之事件分配有系统完成，系统利用各个资源抽象出事件概念，然后分配到相应对象上。</strong></p>

<p>  下面是一个完成事件分配的例子：</p>

<p><img src="http://nicekwell.net/images/dan-pian-ji-bian-cheng/eint.png" alt="中断电路" /></p>

<p>  有两个按键，任意一个按键按下都会触发int0中断。假设共有2个对象，下面是事件分配的代码：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
</pre></td><td class="code"><pre><code class=""><span class="line">unsigned char FocusNum=0;	//标志当前获焦的对象序号，在此只有两个对象，范围是0~1
</span><span class="line">sbit kint0=P3^2;
</span><span class="line">sbit k0=P0^0;
</span><span class="line">sbit k1=P0^1;
</span><span class="line">
</span><span class="line">……
</span><span class="line">
</span><span class="line">void int0() interrupt 0
</span><span class="line">{
</span><span class="line">    EA=0;	//关中断
</span><span class="line">
</span><span class="line">    if(k0==0)	//说明是k0按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_k0Down();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_k0Down();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    else if(k1==0)	//说明是k1按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_k1Down();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_k1Down();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    while(kint0==0);	//等待两个按键都释放     IE0=0;	//清除中断标志，防止在中断处理程序执行过程中再次触发了中断     EA=1;	//开中断
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  采用FocusNum来记录当前激活的对象。</p>

<p>  在此想说明的是，k0和k1两个操作都是放在一个中断里的，具体产生什么事件则是再次通过代码判断的，这些代码属于系统层，是根据实际需要对事件的抽象。</p>

<p>  比如如果需要产生“两个按键同时按下”事件，则可按如下方式分配：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void int0() interrupt 0
</span><span class="line">{
</span><span class="line">    unsigned char 
</span><span class="line">    EA=0;	//关中断
</span><span class="line">    mdelay(200);    //这个延时是为了等待两个按键的状态都稳定，虽然我们是把两个按键同时按下，
</span><span class="line">                    //但肯定因为某个先按下触发中断，此时检测另一个按键不一定是按下的状态
</span><span class="line">    if(k0==0 &amp;&amp; k1!=0)	//说明是k0按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_k0Down();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_k0Down();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    else if(k1==0 &amp;&amp; k0!=0)	//说明是k1按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_k1Down();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_k1Down();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    else if(k0==0 &amp;&amp; k0==0)	//两个按键都按下
</span><span class="line">    {
</span><span class="line">        switch(FocusNum)
</span><span class="line">        {
</span><span class="line">        case 0:	//对象0
</span><span class="line">            Form0_BothDown();
</span><span class="line">            break;
</span><span class="line">        case 1:	//对象1
</span><span class="line">            Form1_BothDown();
</span><span class="line">            break;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    while(kint0==0);	//等待两个按键都释放
</span><span class="line">    IE0=0;	//清除中断标志，防止在中断处理程序执行过程中再次触发了中断
</span><span class="line">    EA=1;	//开中断
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  甚至可以继续改，实现“k0按下时k1按下”“k1按下时k0按下”“k0长按”“k0连按”等事件，这里就不一个个实现了。<br />
  总之只要系统层能够识别的动作都可以抽象成事件。</p>

<h1 id="section-2">4. 系统层构建</h1>

<p>  在以前的编程中从来没把程序这么明确地分层，可能是因为这次项目比较复杂，并且用来面向对象的方法，所以这种结构自然就产生了。在各个对象中有一些公共方法，这些函数完成特定的功能，而他们都依赖于底层的支持。<br />
  当然可以让对象直接操作驱动函数，从最底层开始。但是这样的话，一方面用起来会很麻烦，另一方面可能不是所有的底层功能都会用到。<br />
  所以让系统层根据上层对象的需要把这些功能封装，并向上层提供使用接口。这是系统层做的事情之一。<br />
  另外系统层也会构建一些控制逻辑，这些功能并不在底层有实体的驱动函数，它是系统在软件层面抽象出来的。比如当前系统的数据显示进制、背光灯时间等，它们不对应底层的操作，仅在系统层抽象。对于上层的对象来说，根本不需要考虑这些，只要调用系统层提供的API就行了。<br />
  此外，系统层要做的当然还有事件分配，上一节介绍的事件分配系统是系统层核心的一部分，而系统层还有其他很多功能。事件分配系统是利用各个资源抽象出事件概念，并分配给各个对象。而本节讨论的系统层是利用各个资源，在底层驱动的支持下，根据需要构建出一些控制逻辑，并封装成系统API，供上层软件使用。</p>

<p>  综上，系统层做的事情有：<br />
  1、构建事件分配系统。<br />
  2、对底层驱动封装，并向上层提供操作接口。<br />
  3、根据需要再构建一些其他控制结构，并向上提供接口。</p>

<h1 id="section-3">5. 库函数</h1>

<p>  库函数也属于对系统对底层的封装。某些功能可能比较复杂，可以构成一整套体系，那么就可以把这些函数归位一类，作为完成某个功能的库函数。<br />
  这点和类似于操作系统的GTK库或者QT库，它们提供了大量的绘图函数。<br />
  在本项目中，使用了绘图库，它就是在底层对液晶屏操作的基础上建立的文字和图片显示函数，提供了在指定位置写入字符、汉字，以及反色写入、垂直镜像写入等功能。上层的对象调用这些函数会非常方便。<br />
  总结一下库的作用：利用系统层的API，或者跳过系统层直接调用驱动函数，构建出自己的一套控制逻辑，并对外提供基于这个控制逻辑的函数库。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第5章 定时器执行任务]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-5zhang-ding-shi-qi-zhi-xing-ren-wu.html"/>
    <updated>2016-09-19T22:52:11+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-5zhang-ding-shi-qi-zhi-xing-ren-wu</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 定时器执行任务的程序结构</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 定时器里面任务函数的特点</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3. 过程任务的定时器化</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4. 定时器执行任务程序结构总结</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">5. 我们追求的是什么</a></li>
</ul>

<p>  先来回顾一下：<br />
  在第2章中介绍了界面函数结构，它的思想是主进程为主体，外部的按键等作为特殊情况单独处理。但是当接触到的程序更复杂时，尤其是当程序里还要进行精确定时时，用单进程结构已经满足不了要求了，这就进一步产生了第3章的结构——定时器分配任务。<br />
  定时器分配任务结构在主进程结构基础上开辟了一个定时器进程，在这个进程里进行按键扫描任务、计时任务等。此时这些任务是不会被中断的，定时并且精确地每隔一段时间执行一次。当时的看法是：这些定时器里的进程完成任务后把结果保存，主进程可以选用这些结果进行处理。<br />
  此外定时器还要进行一个特殊的功能——给主进程下达命令，通知主进程进行某种动作。这个功能的本质就是向主进程提供了时间信息。<br />
  这种结构已经结合了定时器，并且已经把一些简短的代码直接放到了定时器中断处理程序里了，但还有相当一部分代码放在主进程里。不是说不能放在主进程里，而是当时没有明确出定时器中的各个进程是如何形成的，这些定时器中的任务有什么更深刻的特征。<br />
  本章就是专门讨论这些放在定时器里执行的任务。</p>

<!-- more -->

<p>  这种结构也有产生的背景，它源于一个“温度控制系统”的项目，具体内容大概有：数码管扫描、按键扫描、时间计时、蜂鸣器控制、温度控制，当温度低于某个值时启动一个固定功率的加热器，温度高于某个值时停止加热，温度更高时启动报警。<br />
  由于这是给公司做的项目，所以不公开源代码，不过不需要源代码也完全可以理解这个结构。<br />
  这个项目并不复杂，功能要求很明确，没有多个工作模式和界面。按开始的想法，这里面除了计时任务需要定时器外，其他任务都可以放在主进程里完成。但是这样的话可能就会出现各个任务之间的相互干扰，比如按下按键时进程被阻塞，数码管扫描就无法得到运行。<br />
  所以，在做这个项目时我尝试了另一种方法——把这些任务全部放在定时器中断处理程序里，由定时器驱动每个任务的运行，主循环什么也不做。<br />
  完成之后事实证明这种结构效果很不错，并且体现出了很多操作系统的思想。下面就来分析一下这种结构。</p>

<h1 id="section">1. 定时器执行任务的程序结构</h1>
<p>  【时间分配系统】
  这种结构的任务需要在定时器中断里执行，而定时器中断的时间不一定是任务想要调用的时间，并且不同的任务的调用时间可能不同。所以肯定有一个时间分配系统，这个系统在特定的时间调用不同的任务函数。<br />
  比如在这次的工程中，51单片机的定时器8位自动填装模式的定时时间不会太长，定时时间设为250us。而按键扫描、数码管扫描、蜂鸣器控制、温度控制、时间控制，这几个任务的执行时间是不一样的：</p>

<table>
  <tbody>
    <tr>
      <td>  </td>
      <td>任务名称</td>
      <td>调用时间</td>
    </tr>
    <tr>
      <td>  </td>
      <td>——</td>
      <td>——</td>
    </tr>
    <tr>
      <td>  </td>
      <td>按键扫描</td>
      <td>5ms一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>按键处理</td>
      <td>5ms一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>数码管扫描</td>
      <td>250us一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>蜂鸣器控制</td>
      <td>5ms一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>温度检测</td>
      <td>1s一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>温度控制</td>
      <td>1s一次</td>
    </tr>
    <tr>
      <td>  </td>
      <td>计时和时间控制</td>
      <td>1min一次</td>
    </tr>
  </tbody>
</table>

<p>  在这里请大家回顾一下，第三章里提到过这样一个问题：当500ms来临时，需要完成的任务有 按键扫描、1602刷新显示、电源管理，（温度采集暂且忽略），定时器中断周期只有200us，现在一下子来了这么多任务，一个中断周期内可以处理完吗？<br />
  当时采用的方法是把一些对时序要求不高的程序放到主进程里完成，而在这里我们还有另一种方法——把任务错开放在不同的定时器中断周期里。虽然这里面的每一个单独的任务都可以在一个定时器中断周期里完成，但是可能会有某个定时器周期里同时来了多个任务，这有可能会导致在一个定时器周期里不能处理完，所以一定要注意时间分配系统要把任务错开放在不同的定时器周期里。<br />
  比如按键扫描和蜂鸣器控制都是5ms执行一次，但是它们却不在同一次定时器中断内执行，因为定时器中断周期是250us，如果在一个中断时处理多个任务可能时间比较长，不能在250us内处理完，所以将它们错开分到不同的时间段内执行，但是周期仍然是5ms。</p>

<p>  时间分配代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void t0() interrupt 1 	//250us一次中断
</span><span class="line">{
</span><span class="line">    static unsigned char numto5ms=0;	//用于5ms计时
</span><span class="line">    static unsigned char numto1min=0;	//用于1min计时
</span><span class="line">    /***数码管扫描任务***/	//数码管扫描，每次中断都执行，这里省略数码管扫描代码
</span><span class="line">
</span><span class="line">    numto5ms++;
</span><span class="line">    if(numto5ms==5)	//5ms一次，温度检测
</span><span class="line">    {
</span><span class="line">        /***温度检测任务***/
</span><span class="line">    }
</span><span class="line">    else if(numto5ms==10)	//5ms一次，蜂鸣器发生
</span><span class="line">    {
</span><span class="line">        /***蜂鸣器发声任务***/
</span><span class="line">    }
</span><span class="line">    else if(numto5ms==15)	//5ms一次，按键扫描
</span><span class="line">    {
</span><span class="line">        /***按键扫描任务***/
</span><span class="line">    }
</span><span class="line">    else if(numto5ms==20)	//5ms到了，进行分钟判断，此时numto5ms要清
</span><span class="line">    {
</span><span class="line">        numto5ms=0;
</span><span class="line">        numto1min++;
</span><span class="line">        if(numto1min==12000)	//1min到了
</span><span class="line">        {
</span><span class="line">            numto1min=0;
</span><span class="line">            /***时间处理任务***/
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  【任务执行函数】</p>

<p>  任务执行函数就是在定时器里调用的用于完成某种任务的函数。<br />
  这个函数的具体特点将在下节介绍，因为很重要。</p>

<h1 id="section-1">2. 定时器里面任务函数的特点</h1>

<p>  首先分析一下这种任务函数的特点和要求：</p>

<ul>
  <li>1、这些函数由定时器调用，所以对于它们的调用时间是很精确地每隔固定时间调用一次。</li>
  <li>2、由于这些函数是放在定时器里，所以<strong>这些函数必须简短，不能占用过长时间，必须可以在一个定时器中断周期内全部处理完。</strong></li>
  <li>3、与在主进程连续执行的任务函数相比，这种函数的调用是周期、间断的，这种周期间断性的调用，决定它自己<strong>必须具有记忆以前的状态的能力</strong>，只有这样才能在本次被调用时决定应该进行什么样的操作。<br />
在上一章“占用式与非占用式程序结构分析”中已经明确了非占用式程序结构的优势，并且也明确了其内部结构：<br />
<img src="http://nicekwell.net/images/dan-pian-ji-bian-cheng/feizhanyongshichengxu.jpg" alt="非占用式程序的一般结构" title="非占用式程序的一般结构" /><br />
  有了上一章的基础就好理解这些在定时器里的任务函数了，实际上这些任务函数和在主进程连续执行的任务函数相比，就是把它们改为了非占用式程序放在定时器里执行。</li>
  <li>4、由于要保证每个任务都要在很短的时间内执行结束，所以就要求每个任务不能阻塞进程，不论这个任务当前处于什么情况，应当执行一次之后立马退出。<br />
这样，<strong>不论某个进程的执行情况如何，其他进程绝对都会继续执行，也就把各个进程独立开了，保证每个进程都会得到及时的执行。</strong></li>
  <li>5、各个进程相对独立，但各个进程间也有通信。比如按键扫描进程把按键码传递给其他进程；蜂鸣器进程通过变量接收外部下达的响铃指令。<br />
要注意一个特点：<strong>由于定时器里面的任务函数是被周期性的调用的，所以如果想使用某个进程的功能，必然不可能像以前那样通过调用函数来实现，因为它本身就一直在被调用着，必然是通过这个进程对外设置的接口变量来实现。</strong></li>
</ul>

<h1 id="section-2">3. 过程任务的定时器化</h1>

<p>  这里讨论如何把一个过程化的程序改成定时器化的程序。<br />
  没有找到通用的方法，可以确定的是定时器化的任务结构肯定就是像非占用式程序结构那样。<br />
  下面举几个定时器化的程序的例子。</p>

<ul>
  <li>数码管扫描</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void smgdisp()
</span><span class="line">{
</span><span class="line">	static unsigned char n;
</span><span class="line">	n++;
</span><span class="line">	if(n==8)
</span><span class="line">		n=0;
</span><span class="line">
</span><span class="line">	smgndisp(n,?);
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  用静态变量n记忆点亮的数码管序号，这样轮换点亮完成扫描。<br />
  还想举一下上一章里面的扫描全彩点阵的程序：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void refresh7()
</span><span class="line">{
</span><span class="line">	static unsigned char r=0;
</span><span class="line">	static unsigned char flagrgb=0;	//当前需要点亮的颜色，0-R,1-G,2-B
</span><span class="line">	static unsigned char num=0;
</span><span class="line">	num++;
</span><span class="line">	if(num==32)
</span><span class="line">	{
</span><span class="line">		num=0;
</span><span class="line">		flagrgb++;
</span><span class="line">		if(flagrgb==3)	//说明三种颜色都扫描完了
</span><span class="line">		{
</span><span class="line">			flagrgb=0;	//从红色开始扫描
</span><span class="line">			r++;		//开始扫描下一行
</span><span class="line">			if(r==8)	//如果发现行都扫描结束则从第行开始扫描
</span><span class="line">				r=0;
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	if(num&lt;light7)	//说明需要点亮
</span><span class="line">	{
</span><span class="line">		switch(flagrgb)
</span><span class="line">		{
</span><span class="line">		case 0:	//扫描红色
</span><span class="line">			DPw = ~(0x01&lt;&lt;r);
</span><span class="line">			DPr = ~vm7r[r];//送入R灯IO接口显示
</span><span class="line">			break;
</span><span class="line">		case 1:	//扫描绿色	
</span><span class="line">			DPw = ~(0x01&lt;&lt;r);
</span><span class="line">			DPg = ~vm7g[r];
</span><span class="line">			break;
</span><span class="line">		case 2:	//扫描蓝色
</span><span class="line">			DPw = ~(0x01&lt;&lt;r);
</span><span class="line">			DPb = ~vm7b[r];
</span><span class="line">			break;
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">	else	//说明不需要点亮
</span><span class="line">	{
</span><span class="line">		DPw=0xff;
</span><span class="line">		DPr=0xff;
</span><span class="line">		DPg=0xff;
</span><span class="line">		DPb=0xff;
</span><span class="line">	}
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  也是通过静态变量记忆，完成某行某个颜色的亮度判断。</p>

<ul>
  <li>按键扫描</li>
</ul>

<p>  简单的一个按键扫描程序在上一章也例举过：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static unsigned char keylast;	//保存上次的按键值
</span><span class="line">if(key==0 &amp;&amp; keylast==1)	//检测到一个下降沿
</span><span class="line">{
</span><span class="line">	/*do something*/
</span><span class="line">}
</span><span class="line">keylast=key;</span></code></pre></td></tr></table></div></figure>

<p>  下面例举一个增强型的按键扫描程序，它可以识别多个按键按下、释放：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void keyscan()	//5ms调用一次 
</span><span class="line">
</span><span class="line">{
</span><span class="line">	static unsigned int key;	//本次扫描结果
</span><span class="line">	static unsigned int keylast=0xffff;	//上次扫描结果
</span><span class="line">	unsigned char i,j;
</span><span class="line">
</span><span class="line">	//开始扫描
</span><span class="line">	for(i=0;i&lt;=3;i++)
</span><span class="line">	{
</span><span class="line">		DPkey=~pow2[i];    //pow[]是一个数组，代表2^i
</span><span class="line">		for(j=4;j&lt;=7;j++)
</span><span class="line">		{
</span><span class="line">			if(DPkey&amp;pow2[j])	//是1
</span><span class="line">			{
</span><span class="line">				key|=pow2[4*i+7-j];
</span><span class="line">			}
</span><span class="line">			else	//是0
</span><span class="line">			{
</span><span class="line">				key&amp;=~pow2[4*i+7-j];
</span><span class="line">			}
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">	//开始判断上升沿和下降沿
</span><span class="line">	if(key^keylast)	//说明按键状态有变化
</span><span class="line">	{
</span><span class="line">		for(i=0;i&lt;=15;i++)
</span><span class="line">		{
</span><span class="line">			if((key&amp;pow2[i])==0 &amp;&amp; (keylast&amp;pow2[i]))	//下降沿，按键按下
</span><span class="line">			{
</span><span class="line">				/****在此添加i号按键按下时要做的事****/
</span><span class="line">			}
</span><span class="line">			else if((key&amp;pow2[i]) &amp;&amp; (keylast&amp;pow2[i])==0)	//上升沿，按键释放
</span><span class="line">			{
</span><span class="line">				/****在此添加i号按键释放时要做的事****/
</span><span class="line">			}
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	keylast=key;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  在这里我想说明的是，任何复杂的功能都可以写成这种“定时器化”的形式。<br />
  <em>如果希望更多的功能则需要添加其他结构，比如想要识别按键长按，则需要添加静态变量记忆按键状态并进行计时。</em><br />
  <strong>不管需要的功能如何，都是可以用这种结构实现的。</strong></p>

<ul>
  <li>蜂鸣器控制</li>
</ul>

<p>  这个相比较于上面两个比较特别，因为上面两个结构比较简单，目的明确，要干什么很清楚。而这个蜂鸣器控制任务平时不工作，当外部下达指令时才会发声。<br />
  所以想以此为例，再次说明<strong>任意功能都可以写成定时器内部任务的结构</strong>。虽然没有证明它，但看起来是这样的。<br />
  对于这个蜂鸣器控制进程来说，需要有一下几种功能：短响1声、短响2声、短响3声、长响1s。<br />
  这些功能在定时器任务里完成，通过一个变量通知这个进程执行哪种任务。<br />
  具体完成代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/*****************************以下是蜂鸣器任务相关*********************************
</span><span class="line">蜂鸣器的任务函数会由定时器5ms调用一次，由一个标志变量标志完成什么样的声音，使用时只要修改一下变量就行了。
</span><span class="line">总共有这么及几种声音：
</span><span class="line">	短响1声、短响2声、短响3声、长响1s
</span><span class="line">/**********************************************************************************/
</span><span class="line">unsigned char music=0;	/*对外接口，外部想要发声直接修改这个变量就可以了。
</span><span class="line">			0-不响
</span><span class="line">			1-短响声
</span><span class="line">			2-短响声
</span><span class="line">			3-短响声
</span><span class="line">			4-长响1s		*/
</span><span class="line">void beep()	//发声任务，由定时器每5ms调用一次
</span><span class="line">{
</span><span class="line">	static unsigned char flagDoing=0;	/*标志当前是否正在执行某个任务，0-不在，1-在
</span><span class="line">						当检测到music变量不为时说明有任务，此时将此变量置，标志正在执行；
</span><span class="line">						具体执行哪个任务根据music变量指示；
</span><span class="line">						当任务执行完毕时清此变量，标志没有任务，是空闲状态，清零music变量，标志没有任务将要执行。	*/
</span><span class="line">
</span><span class="line">	if(music==0)	//没有任务
</span><span class="line">	{
</span><span class="line">		buzzer=1;	//关闭蜂鸣器，	buzzer是蜂鸣器控制引脚，0-响，1-不响
</span><span class="line">	}
</span><span class="line">	else	//说明有任务
</span><span class="line">	{
</span><span class="line">		if(flagDoing==0)	//如果当前没有任务正在执行，则给当前任务赋值为想要执行的任务
</span><span class="line">			flagDoing=music;
</span><span class="line">
</span><span class="line">		if(flagDoing==1)	//短响声
</span><span class="line">		{
</span><span class="line">			static unsigned char count=0;	//用来计时
</span><span class="line">			buzzer=0;	//打开蜂鸣器
</span><span class="line">			count++;
</span><span class="line">			if(count==20)	//任务结束判断条件
</span><span class="line">			{
</span><span class="line">				count=0;	//为下次任务做准备
</span><span class="line">				buzzer=1;	//关闭蜂鸣器
</span><span class="line">				flagDoing=0;
</span><span class="line">				music=0;
</span><span class="line">			}
</span><span class="line">		}
</span><span class="line">		else if(flagDoing==2)	//短响声
</span><span class="line">		{
</span><span class="line">			static unsigned char count=0;
</span><span class="line">			count++;
</span><span class="line">			if(count&lt;=20)
</span><span class="line">				buzzer=0;	//打开蜂鸣器
</span><span class="line">			else if(count&gt;20 &amp;&amp; count&lt;=30)
</span><span class="line">				buzzer=1;	//关闭
</span><span class="line">			else if(count&gt;30 &amp;&amp; count&lt;=50)
</span><span class="line">				buzzer=0;	//打开
</span><span class="line">			else	//执行结束
</span><span class="line">			{
</span><span class="line">				count=0;
</span><span class="line">				buzzer=1;
</span><span class="line">				flagDoing=0;
</span><span class="line">				music=0;
</span><span class="line">			}
</span><span class="line">		}
</span><span class="line">		else if(flagDoing==3)	//短响声
</span><span class="line">		{
</span><span class="line">			static unsigned char count=0;
</span><span class="line">			count++;
</span><span class="line">			if(count&lt;=20)
</span><span class="line">				buzzer=0;	//打开蜂鸣器
</span><span class="line">			else if(count&gt;20 &amp;&amp; count&lt;=30)
</span><span class="line">				buzzer=1;	//关闭
</span><span class="line">			else if(count&gt;30 &amp;&amp; count&lt;=50)
</span><span class="line">				buzzer=0;	//打开
</span><span class="line">			else if(count&gt;50 &amp;&amp; count&lt;=60)
</span><span class="line">				buzzer=1;	//关闭
</span><span class="line">			else if(count&gt;60 &amp;&amp; count&lt;=80)
</span><span class="line">				buzzer=0;
</span><span class="line">			else	//执行结束
</span><span class="line">			{
</span><span class="line">				count=0;
</span><span class="line">				buzzer=1;
</span><span class="line">				flagDoing=0;
</span><span class="line">				music=0;
</span><span class="line">			}
</span><span class="line">		}
</span><span class="line">		else if(flagDoing==4)	//长响s
</span><span class="line">		{
</span><span class="line">			static unsigned char count=0;
</span><span class="line">			buzzer=0;	//打开蜂鸣器
</span><span class="line">			count++;
</span><span class="line">			if(count==140)	//结束条件
</span><span class="line">			{
</span><span class="line">				count=0;
</span><span class="line">				buzzer=1;
</span><span class="line">				flagDoing=0;
</span><span class="line">				music=0;
</span><span class="line">			}
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  用一个变量music来作为对外的API，通过它通知本进程执行哪个任务；<br />
  <strong>music和具体任务之间有一个中间变量flagDoing，这个变量是用来缓冲外部对此进程发送的指令的，只有当进程内部的某个任务执行结束后才会响应下一个任务请求；<br />
  本进程的各个分支是一个小任务，每个小任务中都各自有自己的静态变量，用于完成各自特定的功能；</strong><br />
  <em>在每个小任务执行结束后，都会做一些处理，让本进程准备好接收下一个任务。</em><br />
  总之，不管什么复杂的控制结构，都是可以写成这种被间断调用的“定时器化”的形式。</p>

<h1 id="section-3">4. 定时器执行任务程序结构总结</h1>

<p>  1、每个任务函数不会因外部状态不同而阻塞，<strong>不管外部状态如何，这个任务的本次执行都能够顺利通畅地执行完。</strong><br />
  2、每个任务函数执行时间都很短，有时间限制，都有自己的时间段。<strong>所以不管一个进程的状态如何，它绝对不会影响到其他进程的执行</strong>，整个系统不会因为一个进程而停下来，仍然随着定时器的节拍不断地运行。<br />
  3、在这种结构中，所有被执行的代码都是高效的，因为没有延时等函数。<br />
  4、可以用一个定时器完成多个精确的时间控制任务，事实上整个系统都在精确的时间控制下运行。</p>

<h1 id="section-4">5. 我们追求的是什么</h1>

<p>  从第3章开始，程序的主体逐渐从主进程转移到了定时器中断（从后台转移到前台），也对任务函数进行了一系列改造。</p>

<p>  首先，我想强调这些都是在大量编程时自然产生的，是整个系统越来越复杂的必然结果。</p>

<p>  另外，我们进行了这么多改变到底是在追求什么？我们渴望的系统结构是什么样的？</p>

<p>  在此我想引用《底层工作者手册之嵌入式操作系统内核》中的一段话，也算是为操作系统做个铺垫：<br />
  “在没有操作系统的情况下，C语言是以函数为单位实现功能的，一个函数一个函数串行地执行，一个完整的功能会由多个函数共同完成。然而当软件系统的功能变得多而庞大的时候，这种方法几乎无法使用，因为此时各个功能之间必然会有千丝万缕的联系，不可能依次串行地完成每个功能，各个功能必然需要交替执行。以函数为功能单元的程序很难在执行一个函数的时候转而去执行另外一个不相关的函数，即使是使用一些技巧实现了，也会使整个软件的结构变得混乱不堪，不利于软件的维护和扩展。函数的工作方式就决定了并不适合以它为功能单元运行复杂的程序，在这种情况下就要使用操作系统了。操作系统是对函数运行管理的系统，它可以在一个函数还没有运行完就转而去执行另一个函数，并且还可以恢复到原来的函数继续执行，这样就可以根据需要及时调整到需要运行的函数来满足各种要求。”</p>

<p>  这段话的大概意思是：<br />
  1、传统的过程式程序是以函数为单位执行的。<br />
  2、以函数为单位的程序，在一个函数的执行过程中不能立刻跳转到另一个函数，也就是说可能会耽误另一个函数的响应。<br />
  3、就算在一个函数中嵌入了另一个函数的代码使得另一个函数也能及时得到响应，那也会是整个程序结构混乱，不利于维护和扩展。<br />
  而相比之下，操作系统具有很大的好处：<br />
  1、操作系统中的编程是以功能为单位的。在实现一个任务时根本不需要考虑其他的任务函数，更不需要在一个任务里嵌入另一个任务的代码。<br />
  2、操作系统可以在一个函数没有运行完之前直接跳转到另一个地方运行，并且以后可以恢复到原来地方继续运行。这样就可以及时对重要的函数进行响应。</p>

<hr />

<p>  再来回头看看我们做的更改，我们把占用式程序改为了非占用式程序，实际上就是细化了各个任务，让每个任务函数的单次执行时间很短，也就可以及时地响应其他任务。对比第1章所说的主函数顺序调用的结构，如果把里面的函数全都换成非占用式结构，就能大幅缩短循环时间。当时有么一句话：“在最坏情况下的任务级响应时间取决于整个循环的执行时间”，为什么这里把这句话搬过来，你懂的。</p>

<p>  另外一点，在改为定时器执行任务后，保证了各个任务都有自己固定的时间段执行，每个任务都绝对不会阻塞进程、绝对不会影响到其他任务的运行。这一点和操作系统相比甚至更有优势，因为操作系统的高优先级任务是可以阻塞低优先级任务的，而定时器执行任务结构中的所有任务都一定会及时得到执行。只要能够把这个任务以“定时器化”的形式写入到定时器中断处理程序里，它就绝对不会因为意外而被阻塞（这也是对任务函数的要求之一）。</p>

<hr />

<p>  我们的追求和操作系统是一样的，我们希望各个任务功能独立实现，不要相互影响。同时各个任务都能够及时得到响应。操作系统采用将寄存器入栈的方式保存状态信息，而在定时器执行任务的结构中是用静态变量的方式保存任务信息。</p>

<p>  从第3章到这里介绍的都是定时器中断相关的结构，下一章将介绍一种以外部中断为核心的编程结构。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第4章 占用式与非占用式程序结构]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-4zhang-zhan-yong-shi-yu-fei-zhan-yong-shi-cheng-xu-jie-gou.html"/>
    <updated>2016-09-19T21:39:56+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-4zhang-zhan-yong-shi-yu-fei-zhan-yong-shi-cheng-xu-jie-gou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 什么是占用式程序</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 占用式程序的缺点</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3. 对占用式程序的改造</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4. 改造的本质</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">5. 非占用式程序结构的优势</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">6. 非占用式程序的一般结构</a></li>
</ul>

<h1 id="section">1. 什么是占用式程序</h1>
<p>  一个进程在一个时刻只能处理一个任务。</p>

<p>  每个任务是为了完成一个功能，如果这个功能的实现过程是一直占用进程处理资源的话，就称这个任务函数是占用式程序结构。</p>

<p>  最常见的占用式程序结构就是延时函数了，比如最常用的5ms延时函数</p>

<!-- more -->

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void delay5(unsigned char n)
</span><span class="line">{
</span><span class="line">    unsigned int i;
</span><span class="line">    for(;n&gt;0;n--)
</span><span class="line">        for(i=4700;i&gt;0;i--);	//12MHz，1T
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  在完成5ms功能过程中是一直占用调用它的进程处理资源的，在此期间不能进行其他任务。<br />
  还有一个很常见的占用式程序——数码管扫描，不过在这里我不举数码管扫描的例子，而举更为复杂一点的8*8彩色点阵屏的扫描程序：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void refresh7()
</span><span class="line">{
</span><span class="line">    unsigned char r;
</span><span class="line">    for(r=0;r&lt;8;r++)
</span><span class="line">    {
</span><span class="line">        //扫描红色
</span><span class="line">        DPw = ~(0x01&lt;&lt;r);    //导通指定的行
</span><span class="line">        DPr = ~vm7r[r];    //输出r行8个灯中红色led
</span><span class="line">        DELAY7 (light7);    //亮灯时间长度，时间越长亮度越高
</span><span class="line">        DPw=0xff;
</span><span class="line">        DPr=0xff;
</span><span class="line">        DPg=0xff;
</span><span class="line">        DPb=0xff;
</span><span class="line">        DELAY7 (32-light7);//灭灯时间长度
</span><span class="line">        //为了简洁，这里把绿色和蓝色的扫描程序省略，它们的结构和红色扫描是一样的 
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  这个函数是7色模式下的屏幕扫描程序，调用一次此函数会把整个屏幕扫描一遍。<br />
  r代表行数，r循环8次代表屏幕的8个行；在每次循环里，先导通对应的行和需点亮的灯，然后延时light7个单位，再关闭所有显示，再延时32-light7个单位。</p>

<h1 id="section-1">2. 占用式程序的缺点</h1>

<p>  占用式程序最大的缺点就是执行时间太长，耽误对其他任务的响应。另外就是资源浪费，很多时间浪费在执行中的延时上。<br />
  当然，可以在这些占用式程序中嵌入其他代码以及时处理其他任务，但是这样会造成程序结构混乱，嵌入的其他代码还会影响本程序的执行。如果嵌入的代码功能简单还好，如果功能复杂，尤其是当嵌入的代码也是占用式的，就会严重影响程序执行速度。</p>

<h1 id="section-2">3. 对占用式程序的改造</h1>

<p>  在此还以上面的扫描程序为例，对其进行改造。<br />
  首先，每次调用就扫描8行，耗时太长，现将其改成每次扫描一行：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void refresh7()
</span><span class="line">{
</span><span class="line">    static unsigned char r=0;
</span><span class="line">    //扫描红色
</span><span class="line">    DPw = ~(0x01&lt;&lt;r);	//修改完了再导通指定行
</span><span class="line">    DPr = ~vm7r[r];//送入R灯IO接口显示
</span><span class="line">    DELAY7 (light7);//显示时间长度
</span><span class="line">    DPw=0xff;
</span><span class="line">    DPr=0xff;
</span><span class="line">    DPg=0xff;
</span><span class="line">    DPb=0xff;
</span><span class="line">    DELAY7 (32-light7);//灭灯时间长度
</span><span class="line">    //为了简洁，这里把绿色和蓝色的扫描程序省略，它们的结构和红色扫描是一样的 
</span><span class="line">
</span><span class="line">    r++;
</span><span class="line">    if(r==8)
</span><span class="line">        r=0;
</span><span class="line">   }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  用一个静态变量r来记忆行数，这样每次调用此函数只需扫描一行，执行速度是原来的8倍，可以比较快地响应其他任务了。<br />
  但是这样还不够，每次扫描都会扫描三种颜色，时间还是有点长，下面再次改造，改为每次只扫描一种颜色：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void refresh7()
</span><span class="line">{
</span><span class="line">	static unsigned char r=0;
</span><span class="line">	static unsigned char flagrgb=0;	//当前需要点亮的颜色，0-R,1-G,2-B
</span><span class="line">	flagrgb++;
</span><span class="line">	if(flagrgb==3)	//说明三种颜色都扫描完了
</span><span class="line">	{
</span><span class="line">		flagrgb=0;	//从红色开始扫描
</span><span class="line">		r++;		//开始扫描下一行
</span><span class="line">		if(r==8)	//如果发现行都扫描结束则从第行开始扫描
</span><span class="line">			r=0;
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	switch(flagrgb)
</span><span class="line">	{
</span><span class="line">	case 0:	//扫描红色
</span><span class="line">		DPw = ~(0x01&lt;&lt;r);	//修改完了再导通指定行
</span><span class="line">		DPr = ~vm7r[r];//送入R灯IO接口显示
</span><span class="line">		DELAY7 (light7);//显示时间长度
</span><span class="line">		DPw=0xff;
</span><span class="line">		DPr=0xff;
</span><span class="line">		DPg=0xff;
</span><span class="line">		DPb=0xff;
</span><span class="line">		DELAY7 (32-light7);//灭灯时间长度
</span><span class="line">		break;
</span><span class="line">	case 1:	//扫描绿色	
</span><span class="line">		/*省略代码*/
</span><span class="line">		break;
</span><span class="line">	case 2:	//扫描蓝色
</span><span class="line">		/*省略代码*/
</span><span class="line">		break;
</span><span class="line">	}
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  改造完成之后，执行时间再次缩短，变成了刚才的1/3。<br />
  这下还没完，我们发现每次扫描中都有延时，延时过程中什么也不做，这是极大的浪费，我们需要再此改造，把延时去掉：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void refresh7()
</span><span class="line">{
</span><span class="line">	static unsigned char r=0;
</span><span class="line">	static unsigned char flagrgb=0;	//当前需要点亮的颜色，0-R,1-G,2-B
</span><span class="line">	static unsigned char num=0;
</span><span class="line">	num++;
</span><span class="line">	if(num==32)
</span><span class="line">	{
</span><span class="line">		num=0;
</span><span class="line">		flagrgb++;
</span><span class="line">		if(flagrgb==3)	//说明三种颜色都扫描完了
</span><span class="line">		{
</span><span class="line">			flagrgb=0;	//从红色开始扫描
</span><span class="line">			r++;		//开始扫描下一行
</span><span class="line">			if(r==8)	//如果发现行都扫描结束则从第行开始扫描
</span><span class="line">				r=0;
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	if(num&lt;light7)	//说明需要点亮
</span><span class="line">	{
</span><span class="line">		switch(flagrgb)
</span><span class="line">		{
</span><span class="line">		case 0:	//扫描红色
</span><span class="line">			DPw = ~(0x01&lt;&lt;r);
</span><span class="line">			DPr = ~vm7r[r];//送入R灯IO接口显示
</span><span class="line">			break;
</span><span class="line">		case 1:	//扫描绿色	
</span><span class="line">			DPw = ~(0x01&lt;&lt;r);
</span><span class="line">			DPg = ~vm7g[r];
</span><span class="line">			break;
</span><span class="line">		case 2:	//扫描蓝色
</span><span class="line">			DPw = ~(0x01&lt;&lt;r);
</span><span class="line">			DPb = ~vm7b[r];
</span><span class="line">			break;
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">	else	//说明不需要点亮
</span><span class="line">	{
</span><span class="line">		DPw=0xff;
</span><span class="line">		DPr=0xff;
</span><span class="line">		DPg=0xff;
</span><span class="line">		DPb=0xff;
</span><span class="line">	}
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  现在，这个函数中没有任何延时和循环，执行所消耗的时间是非常少的，可以很快地响应响应其他任务。</p>

<h1 id="section-3">4. 改造的本质</h1>

<p>  上面我们对这个项目的扫描程序进行了“三大改造”，分别是：1、各个行扫描的分离；2、各个颜色扫描的分离；3、延时函数的消除。<br />
  这些改造的本质都是对原程序的分割，把一大坨程序分成多个步骤分别执行，以减小耗时，提高对外部的响应速度。<br />
  还记得在第一章说的主函数顺序调用吗？最后说过这样一句话：“在最坏情况下的任务级响应时间取决于整个循环的执行时间”，而通过这样的改造之后，其实就是在缩短这个循环的时间。<br />
  <strong>但就整个进程的执行来看，有效代码的比例是降低的</strong>，包括上面“三大改造”的第三点 延时函数的消除，看上去是消除了延时函数，提高了执行效率，但从“扫描一次整屏”这个任务来看，其执行的代码量反而是增加的。（但并不是所有的改造都一定会使效率降低，有些改造确实可以达到“消除延时函数”的目的）<br />
  那为什么还要对其进行改造呢，见下节分析。</p>

<h1 id="section-4">5. 非占用式程序结构的优势</h1>

<p>  1、非占用式程序相比于占用式程序，增加了一定的代码，虽然会使整体效率降低，但是提高了各个任务之间的切换速度，可以对各个任务都能很快地响应。这点类似于操作系统，虽然降低了效率，但是各个任务间的快速切换可以达到各个任务“并行处理”的效果，光是这点的好处就已经很大了。</p>

<p>  2、非占用式程序结构可以放进定时器<br />
  第3章已经发现用定时器分配任务的好处，有些简短的代码可以直接放进定时器里。<br />
  在改造之前的扫描程序是不适合放在定时器中断处理程序里执行的，因为太长，可能还没执行完就来了下一个中断。就算勉强执行完了，留给主进程处理其他事情的时间也不多了。<br />
  而改为非占用式之后，可以在中断处理程序里直接调用扫描程序，它会很快地执行完，然后有充足的时间留给其他任务。</p>

<p>  3、非占用式程序并不是一定会降低效率。<br />
  就拿“三大改造”的第三点说明，它虽然形式上消除了延时函数，但是每次调用此函数时对num变量的处理，以及有其产生的相关判断语句，总的代码量比原来的要多。<br />
  但是，这真的就仅仅是这样了吗？改造之前的函数，执行完退出之后所有的led全是熄灭的，只有在此函数执行过程中（延时阶段）才会点亮（传统数码管扫描亦是如此）。<br />
  而改造之后的函数，它的功能就是指定一下每个灯的亮灭，然后立马退出，在执行其他任务的过程中该点亮的灯是在点亮的状态。这样就提高了整体的亮度，在执行其他任务的过程中，从某种意义上说也是在执行当前任务。</p>

<p>  这可能还不能太清楚地说明问题，下面再举一例，传统的按键扫描一般是这样：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">if(key==0)	//key是某个引脚
</span><span class="line">{
</span><span class="line">    delay5(1);
</span><span class="line">    if(key==0)	//确认按键已按下
</span><span class="line">    {
</span><span class="line">        /*do something*/
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  这段代码也是很浪费时间的，中间有个5ms延时白白浪费。<br />
  通过对它改造之后，结合定时器，可以几乎完全地把这5ms时间省出来，把如下代码放进定时器中断处理程序：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static unsigned char keylast;	//保存上次的按键值
</span><span class="line">if(key==0 &amp;&amp; keylast==1)	//检测到一个下降沿
</span><span class="line">{
</span><span class="line">    /*do something*/
</span><span class="line">}
</span><span class="line">keylast=key;</span></code></pre></td></tr></table></div></figure>

<p>  这段代码每5ms执行一次，而执行的时间是非常短的，剩下有大量的时间可留给其他任务。<br />
  <strong>结合定时器进行改造，是真的可以把占用式函数的延时时间节省出来的。</strong></p>

<h1 id="section-5">6. 非占用式程序的一般结构</h1>
<p>  非占用式程序将占用式程序分割执行，需要用到静态变量对当前步骤进行记忆，其一般结构如下：</p>

<p><img src="http://nicekwell.net/images/dan-pian-ji-bian-cheng/feizhanyongshichengxu.jpg" alt="非占用式程序的一般结构" title="非占用式程序的一般结构" /></p>

<p>  逻辑变量计算就是根据任务功能构建出一个合理的逻辑结构。<br />
  对逻辑变量的响应就是对构建好的逻辑结构的结果的响应和执行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第3章 定时器分配任务]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-3zhang-ding-shi-qi-fen-pei-ren-wu.html"/>
    <updated>2016-09-19T21:08:13+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-3zhang-ding-shi-qi-fen-pei-ren-wu</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 用界面函数构成的基础框架</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 结合定时器编程分析</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">3. 任务分割</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4. 定时器分配任务程序结构总结</a></li>
</ul>

<p>  在前两章的内容里都没有考虑中断，本章将引入定时器。引入定时器的原因一些功能需要计时，最常见的就是电子钟了。</p>

<!-- more -->

<p><img src="http://nicekwell.net/images/dan-pian-ji-bian-cheng/dianzizhong.jpeg" alt="电子钟" /></p>

<p>  这是博主2012年的作品，本章将以这个电子钟为背景介绍用定时器分配任务的程序结构，源代码也会在<a href="http://download.csdn.net/detail/nicekwell/6668033" title="从单片机编程到操作系统产生》的附件">附件</a>中给出。</p>

<h1 id="section">1. 用界面函数构成的基础框架</h1>

<p>  这个电子钟的大体硬件租成有：按键、1602显示屏、18b20温度传感器、电源管理模块（两个AD转换和一路PWM输出），由于没用时钟芯片，采用的是8位自动填装定时器每隔200us一次中断来计时的（很准哦）。<br />
  任务处理方面，除计时和日期计算以外，要处理的任务还有：1602显示、按键扫描、温度采集和电源管理（控制电池充放电）。<br />
  需要显示界面有时间显示界面、时间设置界面、电源管理界面和logo界面。每个界面完成不同的功能，时间显示界面就是上图所示的样子，时间设置界面用来完成时间的设置，电源管理界面用来查看当前电池状态以及设置一些充放电参数，logo界面显示3秒后自动跳转到时间显示界面。<br />
  这些界面是如何完成的呢？没错！它就是在主进程里用界面函数完成的。每个界面函数先初始化本界面显示，然后在实现本界面具体功能：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void Page1()
</span><span class="line">{
</span><span class="line">	/*显示初始化*/
</span><span class="line">	/*其他初始化*/
</span><span class="line">
</span><span class="line">	while(1)
</span><span class="line">	{
</span><span class="line">		/*本界面任务*/
</span><span class="line">
</span><span class="line">		if(FlagPage!=1)
</span><span class="line">			return;
</span><span class="line">	}
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  具体而言，例举logo界面的代码如下（因为logo界面代码最短）：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void logopage()	//logo界面，定时器还在工作，只是停留在logo界面s中后返回
</span><span class="line">{
</span><span class="line">	/*下面是显示初始化*/
</span><span class="line">	unsigned char i;
</span><span class="line">	code char logo0[]="hello world!    ";
</span><span class="line">	code char logo1[]="    hello nicek!";
</span><span class="line">	wcom(0x80);
</span><span class="line">	for(i=0;logo0[i]!='\0';i++)
</span><span class="line">		wdat(logo0[i]);
</span><span class="line">	wcom(0x80+0x40);
</span><span class="line">	for(i=0;logo1[i]!='\0';i++)
</span><span class="line">		wdat(logo1[i]);
</span><span class="line">
</span><span class="line">	timenum=15000;	//准备延时3s，这个变量会在定时器里每200us减1
</span><span class="line">	while(timenum)	//等待延时结束，等待过程中仍然对一些按键进行相应
</span><span class="line">	{
</span><span class="line">		switch(keynum)
</span><span class="line">		{
</span><span class="line">		case 5:	//按下返回键
</span><span class="line">			flagpage=0;	//返回后跳转到界面0
</span><span class="line">			return;	//返回
</span><span class="line">		case 6:	//按下灯光键
</span><span class="line">			led=0;	//点亮背光灯
</span><span class="line">			timenumlight=5;	//点亮5s，时间到了之后会在定时器中自动关闭灯光
</span><span class="line">			keynum=7;	//按键响应结束，标志没有按键按下
</span><span class="line">			break;
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">	flagpage=0;	//返回后跳转到界面0
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  有了这些界面函数，也就构成了整个系统的基本框架，但是到目前为止还是没有用到定时器。下面就以“时间显示”界面为例，分析在这个界面中如何结合定时器完成相应功能。</p>

<h1 id="section-1">2. 结合定时器编程分析</h1>

<p>  先来讨论一下在时间显示界面里需要做的这么几个任务：<br />
  1602需要500ms刷新一次。小时和分钟之间有一个冒号“:”需要500ms闪动一次，因为不显示秒，所以当分钟发生变化时整屏也要刷新一次；<br />
  按键扫描5ms扫描一次。如果放在时间界面的主循环里进行按键扫描的话就不用考虑这么多，但是那样做有很多缺点，我这里是把按键扫描当做一个固定的进程，放在定时器中断处理函数里，其他所有界面都能用利用这个扫描结果；<br />
  电源管理500ms检测一次；<br />
  温度采集500ms一次，但比较复杂，涉及到所谓“任务分割”问题，由于比较复杂，会后面单独讨论。</p>

<p>  很自然地想到利用定时器计时来进行，那么定时器会以什么样的工作方式来调配整个系统呢？</p>

<p>  首先，定时器200us一次中断，需要有一个变量累加，当累加到5ms时，进行一次按键扫描；<br />
  然后继续累加，每累加到一个5ms都要进行一次按键扫描……当累加到500ms时进行一次按键扫描、1602刷新显示、电源管理，（温度采集暂且忽略）。</p>

<p>  那么，我们可以直接把这些代码写入中断处理程序吗？比如按键扫描我可以把这段代码写入中断处理程序吗：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for(i=0;i&lt;=6;i++)	//总共7个独立按键
</span><span class="line">{
</span><span class="line">	if(P1&amp;pow2[i]==0)	//pow2[i]就是2的i次方
</span><span class="line">	{
</span><span class="line">		delay5(1);	//延时5ms，以确认是否真的按下
</span><span class="line">		if(P1&amp;pow2[i]==0)
</span><span class="line">		{
</span><span class="line">			keynum=i;
</span><span class="line">			break;
</span><span class="line">		}
</span><span class="line">	}
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  这是显然是不行的，执行完这段代码中的延时函数就有5ms了，而定时器是200us一次中断，一个中断周期里根本执行不完。<br />
  如果把这段代码放到时间界面主循环里是可以的，但是这样的话在其他界面就不能使用（除非也加入相同的代码），正如我上面所说：那样有很多缺点，我这里是把按键扫描当做一个固定的进程，其他所有任务都能用利用这个扫描结果。</p>

<p>  所以这里要提出一个定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间。</strong></p>

<p>  所以我们要想想办法，把按键扫描程序改成了如下，以下代码由中断处理函数调用，每5ms执行一次：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static unsigned char reslast;	//保存上次扫描结果，0-没按下，1-按下
</span><span class="line">unsigned char res;
</span><span class="line">unsigned char i;
</span><span class="line">numforkey=0;
</span><span class="line">res=P1;
</span><span class="line">for(i=0;i&lt;=6;i++)
</span><span class="line">{
</span><span class="line">	if(((res&amp;pow2[i])==0)&amp;&amp;((reslast&amp;pow2[i])!=0))	//这次按下，上次断开
</span><span class="line">		break;
</span><span class="line">}
</span><span class="line">//从这里出来，如果i==7则表示没有按键按下，i&lt;=6的任意一个值表示那个键被按下了
</span><span class="line">keynum=i;
</span><span class="line">reslast=res;</span></code></pre></td></tr></table></div></figure>

<p>  这段代码里面没有延时，执行一次是很快的，而且也可以很好地完成按键扫描，比上面的那种延时扫描更有优势（不占用资源，而且稍加改造可以识别同时按下多个按键）。</p>

<p>  所以，把原则一加上一句，定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间，要想办法把任务改成不占用定时器时间的结构，给主进程让出更多的时间。</strong>关于把“任务改成不占用定时器时间”这个问题会在后面第4章“占用式与非占用式程序结构分析”里详细讨论。</p>

<hr />

<p>  按键扫描在中断处理程序里已经安置妥当了，但请注意当500ms来临时，需要完成的任务有 按键扫描、1602刷新显示、电源管理，（温度采集暂且忽略），定时器中断周期只有200us，现在一下子来了这么多任务，一个中断周期内可以处理完吗？</p>

<p>  为了避免这种风险，我们把定时器中断里的一些任务转移到主进程中（还有另一种方法将在后面“定时器执行任务”的章节中介绍），这就是定时器分配任务的程序结构原则二：<strong>当节拍时间到来时，要处理的任务真的很多，可以通过标志变量通知主进程执行。</strong> <em>但通知让主进程做的事对实时性要求不能太高。</em></p>

<p>  实际上我在电子钟里面把1602刷新就没有放在定时器中断里，而是放到了主进程。在程序里设置了一个flag500ms标志变量，定时器中断处理函数标记变量为1表示到了500ms，时间界面的主循环检测这个变量，当发现这个变量为1时就执行1602刷新。而按键扫描和电源管理由于在任何界面都会用到，并且代码执行速度快，所以把它们放在定时器中断里进行，1602刷新对实时性要求不高，所以可以用定时器通知主进程执行。</p>

<hr />

<p>  下面要说的就是温度采集了，上面为什么没讨论它，就是因为它比较复杂。它既不能满足原则一（在一个定时器中断时间内完成）也不能满足原则二（对实时性要求不高）。</p>

<p>  温度传感器用的是18b20，由单总线协议决定了对它进行一次读写大约需要18ms，而且对实时性要求也很高。</p>

<p>  这里隆重推出一个自己起名的概念——“任务分割”。顺便引出定时器分配任务的程序结构原则三：<strong>当既不满足原则一又不满足原则二，即既不能在一个定时器中断时间里完成又对实时性要求很高的任务，对它进行任务分割。</strong></p>

<p>  下一节将详细介绍任务分割的概念，以及如何对任务进行“分割”。</p>

<h1 id="section-2">3. 任务分割</h1>

<p>  所谓任务分割就是把不能在一个定时器中断时间里完成的任务分割成多个可以在一个定时器中断时间里完成的任务。在这里，把分割完成之后的任务函数仍然放在主进程里。<br />
  要完成任务分割，首先需要让定时器的计时功能可以被外部使用，设一个全局变量TimeNum，然后在定时器中断处理程序里让TimeNum自减：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">unsigned char TimeNum=0;
</span><span class="line">void t0_int() interrupt 1
</span><span class="line">{
</span><span class="line">	/*Do Something*/
</span><span class="line">
</span><span class="line">	if(TimeNum!=0)
</span><span class="line">		TimeNum--;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  这样，外部就可以通过TimeNum变量使用定时器的计时资源了。在主进程里只要这么做就行：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/*Do Something*/
</span><span class="line">TimeNum=100;	//准备等待个定时器中断周期
</span><span class="line">while(TimeNum)	//等待
</span><span class="line">{
</span><span class="line">	/*Do Something*/
</span><span class="line">}
</span><span class="line">/*继续 Do Something*/</span></code></pre></td></tr></table></div></figure>

<p>  可以利用定时器延时之后就可以对主进程里的长任务进行分割了，分割方法就是把原来顺序执行的任务函数，找到合适的节点，在节点处进行合适时间的延时。<br />
  这个步骤做起来是比较麻烦的，因为要进行任务分割的任务一般对时间精确性要求是比较高的（否则直接放到主进程就可以了），需要充分了解运行过程。<strong>既要保证每个节点之间的运行时间小于一个定时器中断周期，又要保证任务时序的正确性。</strong></p>

<p>  需要强调一下，任务分割这个方法是个下策，实在没办法的情况下才进行这种处理，我也只在这个电子钟工程的温度测量用过。<br />
  这种情况在操作系统中也是不好处理的，当某个不能被中断的函数的运行时间确实长于时钟节拍周期的话，也只有先关闭中断，等该函数运行结束后再打开中断。操作系统中把这种函数叫做“临界段”代码。而在电子钟这个例子中，由于要进行精确的计时，是不可以关闭中断的，只有进行任务分割（当然也有其他的处理方式，加个协处理器什么的）。</p>

<p>  下面截取18b20的一段代码，举例说明一下修改的原理。<br />
  修改前代码：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bit ds18b20_init()
</span><span class="line">{
</span><span class="line">	bit dat=0;
</span><span class="line">	dq=1;
</span><span class="line">	delayusx2(5);
</span><span class="line">	dq=0;
</span><span class="line">	delayusx2(200);
</span><span class="line">	delayusx2(200);
</span><span class="line">	dq=1;
</span><span class="line">	delayusx2(50);
</span><span class="line">	dat=dq;
</span><span class="line">	delayusx2(25);
</span><span class="line">	return dat;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  修改后代码：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bit ds18b20_init()
</span><span class="line">{
</span><span class="line">	bit dat=0;
</span><span class="line">	dq=1;
</span><span class="line">	delayusx2(5);    //较短的延时不需要修改，可以在一个中断周期内完成
</span><span class="line">	dq=0;
</span><span class="line">	timenum=4;while(timenum);  //这里原来的800ms延时换成了结合定时器的等待
</span><span class="line">	dq=1;
</span><span class="line">	delayusx2(50);    //延时时间短，不需要分割
</span><span class="line">	dat=dq;
</span><span class="line">	delayusx2(25);    //上次分割到这里大约100us，本次延时时间50us，仍然不需要分割
</span><span class="line">	//到这里实际上init部分的协议已经完成，下面仍然加了一个分割是为了和定时器同步，在这里等待一次定时器中断，保证等待之后有充足的时间执行后续代码
</span><span class="line">	timenum=1;while(timenum);
</span><span class="line">	return dat;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<h1 id="section-3">4. 定时器分配任务程序结构总结</h1>

<p>  1、整个系统有一个主进程：main函数的主循环及其调用的所用任务函数，以及所有任务函数调用的子任务函数。<br />
  这个主进程的特点是所有函数都在一个函数调用链里，运行时精力只能放在一处；优先级低，任何中断所调用的任务都会使其停止工作。</p>

<p>  2、定时器也可开辟一道进程，所有由定时器直接调用的任务都属于这个进程。<br />
  定时器进程可以通过一些标志变量通知主进程进行某种动作，最常用的控制方法是用定时器产生节拍信号，通知主进程进行相应动作;<br />
  同时，定时器也可以直接调用一些函数，在定时器中断处理程序里完成任务。所有由定时器直接调用的程序都属于定时器进程，优先级高于主进程；<br />
  用定时器分配任务有一下三点原则：<br />
  定时器分配任务的程序结构原则一：<strong>定时器中断里的代码执行长度一定不能超过定时器中断时间，要想办法把任务改成不占用定时器时间的结构，给主进程让出更多的时间。</strong><br />
  定时器分配任务的程序结构原则二：<strong>当节拍时间到来时，要处理的任务真的很多，可以通过标志变量通知主进程执行。</strong> <em>但通知让主进程做的事对实时性要求不能太高。</em><br />
  定时器分配任务的程序结构原则三：<strong>当既不满足原则一又不满足原则二，即既不能在一个定时器中断时间里完成又对实时性要求很高的任务，对它进行任务分割。</strong></p>

<p>  3、整个系统来看有两个并行的进程——主进程和定时器进程。主进程一次只能执行一个任务，而定时器进程由于任务一般比较小（如按键扫描、计时、数码管扫描等），所以认为定时器进程的任务也一并完成了。<br />
  看上去就像是多个进程在同时运行，这些进程之间可以通过公共变量进行通信，比如节拍时间的标识变量、计时产生的时间、按键扫描结果变量keynum等，所有其他进程可以有选择地对这些标识变量进行响应。类似于进程间通信。</p>

<hr />

<p>  用定时器命令主函数执行任务的原因有两点：1、利用定时器的时钟节拍使主函数也可以节拍性地执行任务。2、利用主函数构建的逻辑结构。<br />
  对于第1点，该任务的实时性确实会受影响，因为毕竟主函数是用查询方式查询标识变量的。<br />
  但是第2点带来的好处也是非常大的。还拿电子钟举例来说吧，电子钟里面的各个界面之间的逻辑是通过主函数构建出来的，定时器在任何界面都会中断，并且在定时器中执行的任务会通过标识变量向主函数发送信息（比如当前时间、按键扫描结果(我的按键扫描是放在定时器里执行的)等），虽然在各个界面向主函数发送的信息是一样的，但是主函数中的各个界面对这些信息的反应却是不同的（比如各个界面对同一按键的反应是不同的，对定时器提供的时间所做的的反应也是不同的）。
  这些都依赖于主函数所构建出的逻辑结构。</p>

<hr />

<p>  关于这种结构的介绍暂且到此吧，下面将引出一个新的问题。<br />
  注意在3.2节的分析中，有些任务是直接放在定时器里执行的，这些任务都有一些共同的特点——执行时间短。<br />
  执行时间短带来了什么？在1.2节有这么一句话：“任务执行的并行与否是相对而言的。”，在本节的总结中还有这句话：“定时器进程由于任务一般比较小（如按键扫描、计时、数码管扫描等），所以认为定时器进程的任务也一并完成了。”<br />
  定时器的中断处理函数的执行肯定不会被主进程阻挡，这里面的任务全都可以看成是并行的多个进程，它们各自完成不同的功能，把自己的运行结果作为资源供其他进程使用。<br />
  在第5章中将详细分析这种结构，在那一章，我们将会明确我们到底在追求什么，我们要追求的结构到底是什么样的？</p>

<p>  不过在此之前，先要补充一点理论知识，这就是下一章的内容。<br />
  下一章将会分析和明确那些“完成某个任务的函数”到底应该做些什么，哪些东西是有用的。并对这些函数进行改造，分析改造成不同形式的函数有什么样的特点。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第2章 “界面函数”结构]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-2zhang-jie-mian-han-shu-jie-gou.html"/>
    <updated>2016-09-19T20:48:39+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-2zhang-jie-mian-han-shu-jie-gou</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 界面函数一般结构</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 更高的角度分析这种结构</a></li>
</ul>

<p>  这一章将介绍的是主循环调用任务函数的一种非常常用的结构。到目前为止，在主进程的构建方面，除了顺序调用我只用到过这一种构建方式，并且用得非常多。在2011年的电子设计大赛上，笔者就用了这种程序结构获得了安徽省第一的成绩，可见这种结构的威力。之所以叫它“界面函数”结构，是因为它各个函数就像一个个界面一样，在每个界面（函数）中完成某些特定的功能，我没找到这种结构的通用叫法。</p>

<!-- more -->

<p>  在第1章中介绍到由主循环顺序调用其他函数的结构，这种顺序执行的方式是最简单的情况了。当情况复杂时，各个函数之间存在着某种逻辑关系，一个函数执行完毕后可能要根据具体情况决定下一个要执行的是哪个函数，同时也可能由于外部原因需要立马切换到另一个函数里。</p>

<p>  为了让大家更好地理解，举这样一个例子：</p>

<p><em>  一个电子钟，上下左右4个方向键，一个 设置/确定 键，一个返回键，一个背光灯键。<br />
  在正常模式下，显示时间、日期等信息，此时忽略上下左右方向键和返回键，当按下设置键时进入设置模式；<br />
  在设置模式下，通过上下左右方向键来设置时间、日期，按下 设置/确定 键保存设置的信息并返回正常模式，按下返回键取消本次设置并返回正常模式；<br />
  在以上两个模式中的任意模式按下背光灯键就亮灯6秒。</em></p>

<p>  例子中有两个基本模式，每个模式中对外部资源（如按键）的响应方式不同。如果把两种模式代码混合在一起编程的话会造成程序混乱，所以很自然地就想到把两种模式分开控制。这就产生了“界面函数”这种结构，之所以叫它界面函数，是因为它们就像是一个个界面一样，每个界面完成不同的功能。下面先介绍一下这种程序结构的一般形式：</p>

<h1 id="section">1. 界面函数一般结构</h1>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
</pre></td><td class="code"><pre><code class=""><span class="line">unsigned char FlagPage=0;
</span><span class="line">
</span><span class="line">void main()
</span><span class="line">{
</span><span class="line">	/*初始化*/
</span><span class="line">
</span><span class="line">	while(1)
</span><span class="line">	{
</span><span class="line">		if(FlagPage==0)
</span><span class="line">			Task0();
</span><span class="line">		else if(FlagPage==1)
</span><span class="line">			Task1();
</span><span class="line">		else if(FlagPage==2)
</span><span class="line">			Task2();
</span><span class="line">		……
</span><span class="line">	}
</span><span class="line">}
</span><span class="line">
</span><span class="line">void Task0()
</span><span class="line">{
</span><span class="line">	/*Do Something*/
</span><span class="line">	while(1)
</span><span class="line">	{
</span><span class="line">		/*Do Something*/
</span><span class="line">		if(FlagPage!=0)
</span><span class="line">			return;
</span><span class="line">	}
</span><span class="line">}
</span><span class="line">void Task1()
</span><span class="line">{
</span><span class="line">	/*Do Something*/
</span><span class="line">	while(1)
</span><span class="line">	{
</span><span class="line">		/*Do Something*/
</span><span class="line">		if(FlagPage!=1)
</span><span class="line">			return;
</span><span class="line">	}
</span><span class="line">}
</span><span class="line">void Task2()
</span><span class="line">{
</span><span class="line">	/*Do Something*/
</span><span class="line">	while(1)
</span><span class="line">	{
</span><span class="line">		/*Do Something*/
</span><span class="line">		if(FlagPage!=2)
</span><span class="line">			return;
</span><span class="line">	}
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>
<p>  可以看到，主循环其实不进行任何实际功能的处理，它完成的只是调用各个任务函数。对于比较大型复杂的系统，main函数的主循环里根本不放要实际处理的代码，而是把所有任务函数归到一起，根据选择进入相应的任务函数，当处理完该任务之后又会回到主循环，由主循环再次分配任务。<br />
  此时主循环的作用就是调配任务（当然用来调配任务的主循环本身也是一个最基本的任务），而在被调配的任务里面可能还会再次被该任务调配的子任务。<br />
  再来看看被调用的任务函数，这些函数已经不只是完成一些简单功能了，它并不是执行一些固定操作后返回，每个任务函数都有自己的一套控制逻辑，并且“不那么容易返回”。<br />
  这些任务函数同属于一个进程，但是同一时刻只有一个可以运行。当进入某个函数时，可以说进程被这个函数阻塞，其他函数得不到运行。但这也就是我们需要的效果，因为每个函数都有自己的一套控制逻辑，不需要考虑其他界面函数。<br />
  而在函数退出时，可以由该函数本身通过FlagPage指定下一个要进入的函数，或者本来就是由于外部（中断）修改了FlagPage变量才导致该函数退出的。<br />
  这种结构是非常常用的，并且尤其适合那些有多种界面（或者说多种工作模式）的场合。<br />
  比如电子钟里可能有时钟界面、设置界面，再复杂一点有秒表、定时器等界面，从一个界面进入到另一个界面都是由按键控制的。如：在时间界面按下设置键进入到设置界面，按下返回键就进入到logo界面。这一个个界面也就是任务函数，只不过这个任务函数不会自动跳出，而是根据按键情况决定是否跳出、并通知主循环要跳到哪。<strong>每个界面里也会有选择地对其他进程提供的信息进行处理，比如时间界面就会对时间累加进程所提供的时间信息进行显示，同时也会对按键扫描进程提供的按键序号进行处理；而logo界面只会对按键信息进行响应，忽略时间进程提供的时间，但是时间进程仍然在运行。这些进程都是由定时器进行的，在后面会说。</strong><br />
  再如电子设计大赛的小车程序就是，它分为领跑模式、跟随模式、超车模式等，每种模式就是一个界面函数，只不过在运行的过程中不允许有外部操作，完全由每个界面函数本身根据采集到的当前状态信息决定是否退出，并结合一些其他全局变量判断下一个要进入的模式。<br />
  以上把这个典型结构做了一个简单介绍。</p>

<h1 id="section-1">2. 更高的角度分析这种结构</h1>

<p>  在2.1节分析了一下界面函数这种典型结构，在此我想借这种结构分析一下整个系统的构成。把上述系统用下面这个图表示：
<img src="http://nicekwell.net/images/dan-pian-ji-bian-cheng/chengxujiegou.jpg" alt="程序结构示意图" /></p>

<p>  这里面所有函数都是由主函数调用的，属于主进程，并且这些函数也都体现出了系统结构。<br />
  例如在函数1里面想进入函数2，不是直接调用函数2，而是先返回函数1，再由主循环分配到函数2。<br />
  正如前面所说，这种程序结构特别适合于多种“界面”的功能。一般情况下，主进程不会停留在主循环里，而是偶尔退出到主循环重新分配下一个将要进入的函数，大部分时间会停留在某个界面函数里。</p>

<p>  此外，这些函数之间<strong>有一些公共变量，这些变量的作用就是被各个函数使用，甚至用于函数间通信，辅助完成这些函数之间的逻辑结构的构建。</strong>比如1.1节中提到重要的FlagPage变量，这个标志变量就指明了当前工作于哪种工作模式下，任何函数（包括中断进程中的函数）都可以通过改变此变量来切换工作模式。<br />
  <strong>也有一些与函数对应的用于完成特定功能的变量。</strong>比如用于数码管或者显示屏显示的现存，这些显存是有特定用处的，一般其他函数不会使用（但确实是公共变量，是可以被使用的）。</p>

<p>  上面是把变量进行了分类，与之对应地我们也把函数进行分类。<br />
  图中的函数都是所谓的“界面函数”，是用于完成某一特定任务的函数，一般进入这个函数后主进程就会停在里面，当达到特殊目的后返回。而这些“界面函数”也会不断地调用其他函数完成功能，比如延时等。<br />
  这些<strong>被界面函数调用的函数把它们称作“工具函数”</strong>。这些功能函数中有一些是公用的，比如延时函数，很多地方都会用到。而<strong>也有一些是某一个界面函数才会用到的，用于完成这个特殊功能的函数</strong>，比如用于完成屏幕显示用到的屏幕驱动函数、字符显示函数等，这些函数在其他地方几乎不会被调用。<br />
  这些函数、变量结构是在编程中自然产生的，在此将它们明确分类一下，整个系统的构成有：</p>

<ul>
  <li>1、<strong>整体的程序框架是由各个界面函数和少数关键的全局变量构建起来的。</strong>这是构成系统的主体框架。</li>
  <li>2、每个界面函数在完成特定功能时，会携带一些为自己服务的“私有的”变量和函数。</li>
  <li>3、为整个框架服务的还有一些常用的变量和函数，它们完成的是一些通用功能，可以把它们理解为“库函数”。</li>
</ul>

<hr />

<p>  需要提一下，到目前为止讨论的程序结构都没有考虑中断，或者说到目前为止都是把中断当作程序运行过程中的特殊情况处理，并没有融入到整个系统构建的问题内讨论，但是中断确实是存在的。请大家思考一下这种情况会发生什么事情：主进程所构建的程序框架会有一些服务函数，这些服务函数在中断处理程序里也可能会被用到。比如主进程在调用延时函数时被中断，而中断处理程序也调用了该延时函数，这会怎么样呢？<br />
  这就是所谓“函数重入”问题，在此不想过多地讨论该问题，要知道51单片机的编译器keil默认是不支持函数重入的（事实上，如果你这样做了编译器会发出警告的）。<br />
  所以，至少对于51单片机编程来说，在遇到多个进程编程时要注意这样一个原则：中断处理程序不要调用到可能被中断的函数。必要时可以为中断进程单独写一个服务函数，函数内容可能跟主进程中的某个函数一模一样，但这样可以避免上述问题。</p>

<p>  以上就是对“界面函数”这个典型结构的介绍，也分析了整个系统的构成。但是，正如上面说过的，这些都是对一个进程的结构的讨论，并没有涉及到中断。后面的内容会引入中断，甚至到最后把所有的任务都放到中断处理函数里，你会发现把任务放到中断处理函数里有着巨大的优势。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第1章 主函数顺序调用]]></title>
    <link href="http://nicekwell.net/blog/20160919/di-1zhang-zhu-han-shu-shun-xu-diao-yong.html"/>
    <updated>2016-09-19T18:38:40+08:00</updated>
    <id>http://nicekwell.net/blog/20160919/di-1zhang-zhu-han-shu-shun-xu-diao-yong</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1. 主函数顺序调用的一般结构</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2. 主函数顺序调用结构的特点</a></li>
</ul>

<p>  写过单片机程序都知道，在main函数的结尾会有个 while(1) 循环，它就是单片机的归宿。</p>

<p>  在不考虑中断的情况下，整个单片机的最根本任务就是这个循环，由于在主函数里，在此我们称它为“主循环”，认为main函数及其调用的所有子函数（以及子函数调用的子函数）都在“主进程”里。</p>

<!-- more -->

<h1 id="section">1. 主函数顺序调用的一般结构</h1>

<p>  这种结构基本上都是在main函数开始完成一些初始化,然后在主循环里周期性地调用一些函数:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void main()
</span><span class="line">{
</span><span class="line">    /*模块初始化*/
</span><span class="line">    while(1)
</span><span class="line">    {
</span><span class="line">        Fun1();
</span><span class="line">        Fun2();
</span><span class="line">        ......
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>  在初学单片机时，大部分精力都放在单片机和各个模块的驱动上，所以在开始相当长的一段时间里采用的都是这种程序结构。</p>

<p>  而Fun1、Fun2……这些函数完成的功能也都是比较简单的，每个函数完成一个简单的小功能，然后顺序执行就可以组合完成某个功能。</p>

<p>  这些函数虽然功能简单，但是占用CPU资源不一定少，比如最简单的一个独立按键扫描程序：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sbit key=P1^0;
</span><span class="line">unsigned char keyscan()	//返回0代表按下，1代表没按下
</span><span class="line">{
</span><span class="line">    if(key==0)	//说明按键按下
</span><span class="line">    {
</span><span class="line">	delay5(1);	//延时5ms去抖
</span><span class="line">	if(key==0)	//确认按键按下
</span><span class="line">	{
</span><span class="line">            while(key==0);//等待按键释放
</span><span class="line">            return 0;
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    return 1;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>
<p>  这是一个功能很简单的函数，主函数调用它进行按键扫描。注意到：<br />
  1、这个程序里有一个5ms延时函数，在延时的这段时间里单片机运行一些无意义的指令消耗时间。在此期间其他任务得不到运行，整个进程阻塞在延时函数这个地方。<br />
  2、如果按键一直按下没有释放的话，程序将停留在while(key==0); 处，此时主进程里的其他函数都得不到执行。</p>

<h1 id="section-1">2. 主函数顺序调用结构的特点</h1>
<p>  第一点，正如这种结构的名称是“顺序调用”，任务之间的运行顺序是固定不变的，各个任务之间没有优先级的区别，它只适合完成周期性循环的工作。<br />
  第二点，一个任务运行时，其他任务得不到执行。如果其中某个任务由于某种原因卡住了，它将阻塞整个进程的运行。<br />
  第二点能否接受呢，要看具体情况。比如每个任务需要5ms的执行时间（内部可能有一些必要的延时函数），总共四个任务。如果整个单片机系统完成的只是简单的人机交互之类的功能，这是完全可以接受的，因为我们根本察觉不到每个任务在分开运行，在我们看来它们就是并行的。但是如果完成的是像通信协议之类的驱动的话，这是接受不了的，某个任务在执行的过程中可能其他任务有更迫切的需求。</p>

<p>  任务执行的并行与否是相对而言的，要根据具体的情况。如果我们的要求不高，用这种简单的结构当然是最方便的，但是这种简单的结构也确实存在很多不足，有很多可以改进的地方。这是接下来几章要讨论的问题。</p>

<p>  在此我们明确一下这种结构的特点：<br />
<strong>  1、由主循环调用的任务的执行顺序是固定的。<br />
  2、由主循环调用的任务都只能单独地运行，进入一个任务，就不能处理其他任务。<br />
  3、这些任务执行时间一般会比较长（相对后面几章改造过的任务函数而言），某一个任务里面的延时函数会造成整个进程被延时。</strong></p>

<p>  在操作系统的书籍中把这种结构也叫做“前后台系统”，他们把主循环称作后台，中断称作前台。用操作系统的语言来说“应用程序是一个无限的循环，循环中调用相应的函数完成相应的功能”。由于函数是循环调用的，所以“在最坏情况下的任务级响应时间取决于整个循环的执行时间”。<br />
  本文在这里没有考虑中断，也就纯粹讨论的是后台系统。</p>

<p>  第2章将介绍如何构建复杂的后台系统结构，并将程序框架和任务函数分立，明确系统的构建和任务函数的实现在整个单片机编程系统中的区别。而不要混为一谈盲目的构建系统。<br />
  在接下来的第3章到第6章将会发现程序的主体逐渐从后台转移到了前台，在转移的过程中会对任务函数进行改造，并明确这些改造的目的和优势。</p>

]]></content>
  </entry>
  
</feed>
